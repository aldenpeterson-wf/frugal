#
# Autogenerated by Frugal Compiler (2.0.0-RC5)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#



import asyncio
from datetime import timedelta
import inspect

from frugal.aio.processor import FBaseProcessor
from frugal.aio.processor import FProcessorFunction
from frugal.exceptions import FApplicationException
from frugal.exceptions import FMessageSizeException
from frugal.exceptions import FRateLimitException
from frugal.exceptions import FTimeoutException
from frugal.middleware import Method
from frugal.transport import TMemoryOutputBuffer
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType
import actual_base.python.ttypes
import actual_base.python.constants
import actual_base.python.f_BaseFoo
import validStructs.ttypes
import validStructs.constants
import validStructs.f_BaseFoo
import ValidTypes.ttypes
import ValidTypes.constants
import ValidTypes.f_BaseFoo
import subdir_include.ttypes
import subdir_include.constants
import subdir_include.f_BaseFoo
from .ttypes import *


class Iface(actual_base.python.f_BaseFoo.Iface):
    """
    This is a thrift service. Frugal will generate bindings that include
    a frugal Context for each service call.
    """

    async def ping(self, ctx):
        """
        Ping the server.
        
        Args:
            ctx: FContext
        """
        pass

    async def blah(self, ctx, num, Str, event):
        """
        Blah the server.
        
        Args:
            ctx: FContext
            num: int (signed 32 bits)
            Str: string
            event: Event
        """
        pass

    async def oneWay(self, ctx, id, req):
        """
        oneway methods don't receive a response from the server.
        
        Args:
            ctx: FContext
            id: int (signed 64 bits)
            req: dict of <int (signed 32 bits), string>
        """
        pass

    async def bin_method(self, ctx, bin, Str):
        """
        Args:
            ctx: FContext
            bin: binary string
            Str: string
        """
        pass

    async def param_modifiers(self, ctx, opt_num, default_num, req_num):
        """
        Args:
            ctx: FContext
            opt_num: int (signed 32 bits)
            default_num: int (signed 32 bits)
            req_num: int (signed 32 bits)
        """
        pass

    async def underlying_types_test(self, ctx, list_type, set_type):
        """
        Args:
            ctx: FContext
            list_type: list of int (signed 64 bits)
            set_type: set of int (signed 64 bits)
        """
        pass

    async def getThing(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    async def getMyInt(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    async def use_subdir_struct(self, ctx, a):
        """
        Args:
            ctx: FContext
            a: subdir_include.A
        """
        pass


class Client(actual_base.python.f_BaseFoo.Client, Iface):

    def __init__(self, transport, protocol_factory, middleware=None):
        """
        Create a new Client with a transport and protocol factory.

        Args:
            transport: FTransport
            protocol_factory: FProtocolFactory
            middleware: ServiceMiddleware or list of ServiceMiddleware
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]
        super(Client, self).__init__(transport, protocol_factory,
                                     middleware=middleware)
        self._methods.update({
            'ping': Method(self._ping, middleware),
            'blah': Method(self._blah, middleware),
            'oneWay': Method(self._oneWay, middleware),
            'bin_method': Method(self._bin_method, middleware),
            'param_modifiers': Method(self._param_modifiers, middleware),
            'underlying_types_test': Method(self._underlying_types_test, middleware),
            'getThing': Method(self._getThing, middleware),
            'getMyInt': Method(self._getMyInt, middleware),
            'use_subdir_struct': Method(self._use_subdir_struct, middleware),
        })

    async def ping(self, ctx):
        """
        Ping the server.
        
        Args:
            ctx: FContext
        """
        return await self._methods['ping']([ctx])

    async def _ping(self, ctx):
        timeout = ctx.timeout / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_ping(ctx, future))
        try:
            await self._send_ping(ctx)
            result = await timed_future
        except asyncio.TimeoutError:
            raise FTimeoutException('ping timed out after {} milliseconds'.format(ctx.timeout))
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_ping(self, ctx):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('ping', TMessageType.CALL, 0)
        args = ping_args()
        args.write(oprot)
        oprot.writeMessageEnd()
        await self._transport.send(buffer.getvalue())

    def _recv_ping(self, ctx, future):
        def ping_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
                    future.set_exception(FMessageSizeException.response(x.message))
                    return
                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
                    future.set_exception(FRateLimitException(x.message))
                    return
                future.set_exception(x)
                return
            result = ping_result()
            result.read(iprot)
            iprot.readMessageEnd()
            future.set_result(None)
        return ping_callback

    async def blah(self, ctx, num, Str, event):
        """
        Blah the server.
        
        Args:
            ctx: FContext
            num: int (signed 32 bits)
            Str: string
            event: Event
        """
        return await self._methods['blah']([ctx, num, Str, event])

    async def _blah(self, ctx, num, Str, event):
        timeout = ctx.timeout / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_blah(ctx, future))
        try:
            await self._send_blah(ctx, num, Str, event)
            result = await timed_future
        except asyncio.TimeoutError:
            raise FTimeoutException('blah timed out after {} milliseconds'.format(ctx.timeout))
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_blah(self, ctx, num, Str, event):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('blah', TMessageType.CALL, 0)
        args = blah_args()
        args.num = num
        args.Str = Str
        args.event = event
        args.write(oprot)
        oprot.writeMessageEnd()
        await self._transport.send(buffer.getvalue())

    def _recv_blah(self, ctx, future):
        def blah_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
                    future.set_exception(FMessageSizeException.response(x.message))
                    return
                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
                    future.set_exception(FRateLimitException(x.message))
                    return
                future.set_exception(x)
                return
            result = blah_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.awe is not None:
                future.set_exception(result.awe)
                return
            if result.api is not None:
                future.set_exception(result.api)
                return
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "blah failed: unknown result")
            future.set_exception(x)
            raise x
        return blah_callback

    async def oneWay(self, ctx, id, req):
        """
        oneway methods don't receive a response from the server.
        
        Args:
            ctx: FContext
            id: int (signed 64 bits)
            req: dict of <int (signed 32 bits), string>
        """
        return await self._methods['oneWay']([ctx, id, req])

    async def _oneWay(self, ctx, id, req):
        await self._send_oneWay(ctx, id, req)

    async def _send_oneWay(self, ctx, id, req):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('oneWay', TMessageType.CALL, 0)
        args = oneWay_args()
        args.id = id
        args.req = req
        args.write(oprot)
        oprot.writeMessageEnd()
        await self._transport.send(buffer.getvalue())

    async def bin_method(self, ctx, bin, Str):
        """
        Args:
            ctx: FContext
            bin: binary string
            Str: string
        """
        return await self._methods['bin_method']([ctx, bin, Str])

    async def _bin_method(self, ctx, bin, Str):
        timeout = ctx.timeout / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_bin_method(ctx, future))
        try:
            await self._send_bin_method(ctx, bin, Str)
            result = await timed_future
        except asyncio.TimeoutError:
            raise FTimeoutException('bin_method timed out after {} milliseconds'.format(ctx.timeout))
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_bin_method(self, ctx, bin, Str):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('bin_method', TMessageType.CALL, 0)
        args = bin_method_args()
        args.bin = bin
        args.Str = Str
        args.write(oprot)
        oprot.writeMessageEnd()
        await self._transport.send(buffer.getvalue())

    def _recv_bin_method(self, ctx, future):
        def bin_method_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
                    future.set_exception(FMessageSizeException.response(x.message))
                    return
                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
                    future.set_exception(FRateLimitException(x.message))
                    return
                future.set_exception(x)
                return
            result = bin_method_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.api is not None:
                future.set_exception(result.api)
                return
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "bin_method failed: unknown result")
            future.set_exception(x)
            raise x
        return bin_method_callback

    async def param_modifiers(self, ctx, opt_num, default_num, req_num):
        """
        Args:
            ctx: FContext
            opt_num: int (signed 32 bits)
            default_num: int (signed 32 bits)
            req_num: int (signed 32 bits)
        """
        return await self._methods['param_modifiers']([ctx, opt_num, default_num, req_num])

    async def _param_modifiers(self, ctx, opt_num, default_num, req_num):
        timeout = ctx.timeout / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_param_modifiers(ctx, future))
        try:
            await self._send_param_modifiers(ctx, opt_num, default_num, req_num)
            result = await timed_future
        except asyncio.TimeoutError:
            raise FTimeoutException('param_modifiers timed out after {} milliseconds'.format(ctx.timeout))
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_param_modifiers(self, ctx, opt_num, default_num, req_num):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('param_modifiers', TMessageType.CALL, 0)
        args = param_modifiers_args()
        args.opt_num = opt_num
        args.default_num = default_num
        args.req_num = req_num
        args.write(oprot)
        oprot.writeMessageEnd()
        await self._transport.send(buffer.getvalue())

    def _recv_param_modifiers(self, ctx, future):
        def param_modifiers_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
                    future.set_exception(FMessageSizeException.response(x.message))
                    return
                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
                    future.set_exception(FRateLimitException(x.message))
                    return
                future.set_exception(x)
                return
            result = param_modifiers_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "param_modifiers failed: unknown result")
            future.set_exception(x)
            raise x
        return param_modifiers_callback

    async def underlying_types_test(self, ctx, list_type, set_type):
        """
        Args:
            ctx: FContext
            list_type: list of int (signed 64 bits)
            set_type: set of int (signed 64 bits)
        """
        return await self._methods['underlying_types_test']([ctx, list_type, set_type])

    async def _underlying_types_test(self, ctx, list_type, set_type):
        timeout = ctx.timeout / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_underlying_types_test(ctx, future))
        try:
            await self._send_underlying_types_test(ctx, list_type, set_type)
            result = await timed_future
        except asyncio.TimeoutError:
            raise FTimeoutException('underlying_types_test timed out after {} milliseconds'.format(ctx.timeout))
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_underlying_types_test(self, ctx, list_type, set_type):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('underlying_types_test', TMessageType.CALL, 0)
        args = underlying_types_test_args()
        args.list_type = list_type
        args.set_type = set_type
        args.write(oprot)
        oprot.writeMessageEnd()
        await self._transport.send(buffer.getvalue())

    def _recv_underlying_types_test(self, ctx, future):
        def underlying_types_test_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
                    future.set_exception(FMessageSizeException.response(x.message))
                    return
                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
                    future.set_exception(FRateLimitException(x.message))
                    return
                future.set_exception(x)
                return
            result = underlying_types_test_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "underlying_types_test failed: unknown result")
            future.set_exception(x)
            raise x
        return underlying_types_test_callback

    async def getThing(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return await self._methods['getThing']([ctx])

    async def _getThing(self, ctx):
        timeout = ctx.timeout / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_getThing(ctx, future))
        try:
            await self._send_getThing(ctx)
            result = await timed_future
        except asyncio.TimeoutError:
            raise FTimeoutException('getThing timed out after {} milliseconds'.format(ctx.timeout))
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_getThing(self, ctx):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('getThing', TMessageType.CALL, 0)
        args = getThing_args()
        args.write(oprot)
        oprot.writeMessageEnd()
        await self._transport.send(buffer.getvalue())

    def _recv_getThing(self, ctx, future):
        def getThing_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
                    future.set_exception(FMessageSizeException.response(x.message))
                    return
                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
                    future.set_exception(FRateLimitException(x.message))
                    return
                future.set_exception(x)
                return
            result = getThing_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "getThing failed: unknown result")
            future.set_exception(x)
            raise x
        return getThing_callback

    async def getMyInt(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return await self._methods['getMyInt']([ctx])

    async def _getMyInt(self, ctx):
        timeout = ctx.timeout / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_getMyInt(ctx, future))
        try:
            await self._send_getMyInt(ctx)
            result = await timed_future
        except asyncio.TimeoutError:
            raise FTimeoutException('getMyInt timed out after {} milliseconds'.format(ctx.timeout))
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_getMyInt(self, ctx):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('getMyInt', TMessageType.CALL, 0)
        args = getMyInt_args()
        args.write(oprot)
        oprot.writeMessageEnd()
        await self._transport.send(buffer.getvalue())

    def _recv_getMyInt(self, ctx, future):
        def getMyInt_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
                    future.set_exception(FMessageSizeException.response(x.message))
                    return
                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
                    future.set_exception(FRateLimitException(x.message))
                    return
                future.set_exception(x)
                return
            result = getMyInt_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "getMyInt failed: unknown result")
            future.set_exception(x)
            raise x
        return getMyInt_callback

    async def use_subdir_struct(self, ctx, a):
        """
        Args:
            ctx: FContext
            a: subdir_include.A
        """
        return await self._methods['use_subdir_struct']([ctx, a])

    async def _use_subdir_struct(self, ctx, a):
        timeout = ctx.timeout / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_use_subdir_struct(ctx, future))
        try:
            await self._send_use_subdir_struct(ctx, a)
            result = await timed_future
        except asyncio.TimeoutError:
            raise FTimeoutException('use_subdir_struct timed out after {} milliseconds'.format(ctx.timeout))
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_use_subdir_struct(self, ctx, a):
        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
        oprot = self._protocol_factory.get_protocol(buffer)
        oprot.write_request_headers(ctx)
        oprot.writeMessageBegin('use_subdir_struct', TMessageType.CALL, 0)
        args = use_subdir_struct_args()
        args.a = a
        args.write(oprot)
        oprot.writeMessageEnd()
        await self._transport.send(buffer.getvalue())

    def _recv_use_subdir_struct(self, ctx, future):
        def use_subdir_struct_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
                    future.set_exception(FMessageSizeException.response(x.message))
                    return
                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
                    future.set_exception(FRateLimitException(x.message))
                    return
                future.set_exception(x)
                return
            result = use_subdir_struct_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "use_subdir_struct failed: unknown result")
            future.set_exception(x)
            raise x
        return use_subdir_struct_callback


class Processor(actual_base.python.f_BaseFoo.Processor):

    def __init__(self, handler, middleware=None):
        """
        Create a new Processor.

        Args:
            handler: Iface
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]

        super(Processor, self).__init__(handler, middleware=middleware)
        self.add_to_processor_map('ping', _ping(Method(handler.ping, middleware), self.get_write_lock()))
        self.add_to_processor_map('blah', _blah(Method(handler.blah, middleware), self.get_write_lock()))
        self.add_to_processor_map('oneWay', _oneWay(Method(handler.oneWay, middleware), self.get_write_lock()))
        self.add_to_processor_map('bin_method', _bin_method(Method(handler.bin_method, middleware), self.get_write_lock()))
        self.add_to_processor_map('param_modifiers', _param_modifiers(Method(handler.param_modifiers, middleware), self.get_write_lock()))
        self.add_to_processor_map('underlying_types_test', _underlying_types_test(Method(handler.underlying_types_test, middleware), self.get_write_lock()))
        self.add_to_processor_map('getThing', _getThing(Method(handler.getThing, middleware), self.get_write_lock()))
        self.add_to_processor_map('getMyInt', _getMyInt(Method(handler.getMyInt, middleware), self.get_write_lock()))
        self.add_to_processor_map('use_subdir_struct', _use_subdir_struct(Method(handler.use_subdir_struct, middleware), self.get_write_lock()))


class _ping(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = ping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ping_result()
        try:
            ret = self._handler([ctx])
            if inspect.iscoroutine(ret):
                ret = await ret
        except FRateLimitException as ex:
            async with self._write_lock:
                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "ping", ex.message)
                return
        except Exception as e:
            async with self._write_lock:
                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "ping", e.args[0])
            raise e from None
        async with self._write_lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('ping', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except FMessageSizeException as e:
                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "ping", e.args[0])


class _blah(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = blah_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = blah_result()
        try:
            ret = self._handler([ctx, args.num, args.Str, args.event])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except FRateLimitException as ex:
            async with self._write_lock:
                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "blah", ex.message)
                return
        except AwesomeException as awe:
            result.awe = awe
        except actual_base.python.ttypes.api_exception as api:
            result.api = api
        except Exception as e:
            async with self._write_lock:
                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "blah", e.args[0])
            raise e from None
        async with self._write_lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('blah', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except FMessageSizeException as e:
                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "blah", e.args[0])


class _oneWay(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = oneWay_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            ret = self._handler([ctx, args.id, args.req])
            if inspect.iscoroutine(ret):
                ret = await ret
        except FRateLimitException as ex:
            async with self._write_lock:
                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "oneWay", ex.message)
                return
        except Exception as e:
            raise e from None


class _bin_method(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = bin_method_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = bin_method_result()
        try:
            ret = self._handler([ctx, args.bin, args.Str])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except FRateLimitException as ex:
            async with self._write_lock:
                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "bin_method", ex.message)
                return
        except actual_base.python.ttypes.api_exception as api:
            result.api = api
        except Exception as e:
            async with self._write_lock:
                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "bin_method", e.args[0])
            raise e from None
        async with self._write_lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('bin_method', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except FMessageSizeException as e:
                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "bin_method", e.args[0])


class _param_modifiers(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = param_modifiers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = param_modifiers_result()
        try:
            ret = self._handler([ctx, args.opt_num, args.default_num, args.req_num])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except FRateLimitException as ex:
            async with self._write_lock:
                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "param_modifiers", ex.message)
                return
        except Exception as e:
            async with self._write_lock:
                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "param_modifiers", e.args[0])
            raise e from None
        async with self._write_lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('param_modifiers', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except FMessageSizeException as e:
                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "param_modifiers", e.args[0])


class _underlying_types_test(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = underlying_types_test_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = underlying_types_test_result()
        try:
            ret = self._handler([ctx, args.list_type, args.set_type])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except FRateLimitException as ex:
            async with self._write_lock:
                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "underlying_types_test", ex.message)
                return
        except Exception as e:
            async with self._write_lock:
                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "underlying_types_test", e.args[0])
            raise e from None
        async with self._write_lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('underlying_types_test', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except FMessageSizeException as e:
                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "underlying_types_test", e.args[0])


class _getThing(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = getThing_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getThing_result()
        try:
            ret = self._handler([ctx])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except FRateLimitException as ex:
            async with self._write_lock:
                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "getThing", ex.message)
                return
        except Exception as e:
            async with self._write_lock:
                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "getThing", e.args[0])
            raise e from None
        async with self._write_lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getThing', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except FMessageSizeException as e:
                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "getThing", e.args[0])


class _getMyInt(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = getMyInt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMyInt_result()
        try:
            ret = self._handler([ctx])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except FRateLimitException as ex:
            async with self._write_lock:
                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "getMyInt", ex.message)
                return
        except Exception as e:
            async with self._write_lock:
                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "getMyInt", e.args[0])
            raise e from None
        async with self._write_lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('getMyInt', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except FMessageSizeException as e:
                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "getMyInt", e.args[0])


class _use_subdir_struct(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = use_subdir_struct_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = use_subdir_struct_result()
        try:
            ret = self._handler([ctx, args.a])
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except FRateLimitException as ex:
            async with self._write_lock:
                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "use_subdir_struct", ex.message)
                return
        except Exception as e:
            async with self._write_lock:
                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "use_subdir_struct", e.args[0])
            raise e from None
        async with self._write_lock:
            try:
                oprot.write_response_headers(ctx)
                oprot.writeMessageBegin('use_subdir_struct', TMessageType.REPLY, 0)
                result.write(oprot)
                oprot.writeMessageEnd()
                oprot.get_transport().flush()
            except FMessageSizeException as e:
                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "use_subdir_struct", e.args[0])


def _write_application_exception(ctx, oprot, typ, method, message):
    x = TApplicationException(type=typ, message=message)
    oprot.write_response_headers(ctx)
    oprot.writeMessageBegin(method, TMessageType.EXCEPTION, 0)
    x.write(oprot)
    oprot.writeMessageEnd()
    oprot.get_transport().flush()
    return x

class ping_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        oprot.writeStructBegin('ping_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class ping_result(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        oprot.writeStructBegin('ping_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class blah_args(object):
    """
    Attributes:
     - num
     - Str
     - event
    """
    def __init__(self, num=None, Str=None, event=None):
        self.num = num
        self.Str = Str
        self.event = event

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.Str = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.event = Event()
                    self.event.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        oprot.writeStructBegin('blah_args')
        if self.num is not None:
            oprot.writeFieldBegin('num', TType.I32, 1)
            oprot.writeI32(self.num)
            oprot.writeFieldEnd()
        if self.Str is not None:
            oprot.writeFieldBegin('Str', TType.STRING, 2)
            oprot.writeString(self.Str)
            oprot.writeFieldEnd()
        if self.event is not None:
            oprot.writeFieldBegin('event', TType.STRUCT, 3)
            self.event.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.num)
        value = (value * 31) ^ hash(self.Str)
        value = (value * 31) ^ hash(self.event)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class blah_result(object):
    """
    Attributes:
     - success
     - awe
     - api
    """
    def __init__(self, success=None, awe=None, api=None):
        self.success = success
        self.awe = awe
        self.api = api

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.awe = AwesomeException()
                    self.awe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.api = actual_base.python.ttypes.api_exception()
                    self.api.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        oprot.writeStructBegin('blah_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.awe is not None:
            oprot.writeFieldBegin('awe', TType.STRUCT, 1)
            self.awe.write(oprot)
            oprot.writeFieldEnd()
        if self.api is not None:
            oprot.writeFieldBegin('api', TType.STRUCT, 2)
            self.api.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.awe)
        value = (value * 31) ^ hash(self.api)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class oneWay_args(object):
    """
    Attributes:
     - id
     - req
    """
    def __init__(self, id=None, req=None):
        self.id = id
        self.req = req

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.req = {}
                    (_, _, elem42) = iprot.readMapBegin()
                    for _ in range(elem42):
                        elem44 = iprot.readI32()
                        elem43 = iprot.readString()
                        self.req[elem44] = elem43
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        oprot.writeStructBegin('oneWay_args')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.MAP, 2)
            oprot.writeMapBegin(TType.I32, TType.STRING, len(self.req))
            for elem46, elem45 in self.req.items():
                oprot.writeI32(elem46)
                oprot.writeString(elem45)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.id)
        value = (value * 31) ^ hash(self.req)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class bin_method_args(object):
    """
    Attributes:
     - bin
     - Str
    """
    def __init__(self, bin=None, Str=None):
        self.bin = bin
        self.Str = Str

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.bin = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.Str = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        oprot.writeStructBegin('bin_method_args')
        if self.bin is not None:
            oprot.writeFieldBegin('bin', TType.STRING, 1)
            oprot.writeBinary(self.bin)
            oprot.writeFieldEnd()
        if self.Str is not None:
            oprot.writeFieldBegin('Str', TType.STRING, 2)
            oprot.writeString(self.Str)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.bin)
        value = (value * 31) ^ hash(self.Str)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class bin_method_result(object):
    """
    Attributes:
     - success
     - api
    """
    def __init__(self, success=None, api=None):
        self.success = success
        self.api = api

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.api = actual_base.python.ttypes.api_exception()
                    self.api.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        oprot.writeStructBegin('bin_method_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        if self.api is not None:
            oprot.writeFieldBegin('api', TType.STRUCT, 1)
            self.api.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        value = (value * 31) ^ hash(self.api)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class param_modifiers_args(object):
    """
    Attributes:
     - opt_num
     - default_num
     - req_num
    """
    def __init__(self, opt_num=None, default_num=None, req_num=None):
        self.opt_num = opt_num
        self.default_num = default_num
        self.req_num = req_num

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.opt_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.default_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.req_num = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        oprot.writeStructBegin('param_modifiers_args')
        if self.opt_num is not None:
            oprot.writeFieldBegin('opt_num', TType.I32, 1)
            oprot.writeI32(self.opt_num)
            oprot.writeFieldEnd()
        if self.default_num is not None:
            oprot.writeFieldBegin('default_num', TType.I32, 2)
            oprot.writeI32(self.default_num)
            oprot.writeFieldEnd()
        if self.req_num is not None:
            oprot.writeFieldBegin('req_num', TType.I32, 3)
            oprot.writeI32(self.req_num)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.req_num is None:
            raise TProtocol.TProtocolException(message='Required field req_num is unset!')
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.opt_num)
        value = (value * 31) ^ hash(self.default_num)
        value = (value * 31) ^ hash(self.req_num)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class param_modifiers_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        oprot.writeStructBegin('param_modifiers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class underlying_types_test_args(object):
    """
    Attributes:
     - list_type
     - set_type
    """
    def __init__(self, list_type=None, set_type=None):
        self.list_type = list_type
        self.set_type = set_type

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.list_type = []
                    (_, elem47) = iprot.readListBegin()
                    for _ in range(elem47):
                        elem48 = iprot.readI64()
                        self.list_type.append(elem48)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.set_type = set()
                    (_, elem49) = iprot.readSetBegin()
                    for _ in range(elem49):
                        elem50 = iprot.readI64()
                        self.set_type.add(elem50)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        oprot.writeStructBegin('underlying_types_test_args')
        if self.list_type is not None:
            oprot.writeFieldBegin('list_type', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.list_type))
            for elem51 in self.list_type:
                oprot.writeI64(elem51)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.set_type is not None:
            oprot.writeFieldBegin('set_type', TType.SET, 2)
            oprot.writeSetBegin(TType.I64, len(self.set_type))
            for elem52 in self.set_type:
                oprot.writeI64(elem52)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.list_type)
        value = (value * 31) ^ hash(self.set_type)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class underlying_types_test_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_, elem53) = iprot.readListBegin()
                    for _ in range(elem53):
                        elem54 = iprot.readI64()
                        self.success.append(elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        oprot.writeStructBegin('underlying_types_test_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I64, len(self.success))
            for elem55 in self.success:
                oprot.writeI64(elem55)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getThing_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        oprot.writeStructBegin('getThing_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getThing_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = validStructs.ttypes.Thing()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        oprot.writeStructBegin('getThing_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMyInt_args(object):
    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        oprot.writeStructBegin('getMyInt_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class getMyInt_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        oprot.writeStructBegin('getMyInt_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class use_subdir_struct_args(object):
    """
    Attributes:
     - a
    """
    def __init__(self, a=None):
        self.a = a

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.a = subdir_include.ttypes.A()
                    self.a.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        oprot.writeStructBegin('use_subdir_struct_args')
        if self.a is not None:
            oprot.writeFieldBegin('a', TType.STRUCT, 1)
            self.a.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.a)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

class use_subdir_struct_result(object):
    """
    Attributes:
     - success
    """
    def __init__(self, success=None):
        self.success = success

    def read(self, iprot):
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = subdir_include.ttypes.A()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        oprot.writeStructBegin('use_subdir_struct_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __hash__(self):
        value = 17
        value = (value * 31) ^ hash(self.success)
        return value

    def __repr__(self):
        L = ['%s=%r' % (key, value)
            for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)

