#
# Autogenerated by Frugal Compiler (1.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#



import asyncio
from datetime import timedelta
import inspect

from frugal.aio.processor import FBaseProcessor
from frugal.aio.processor import FProcessorFunction
from frugal.aio.registry import FClientRegistry
from frugal.middleware import Method
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType
import excepts
import validStructs
import ValidTypes
from valid.Blah import *
from valid.ttypes import *


class Iface(object):

    async def ping(self, ctx):
        """
        Use this to ping the server.
        
        Args:
            ctx: FContext
        """
        pass

    async def bleh(self, ctx, one, Two, custom_ints):
        """
        Use this to tell the server how you feel.
        
        Args:
            ctx: FContext
            one: Thing
            Two: Stuff
            custom_ints: list of int (signed 32 bits)
        """
        pass

    async def getThing(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    async def getMyInt(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass


class Client(Iface):

    def __init__(self, transport, protocol_factory, middleware=None):
        """
        Create a new Client with a transport and protocol factory.

        Args:
            transport: FTransport
            protocol_factory: FProtocolFactory
            middleware: ServiceMiddleware or list of ServiceMiddleware
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]
        transport.set_registry(FClientRegistry())
        self._transport = transport
        self._protocol_factory = protocol_factory
        self._oprot = protocol_factory.get_protocol(transport)
        self._write_lock = asyncio.Lock()
        self._methods = {
            'ping': Method(self._ping, middleware),
            'bleh': Method(self._bleh, middleware),
            'getThing': Method(self._getThing, middleware),
            'getMyInt': Method(self._getMyInt, middleware),
        }

    async def ping(self, ctx):
        """
        Use this to ping the server.
        
        Args:
            ctx: FContext
        """
        await self._methods['ping']([ctx])

    async def _ping(self, ctx):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_ping(ctx, future))
        await self._send_ping(ctx)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_ping(self, ctx):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('ping', TMessageType.CALL, 0)
            args = ping_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_ping(self, ctx, future):
        def ping_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = ping_result()
            result.read(iprot)
            iprot.readMessageEnd()
            future.set_result(None)
        return ping_callback

    async def bleh(self, ctx, one, Two, custom_ints):
        """
        Use this to tell the server how you feel.
        
        Args:
            ctx: FContext
            one: Thing
            Two: Stuff
            custom_ints: list of int (signed 32 bits)
        """
        await self._methods['bleh']([ctx, one, Two, custom_ints])

    async def _bleh(self, ctx, one, Two, custom_ints):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_bleh(ctx, future))
        await self._send_bleh(ctx, one, Two, custom_ints)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_bleh(self, ctx, one, Two, custom_ints):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('bleh', TMessageType.CALL, 0)
            args = bleh_args()
            args.one = one
            args.Two = Two
            args.custom_ints = custom_ints
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_bleh(self, ctx, future):
        def bleh_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = bleh_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.oops is not None:
                future.set_exception(result.oops)
                return
            if result.err2 is not None:
                future.set_exception(result.err2)
                return
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "bleh failed: unknown result")
            future.set_exception(x)
            raise x
        return bleh_callback

    async def getThing(self, ctx):
        """
        Args:
            ctx: FContext
        """
        await self._methods['getThing']([ctx])

    async def _getThing(self, ctx):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_getThing(ctx, future))
        await self._send_getThing(ctx)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_getThing(self, ctx):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getThing', TMessageType.CALL, 0)
            args = getThing_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_getThing(self, ctx, future):
        def getThing_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = getThing_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "getThing failed: unknown result")
            future.set_exception(x)
            raise x
        return getThing_callback

    async def getMyInt(self, ctx):
        """
        Args:
            ctx: FContext
        """
        await self._methods['getMyInt']([ctx])

    async def _getMyInt(self, ctx):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_getMyInt(ctx, future))
        await self._send_getMyInt(ctx)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_getMyInt(self, ctx):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('getMyInt', TMessageType.CALL, 0)
            args = getMyInt_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_getMyInt(self, ctx, future):
        def getMyInt_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = getMyInt_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "getMyInt failed: unknown result")
            future.set_exception(x)
            raise x
        return getMyInt_callback


class Processor(FBaseProcessor):

    def __init__(self, handler):
        """
        Create a new Processor.

        Args:
            handler: Iface
        """
        super(Processor, self).__init__()
        self.add_to_processor_map('ping', _ping(handler, self.get_write_lock()))
        self.add_to_processor_map('bleh', _bleh(handler, self.get_write_lock()))
        self.add_to_processor_map('getThing', _getThing(handler, self.get_write_lock()))
        self.add_to_processor_map('getMyInt', _getMyInt(handler, self.get_write_lock()))


class _ping(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = ping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ping_result()
        ret = self._handler.ping(ctx)
        if inspect.iscoroutine(ret):
            ret = await ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('ping', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _bleh(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = bleh_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = bleh_result()
        try:
            ret = self._handler.bleh(ctx, args.one, args.Two, args.custom_ints)
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except InvalidOperation as oops:
            result.oops = oops
        except excepts.ttypes.InvalidData as err2:
            result.err2 = err2
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('bleh', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _getThing(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = getThing_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getThing_result()
        ret = self._handler.getThing(ctx)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('getThing', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _getMyInt(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = getMyInt_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMyInt_result()
        ret = self._handler.getMyInt(ctx)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('getMyInt', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


