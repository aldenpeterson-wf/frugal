#
# Autogenerated by Frugal Compiler (1.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#



import asyncio
from datetime import timedelta
import inspect

from frugal.aio.processor import FBaseProcessor
from frugal.aio.processor import FProcessorFunction
from frugal.aio.registry import FClientRegistry
from frugal.middleware import Method
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType
from frugal_test.FrugalTest import *
from frugal_test.ttypes import *


class Iface(object):

    async def testVoid(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    async def testString(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: string
        """
        pass

    async def testBool(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: boolean
        """
        pass

    async def testByte(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: int (signed 8 bits)
        """
        pass

    async def testI32(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: int (signed 32 bits)
        """
        pass

    async def testI64(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: int (signed 64 bits)
        """
        pass

    async def testDouble(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: float
        """
        pass

    async def testBinary(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: binary string
        """
        pass

    async def testStruct(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: Xtruct
        """
        pass

    async def testNest(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: Xtruct2
        """
        pass

    async def testMap(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: dict of <int (signed 32 bits), int (signed 32 bits)>
        """
        pass

    async def testStringMap(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: dict of <string, string>
        """
        pass

    async def testSet(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: set of int (signed 32 bits)
        """
        pass

    async def testList(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: list of int (signed 32 bits)
        """
        pass

    async def testEnum(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: Numberz
        """
        pass

    async def testTypedef(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: int (signed 64 bits)
        """
        pass

    async def testMapMap(self, ctx, hello):
        """
        Args:
            ctx: FContext
            hello: int (signed 32 bits)
        """
        pass

    async def testInsanity(self, ctx, argument):
        """
        Args:
            ctx: FContext
            argument: Insanity
        """
        pass

    async def testMulti(self, ctx, arg0, arg1, arg2, arg3, arg4, arg5):
        """
        Args:
            ctx: FContext
            arg0: int (signed 8 bits)
            arg1: int (signed 32 bits)
            arg2: int (signed 64 bits)
            arg3: dict of <int (signed 16 bits), string>
            arg4: Numberz
            arg5: int (signed 64 bits)
        """
        pass

    async def testException(self, ctx, arg):
        """
        Args:
            ctx: FContext
            arg: string
        """
        pass

    async def testMultiException(self, ctx, arg0, arg1):
        """
        Args:
            ctx: FContext
            arg0: string
            arg1: string
        """
        pass

    async def testOneway(self, ctx, secondsToSleep):
        """
        Args:
            ctx: FContext
            secondsToSleep: int (signed 32 bits)
        """
        pass


class Client(Iface):

    def __init__(self, transport, protocol_factory, middleware=None):
        """
        Create a new Client with a transport and protocol factory.

        Args:
            transport: FTransport
            protocol_factory: FProtocolFactory
            middleware: ServiceMiddleware or list of ServiceMiddleware
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]
        transport.set_registry(FClientRegistry())
        self._transport = transport
        self._protocol_factory = protocol_factory
        self._oprot = protocol_factory.get_protocol(transport)
        self._write_lock = asyncio.Lock()
        self._methods = {
            'testVoid': Method(self._testVoid, middleware),
            'testString': Method(self._testString, middleware),
            'testBool': Method(self._testBool, middleware),
            'testByte': Method(self._testByte, middleware),
            'testI32': Method(self._testI32, middleware),
            'testI64': Method(self._testI64, middleware),
            'testDouble': Method(self._testDouble, middleware),
            'testBinary': Method(self._testBinary, middleware),
            'testStruct': Method(self._testStruct, middleware),
            'testNest': Method(self._testNest, middleware),
            'testMap': Method(self._testMap, middleware),
            'testStringMap': Method(self._testStringMap, middleware),
            'testSet': Method(self._testSet, middleware),
            'testList': Method(self._testList, middleware),
            'testEnum': Method(self._testEnum, middleware),
            'testTypedef': Method(self._testTypedef, middleware),
            'testMapMap': Method(self._testMapMap, middleware),
            'testInsanity': Method(self._testInsanity, middleware),
            'testMulti': Method(self._testMulti, middleware),
            'testException': Method(self._testException, middleware),
            'testMultiException': Method(self._testMultiException, middleware),
            'testOneway': Method(self._testOneway, middleware),
        }

    async def testVoid(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return await self._methods['testVoid']([ctx])

    async def _testVoid(self, ctx):
        print ('Testing void')
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        print ('Future created, waiting for a timeout')
        timed_future = asyncio.wait_for(future, timeout)
        print ('Future registering callback')
        await self._transport.register(ctx, self._recv_testVoid(ctx, future))
        print ('Future sending testVoid')
        await self._send_testVoid(ctx)

        try:
            print ('awaiting timed_future')
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testVoid(self, ctx):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testVoid', TMessageType.CALL, 0)
            args = testVoid_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testVoid(self, ctx, future):
        def testVoid_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testVoid_result()
            result.read(iprot)
            iprot.readMessageEnd()
            future.set_result(None)
        return testVoid_callback

    async def testString(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: string
        """
        return await self._methods['testString']([ctx, thing])

    async def _testString(self, ctx, thing):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testString(ctx, future))
        await self._send_testString(ctx, thing)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testString(self, ctx, thing):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testString', TMessageType.CALL, 0)
            args = testString_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testString(self, ctx, future):
        def testString_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testString_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testString failed: unknown result")
            future.set_exception(x)
            raise x
        return testString_callback

    async def testBool(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: boolean
        """
        return await self._methods['testBool']([ctx, thing])

    async def _testBool(self, ctx, thing):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testBool(ctx, future))
        await self._send_testBool(ctx, thing)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testBool(self, ctx, thing):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testBool', TMessageType.CALL, 0)
            args = testBool_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testBool(self, ctx, future):
        def testBool_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testBool_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testBool failed: unknown result")
            future.set_exception(x)
            raise x
        return testBool_callback

    async def testByte(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: int (signed 8 bits)
        """
        return await self._methods['testByte']([ctx, thing])

    async def _testByte(self, ctx, thing):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testByte(ctx, future))
        await self._send_testByte(ctx, thing)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testByte(self, ctx, thing):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testByte', TMessageType.CALL, 0)
            args = testByte_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testByte(self, ctx, future):
        def testByte_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testByte_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testByte failed: unknown result")
            future.set_exception(x)
            raise x
        return testByte_callback

    async def testI32(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: int (signed 32 bits)
        """
        return await self._methods['testI32']([ctx, thing])

    async def _testI32(self, ctx, thing):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testI32(ctx, future))
        await self._send_testI32(ctx, thing)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testI32(self, ctx, thing):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testI32', TMessageType.CALL, 0)
            args = testI32_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testI32(self, ctx, future):
        def testI32_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testI32_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testI32 failed: unknown result")
            future.set_exception(x)
            raise x
        return testI32_callback

    async def testI64(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: int (signed 64 bits)
        """
        return await self._methods['testI64']([ctx, thing])

    async def _testI64(self, ctx, thing):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testI64(ctx, future))
        await self._send_testI64(ctx, thing)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testI64(self, ctx, thing):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testI64', TMessageType.CALL, 0)
            args = testI64_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testI64(self, ctx, future):
        def testI64_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testI64_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testI64 failed: unknown result")
            future.set_exception(x)
            raise x
        return testI64_callback

    async def testDouble(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: float
        """
        return await self._methods['testDouble']([ctx, thing])

    async def _testDouble(self, ctx, thing):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testDouble(ctx, future))
        await self._send_testDouble(ctx, thing)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testDouble(self, ctx, thing):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testDouble', TMessageType.CALL, 0)
            args = testDouble_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testDouble(self, ctx, future):
        def testDouble_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testDouble_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testDouble failed: unknown result")
            future.set_exception(x)
            raise x
        return testDouble_callback

    async def testBinary(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: binary string
        """
        return await self._methods['testBinary']([ctx, thing])

    async def _testBinary(self, ctx, thing):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testBinary(ctx, future))
        await self._send_testBinary(ctx, thing)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testBinary(self, ctx, thing):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testBinary', TMessageType.CALL, 0)
            args = testBinary_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testBinary(self, ctx, future):
        def testBinary_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testBinary_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testBinary failed: unknown result")
            future.set_exception(x)
            raise x
        return testBinary_callback

    async def testStruct(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: Xtruct
        """
        return await self._methods['testStruct']([ctx, thing])

    async def _testStruct(self, ctx, thing):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testStruct(ctx, future))
        await self._send_testStruct(ctx, thing)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testStruct(self, ctx, thing):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testStruct', TMessageType.CALL, 0)
            args = testStruct_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testStruct(self, ctx, future):
        def testStruct_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testStruct_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testStruct failed: unknown result")
            future.set_exception(x)
            raise x
        return testStruct_callback

    async def testNest(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: Xtruct2
        """
        return await self._methods['testNest']([ctx, thing])

    async def _testNest(self, ctx, thing):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testNest(ctx, future))
        await self._send_testNest(ctx, thing)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testNest(self, ctx, thing):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testNest', TMessageType.CALL, 0)
            args = testNest_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testNest(self, ctx, future):
        def testNest_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testNest_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testNest failed: unknown result")
            future.set_exception(x)
            raise x
        return testNest_callback

    async def testMap(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: dict of <int (signed 32 bits), int (signed 32 bits)>
        """
        return await self._methods['testMap']([ctx, thing])

    async def _testMap(self, ctx, thing):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testMap(ctx, future))
        await self._send_testMap(ctx, thing)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testMap(self, ctx, thing):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testMap', TMessageType.CALL, 0)
            args = testMap_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testMap(self, ctx, future):
        def testMap_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testMap_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testMap failed: unknown result")
            future.set_exception(x)
            raise x
        return testMap_callback

    async def testStringMap(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: dict of <string, string>
        """
        return await self._methods['testStringMap']([ctx, thing])

    async def _testStringMap(self, ctx, thing):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testStringMap(ctx, future))
        await self._send_testStringMap(ctx, thing)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testStringMap(self, ctx, thing):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testStringMap', TMessageType.CALL, 0)
            args = testStringMap_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testStringMap(self, ctx, future):
        def testStringMap_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testStringMap_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testStringMap failed: unknown result")
            future.set_exception(x)
            raise x
        return testStringMap_callback

    async def testSet(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: set of int (signed 32 bits)
        """
        return await self._methods['testSet']([ctx, thing])

    async def _testSet(self, ctx, thing):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testSet(ctx, future))
        await self._send_testSet(ctx, thing)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testSet(self, ctx, thing):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testSet', TMessageType.CALL, 0)
            args = testSet_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testSet(self, ctx, future):
        def testSet_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testSet_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testSet failed: unknown result")
            future.set_exception(x)
            raise x
        return testSet_callback

    async def testList(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: list of int (signed 32 bits)
        """
        return await self._methods['testList']([ctx, thing])

    async def _testList(self, ctx, thing):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testList(ctx, future))
        await self._send_testList(ctx, thing)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testList(self, ctx, thing):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testList', TMessageType.CALL, 0)
            args = testList_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testList(self, ctx, future):
        def testList_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testList_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testList failed: unknown result")
            future.set_exception(x)
            raise x
        return testList_callback

    async def testEnum(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: Numberz
        """
        return await self._methods['testEnum']([ctx, thing])

    async def _testEnum(self, ctx, thing):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testEnum(ctx, future))
        await self._send_testEnum(ctx, thing)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testEnum(self, ctx, thing):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testEnum', TMessageType.CALL, 0)
            args = testEnum_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testEnum(self, ctx, future):
        def testEnum_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testEnum_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testEnum failed: unknown result")
            future.set_exception(x)
            raise x
        return testEnum_callback

    async def testTypedef(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: int (signed 64 bits)
        """
        return await self._methods['testTypedef']([ctx, thing])

    async def _testTypedef(self, ctx, thing):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testTypedef(ctx, future))
        await self._send_testTypedef(ctx, thing)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testTypedef(self, ctx, thing):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testTypedef', TMessageType.CALL, 0)
            args = testTypedef_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testTypedef(self, ctx, future):
        def testTypedef_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testTypedef_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testTypedef failed: unknown result")
            future.set_exception(x)
            raise x
        return testTypedef_callback

    async def testMapMap(self, ctx, hello):
        """
        Args:
            ctx: FContext
            hello: int (signed 32 bits)
        """
        return await self._methods['testMapMap']([ctx, hello])

    async def _testMapMap(self, ctx, hello):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testMapMap(ctx, future))
        await self._send_testMapMap(ctx, hello)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testMapMap(self, ctx, hello):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testMapMap', TMessageType.CALL, 0)
            args = testMapMap_args()
            args.hello = hello
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testMapMap(self, ctx, future):
        def testMapMap_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testMapMap_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testMapMap failed: unknown result")
            future.set_exception(x)
            raise x
        return testMapMap_callback

    async def testInsanity(self, ctx, argument):
        """
        Args:
            ctx: FContext
            argument: Insanity
        """
        return await self._methods['testInsanity']([ctx, argument])

    async def _testInsanity(self, ctx, argument):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testInsanity(ctx, future))
        await self._send_testInsanity(ctx, argument)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testInsanity(self, ctx, argument):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testInsanity', TMessageType.CALL, 0)
            args = testInsanity_args()
            args.argument = argument
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testInsanity(self, ctx, future):
        def testInsanity_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testInsanity_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testInsanity failed: unknown result")
            future.set_exception(x)
            raise x
        return testInsanity_callback

    async def testMulti(self, ctx, arg0, arg1, arg2, arg3, arg4, arg5):
        """
        Args:
            ctx: FContext
            arg0: int (signed 8 bits)
            arg1: int (signed 32 bits)
            arg2: int (signed 64 bits)
            arg3: dict of <int (signed 16 bits), string>
            arg4: Numberz
            arg5: int (signed 64 bits)
        """
        return await self._methods['testMulti']([ctx, arg0, arg1, arg2, arg3, arg4, arg5])

    async def _testMulti(self, ctx, arg0, arg1, arg2, arg3, arg4, arg5):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testMulti(ctx, future))
        await self._send_testMulti(ctx, arg0, arg1, arg2, arg3, arg4, arg5)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testMulti(self, ctx, arg0, arg1, arg2, arg3, arg4, arg5):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testMulti', TMessageType.CALL, 0)
            args = testMulti_args()
            args.arg0 = arg0
            args.arg1 = arg1
            args.arg2 = arg2
            args.arg3 = arg3
            args.arg4 = arg4
            args.arg5 = arg5
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testMulti(self, ctx, future):
        def testMulti_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testMulti_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testMulti failed: unknown result")
            future.set_exception(x)
            raise x
        return testMulti_callback

    async def testException(self, ctx, arg):
        """
        Args:
            ctx: FContext
            arg: string
        """
        return await self._methods['testException']([ctx, arg])

    async def _testException(self, ctx, arg):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testException(ctx, future))
        await self._send_testException(ctx, arg)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testException(self, ctx, arg):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testException', TMessageType.CALL, 0)
            args = testException_args()
            args.arg = arg
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testException(self, ctx, future):
        def testException_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testException_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.err1 is not None:
                future.set_exception(result.err1)
                return
            future.set_result(None)
        return testException_callback

    async def testMultiException(self, ctx, arg0, arg1):
        """
        Args:
            ctx: FContext
            arg0: string
            arg1: string
        """
        return await self._methods['testMultiException']([ctx, arg0, arg1])

    async def _testMultiException(self, ctx, arg0, arg1):
        timeout = ctx.get_timeout() / 1000.0
        future = asyncio.Future()
        timed_future = asyncio.wait_for(future, timeout)
        await self._transport.register(ctx, self._recv_testMultiException(ctx, future))
        await self._send_testMultiException(ctx, arg0, arg1)

        try:
            result = await timed_future
        finally:
            await self._transport.unregister(ctx)
        return result

    async def _send_testMultiException(self, ctx, arg0, arg1):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testMultiException', TMessageType.CALL, 0)
            args = testMultiException_args()
            args.arg0 = arg0
            args.arg1 = arg1
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()

    def _recv_testMultiException(self, ctx, future):
        def testMultiException_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testMultiException_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.err1 is not None:
                future.set_exception(result.err1)
                return
            if result.err2 is not None:
                future.set_exception(result.err2)
                return
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testMultiException failed: unknown result")
            future.set_exception(x)
            raise x
        return testMultiException_callback

    async def testOneway(self, ctx, secondsToSleep):
        """
        Args:
            ctx: FContext
            secondsToSleep: int (signed 32 bits)
        """
        return await self._methods['testOneway']([ctx, secondsToSleep])

    async def _testOneway(self, ctx, secondsToSleep):
        await self._send_testOneway(ctx, secondsToSleep)

    async def _send_testOneway(self, ctx, secondsToSleep):
        oprot = self._oprot
        async with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testOneway', TMessageType.CALL, 0)
            args = testOneway_args()
            args.secondsToSleep = secondsToSleep
            args.write(oprot)
            oprot.writeMessageEnd()
            await oprot.get_transport().flush()


class Processor(FBaseProcessor):

    def __init__(self, handler):
        """
        Create a new Processor.

        Args:
            handler: Iface
        """
        super(Processor, self).__init__()
        self.add_to_processor_map('testVoid', _testVoid(handler, self.get_write_lock()))
        self.add_to_processor_map('testString', _testString(handler, self.get_write_lock()))
        self.add_to_processor_map('testBool', _testBool(handler, self.get_write_lock()))
        self.add_to_processor_map('testByte', _testByte(handler, self.get_write_lock()))
        self.add_to_processor_map('testI32', _testI32(handler, self.get_write_lock()))
        self.add_to_processor_map('testI64', _testI64(handler, self.get_write_lock()))
        self.add_to_processor_map('testDouble', _testDouble(handler, self.get_write_lock()))
        self.add_to_processor_map('testBinary', _testBinary(handler, self.get_write_lock()))
        self.add_to_processor_map('testStruct', _testStruct(handler, self.get_write_lock()))
        self.add_to_processor_map('testNest', _testNest(handler, self.get_write_lock()))
        self.add_to_processor_map('testMap', _testMap(handler, self.get_write_lock()))
        self.add_to_processor_map('testStringMap', _testStringMap(handler, self.get_write_lock()))
        self.add_to_processor_map('testSet', _testSet(handler, self.get_write_lock()))
        self.add_to_processor_map('testList', _testList(handler, self.get_write_lock()))
        self.add_to_processor_map('testEnum', _testEnum(handler, self.get_write_lock()))
        self.add_to_processor_map('testTypedef', _testTypedef(handler, self.get_write_lock()))
        self.add_to_processor_map('testMapMap', _testMapMap(handler, self.get_write_lock()))
        self.add_to_processor_map('testInsanity', _testInsanity(handler, self.get_write_lock()))
        self.add_to_processor_map('testMulti', _testMulti(handler, self.get_write_lock()))
        self.add_to_processor_map('testException', _testException(handler, self.get_write_lock()))
        self.add_to_processor_map('testMultiException', _testMultiException(handler, self.get_write_lock()))
        self.add_to_processor_map('testOneway', _testOneway(handler, self.get_write_lock()))


class _testVoid(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testVoid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testVoid_result()
        ret = self._handler.testVoid(ctx)
        if inspect.iscoroutine(ret):
            ret = await ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testVoid', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testString(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testString_result()
        ret = self._handler.testString(ctx, args.thing)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testString', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testBool(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testBool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testBool_result()
        ret = self._handler.testBool(ctx, args.thing)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testBool', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testByte(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testByte_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testByte_result()
        ret = self._handler.testByte(ctx, args.thing)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testByte', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testI32(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testI32_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testI32_result()
        ret = self._handler.testI32(ctx, args.thing)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testI32', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testI64(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testI64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testI64_result()
        ret = self._handler.testI64(ctx, args.thing)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testI64', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testDouble(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testDouble_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testDouble_result()
        ret = self._handler.testDouble(ctx, args.thing)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testDouble', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testBinary(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testBinary_result()
        ret = self._handler.testBinary(ctx, args.thing)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testBinary', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testStruct(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testStruct_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testStruct_result()
        ret = self._handler.testStruct(ctx, args.thing)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testStruct', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testNest(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testNest_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testNest_result()
        ret = self._handler.testNest(ctx, args.thing)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testNest', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testMap(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testMap_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testMap_result()
        ret = self._handler.testMap(ctx, args.thing)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testMap', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testStringMap(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testStringMap_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testStringMap_result()
        ret = self._handler.testStringMap(ctx, args.thing)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testStringMap', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testSet(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testSet_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testSet_result()
        ret = self._handler.testSet(ctx, args.thing)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testSet', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testList(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testList_result()
        ret = self._handler.testList(ctx, args.thing)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testList', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testEnum(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testEnum_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testEnum_result()
        ret = self._handler.testEnum(ctx, args.thing)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testEnum', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testTypedef(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testTypedef_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testTypedef_result()
        ret = self._handler.testTypedef(ctx, args.thing)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testTypedef', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testMapMap(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testMapMap_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testMapMap_result()
        ret = self._handler.testMapMap(ctx, args.hello)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testMapMap', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testInsanity(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testInsanity_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testInsanity_result()
        ret = self._handler.testInsanity(ctx, args.argument)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testInsanity', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testMulti(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testMulti_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testMulti_result()
        ret = self._handler.testMulti(ctx, args.arg0, args.arg1, args.arg2, args.arg3, args.arg4, args.arg5)
        if inspect.iscoroutine(ret):
            ret = await ret
        result.success = ret
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testMulti', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testException(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testException_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testException_result()
        try:
            ret = self._handler.testException(ctx, args.arg)
            if inspect.iscoroutine(ret):
                ret = await ret
        except Xception as err1:
            result.err1 = err1
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testException', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testMultiException(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testMultiException_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testMultiException_result()
        try:
            ret = self._handler.testMultiException(ctx, args.arg0, args.arg1)
            if inspect.iscoroutine(ret):
                ret = await ret
            result.success = ret
        except Xception as err1:
            result.err1 = err1
        except Xception2 as err2:
            result.err2 = err2
        async with self._write_lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testMultiException', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testOneway(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._write_lock = lock

    async def process(self, ctx, iprot, oprot):
        args = testOneway_args()
        args.read(iprot)
        iprot.readMessageEnd()
        ret = self._handler.testOneway(ctx, args.secondsToSleep)
        if inspect.iscoroutine(ret):
            ret = await ret


