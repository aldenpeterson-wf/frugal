#
# Autogenerated by Frugal Compiler (1.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#



from datetime import timedelta
from threading import Lock

from frugal.middleware import Method
from frugal.processor import FBaseProcessor
from frugal.processor import FProcessorFunction
from frugal.registry import FClientRegistry
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType
from tornado import gen
from tornado.concurrent import Future

from frugal_test.SecondService import *
from frugal_test.ttypes import *


class Iface(object):

    def blahBlah(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def secondtestString(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: string
        """
        pass


class Client(Iface):

    def __init__(self, transport, protocol_factory, middleware=None):
        """
        Create a new Client with a transport and protocol factory.

        Args:
            transport: FTransport
            protocol_factory: FProtocolFactory
            middleware: ServiceMiddleware or list of ServiceMiddleware
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]
        transport.set_registry(FClientRegistry())
        self._transport = transport
        self._protocol_factory = protocol_factory
        self._oprot = protocol_factory.get_protocol(transport)
        self._write_lock = Lock()
        self._methods = {
            'blahBlah': Method(self._blahBlah, middleware),
            'secondtestString': Method(self._secondtestString, middleware),
        }

    def blahBlah(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['blahBlah']([ctx])

    @gen.coroutine
    def _blahBlah(self, ctx):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_blahBlah(ctx, callback_future))
        yield self._send_blahBlah(ctx)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_blahBlah(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('blahBlah', TMessageType.CALL, 0)
            args = blahBlah_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_blahBlah(self, ctx, future):
        def blahBlah_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = blahBlah_result()
            result.read(iprot)
            iprot.readMessageEnd()
            future.set_result(None)
        return blahBlah_callback

    def secondtestString(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: string
        """
        return self._methods['secondtestString']([ctx, thing])

    @gen.coroutine
    def _secondtestString(self, ctx, thing):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_secondtestString(ctx, callback_future))
        yield self._send_secondtestString(ctx, thing)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_secondtestString(self, ctx, thing):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('secondtestString', TMessageType.CALL, 0)
            args = secondtestString_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_secondtestString(self, ctx, future):
        def secondtestString_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = secondtestString_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "secondtestString failed: unknown result")
            future.set_exception(x)
            raise x
        return secondtestString_callback


class Processor(FBaseProcessor):

    def __init__(self, handler):
        """
        Create a new Processor.

        Args:
            handler: Iface
        """
        super(Processor, self).__init__()
        self.add_to_processor_map('blahBlah', _blahBlah(handler, self.get_write_lock()))
        self.add_to_processor_map('secondtestString', _secondtestString(handler, self.get_write_lock()))


class _blahBlah(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = blahBlah_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = blahBlah_result()
        yield gen.maybe_future(self._handler.blahBlah(ctx))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('blahBlah', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _secondtestString(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = secondtestString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = secondtestString_result()
        result.success = yield gen.maybe_future(self._handler.secondtestString(ctx, args.thing))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('secondtestString', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


