#
# Autogenerated by Frugal Compiler (1.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#



from datetime import timedelta
from threading import Lock

from frugal.middleware import Method
from frugal.processor import FBaseProcessor
from frugal.processor import FProcessorFunction
from frugal.registry import FClientRegistry
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType
from tornado import gen
from tornado.concurrent import Future

from frugal_test.FrugalTest import *
from frugal_test.ttypes import *


class Iface(object):

    def testVoid(self, ctx):
        """
        Args:
            ctx: FContext
        """
        pass

    def testString(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: string
        """
        pass

    def testBool(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: boolean
        """
        pass

    def testByte(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: int (signed 8 bits)
        """
        pass

    def testI32(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: int (signed 32 bits)
        """
        pass

    def testI64(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: int (signed 64 bits)
        """
        pass

    def testDouble(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: float
        """
        pass

    def testBinary(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: binary string
        """
        pass

    def testStruct(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: Xtruct
        """
        pass

    def testNest(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: Xtruct2
        """
        pass

    def testMap(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: dict of <int (signed 32 bits), int (signed 32 bits)>
        """
        pass

    def testStringMap(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: dict of <string, string>
        """
        pass

    def testSet(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: set of int (signed 32 bits)
        """
        pass

    def testList(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: list of int (signed 32 bits)
        """
        pass

    def testEnum(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: Numberz
        """
        pass

    def testTypedef(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: int (signed 64 bits)
        """
        pass

    def testMapMap(self, ctx, hello):
        """
        Args:
            ctx: FContext
            hello: int (signed 32 bits)
        """
        pass

    def testInsanity(self, ctx, argument):
        """
        Args:
            ctx: FContext
            argument: Insanity
        """
        pass

    def testMulti(self, ctx, arg0, arg1, arg2, arg3, arg4, arg5):
        """
        Args:
            ctx: FContext
            arg0: int (signed 8 bits)
            arg1: int (signed 32 bits)
            arg2: int (signed 64 bits)
            arg3: dict of <int (signed 16 bits), string>
            arg4: Numberz
            arg5: int (signed 64 bits)
        """
        pass

    def testException(self, ctx, arg):
        """
        Args:
            ctx: FContext
            arg: string
        """
        pass

    def testMultiException(self, ctx, arg0, arg1):
        """
        Args:
            ctx: FContext
            arg0: string
            arg1: string
        """
        pass

    def testOneway(self, ctx, secondsToSleep):
        """
        Args:
            ctx: FContext
            secondsToSleep: int (signed 32 bits)
        """
        pass


class Client(Iface):

    def __init__(self, transport, protocol_factory, middleware=None):
        """
        Create a new Client with a transport and protocol factory.

        Args:
            transport: FTransport
            protocol_factory: FProtocolFactory
            middleware: ServiceMiddleware or list of ServiceMiddleware
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]
        transport.set_registry(FClientRegistry())
        self._transport = transport
        self._protocol_factory = protocol_factory
        self._oprot = protocol_factory.get_protocol(transport)
        self._write_lock = Lock()
        self._methods = {
            'testVoid': Method(self._testVoid, middleware),
            'testString': Method(self._testString, middleware),
            'testBool': Method(self._testBool, middleware),
            'testByte': Method(self._testByte, middleware),
            'testI32': Method(self._testI32, middleware),
            'testI64': Method(self._testI64, middleware),
            'testDouble': Method(self._testDouble, middleware),
            'testBinary': Method(self._testBinary, middleware),
            'testStruct': Method(self._testStruct, middleware),
            'testNest': Method(self._testNest, middleware),
            'testMap': Method(self._testMap, middleware),
            'testStringMap': Method(self._testStringMap, middleware),
            'testSet': Method(self._testSet, middleware),
            'testList': Method(self._testList, middleware),
            'testEnum': Method(self._testEnum, middleware),
            'testTypedef': Method(self._testTypedef, middleware),
            'testMapMap': Method(self._testMapMap, middleware),
            'testInsanity': Method(self._testInsanity, middleware),
            'testMulti': Method(self._testMulti, middleware),
            'testException': Method(self._testException, middleware),
            'testMultiException': Method(self._testMultiException, middleware),
            'testOneway': Method(self._testOneway, middleware),
        }

    def testVoid(self, ctx):
        """
        Args:
            ctx: FContext
        """
        return self._methods['testVoid']([ctx])

    @gen.coroutine
    def _testVoid(self, ctx):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testVoid(ctx, callback_future))
        yield self._send_testVoid(ctx)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testVoid(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testVoid', TMessageType.CALL, 0)
            args = testVoid_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testVoid(self, ctx, future):
        def testVoid_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testVoid_result()
            result.read(iprot)
            iprot.readMessageEnd()
            future.set_result(None)
        return testVoid_callback

    def testString(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: string
        """
        return self._methods['testString']([ctx, thing])

    @gen.coroutine
    def _testString(self, ctx, thing):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testString(ctx, callback_future))
        yield self._send_testString(ctx, thing)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testString(self, ctx, thing):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testString', TMessageType.CALL, 0)
            args = testString_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testString(self, ctx, future):
        def testString_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testString_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testString failed: unknown result")
            future.set_exception(x)
            raise x
        return testString_callback

    def testBool(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: boolean
        """
        return self._methods['testBool']([ctx, thing])

    @gen.coroutine
    def _testBool(self, ctx, thing):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testBool(ctx, callback_future))
        yield self._send_testBool(ctx, thing)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testBool(self, ctx, thing):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testBool', TMessageType.CALL, 0)
            args = testBool_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testBool(self, ctx, future):
        def testBool_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testBool_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testBool failed: unknown result")
            future.set_exception(x)
            raise x
        return testBool_callback

    def testByte(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: int (signed 8 bits)
        """
        return self._methods['testByte']([ctx, thing])

    @gen.coroutine
    def _testByte(self, ctx, thing):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testByte(ctx, callback_future))
        yield self._send_testByte(ctx, thing)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testByte(self, ctx, thing):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testByte', TMessageType.CALL, 0)
            args = testByte_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testByte(self, ctx, future):
        def testByte_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testByte_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testByte failed: unknown result")
            future.set_exception(x)
            raise x
        return testByte_callback

    def testI32(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: int (signed 32 bits)
        """
        return self._methods['testI32']([ctx, thing])

    @gen.coroutine
    def _testI32(self, ctx, thing):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testI32(ctx, callback_future))
        yield self._send_testI32(ctx, thing)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testI32(self, ctx, thing):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testI32', TMessageType.CALL, 0)
            args = testI32_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testI32(self, ctx, future):
        def testI32_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testI32_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testI32 failed: unknown result")
            future.set_exception(x)
            raise x
        return testI32_callback

    def testI64(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: int (signed 64 bits)
        """
        return self._methods['testI64']([ctx, thing])

    @gen.coroutine
    def _testI64(self, ctx, thing):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testI64(ctx, callback_future))
        yield self._send_testI64(ctx, thing)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testI64(self, ctx, thing):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testI64', TMessageType.CALL, 0)
            args = testI64_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testI64(self, ctx, future):
        def testI64_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testI64_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testI64 failed: unknown result")
            future.set_exception(x)
            raise x
        return testI64_callback

    def testDouble(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: float
        """
        return self._methods['testDouble']([ctx, thing])

    @gen.coroutine
    def _testDouble(self, ctx, thing):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testDouble(ctx, callback_future))
        yield self._send_testDouble(ctx, thing)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testDouble(self, ctx, thing):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testDouble', TMessageType.CALL, 0)
            args = testDouble_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testDouble(self, ctx, future):
        def testDouble_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testDouble_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testDouble failed: unknown result")
            future.set_exception(x)
            raise x
        return testDouble_callback

    def testBinary(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: binary string
        """
        return self._methods['testBinary']([ctx, thing])

    @gen.coroutine
    def _testBinary(self, ctx, thing):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testBinary(ctx, callback_future))
        yield self._send_testBinary(ctx, thing)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testBinary(self, ctx, thing):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testBinary', TMessageType.CALL, 0)
            args = testBinary_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testBinary(self, ctx, future):
        def testBinary_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testBinary_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testBinary failed: unknown result")
            future.set_exception(x)
            raise x
        return testBinary_callback

    def testStruct(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: Xtruct
        """
        return self._methods['testStruct']([ctx, thing])

    @gen.coroutine
    def _testStruct(self, ctx, thing):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testStruct(ctx, callback_future))
        yield self._send_testStruct(ctx, thing)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testStruct(self, ctx, thing):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testStruct', TMessageType.CALL, 0)
            args = testStruct_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testStruct(self, ctx, future):
        def testStruct_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testStruct_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testStruct failed: unknown result")
            future.set_exception(x)
            raise x
        return testStruct_callback

    def testNest(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: Xtruct2
        """
        return self._methods['testNest']([ctx, thing])

    @gen.coroutine
    def _testNest(self, ctx, thing):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testNest(ctx, callback_future))
        yield self._send_testNest(ctx, thing)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testNest(self, ctx, thing):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testNest', TMessageType.CALL, 0)
            args = testNest_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testNest(self, ctx, future):
        def testNest_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testNest_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testNest failed: unknown result")
            future.set_exception(x)
            raise x
        return testNest_callback

    def testMap(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: dict of <int (signed 32 bits), int (signed 32 bits)>
        """
        return self._methods['testMap']([ctx, thing])

    @gen.coroutine
    def _testMap(self, ctx, thing):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testMap(ctx, callback_future))
        yield self._send_testMap(ctx, thing)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testMap(self, ctx, thing):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testMap', TMessageType.CALL, 0)
            args = testMap_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testMap(self, ctx, future):
        def testMap_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testMap_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testMap failed: unknown result")
            future.set_exception(x)
            raise x
        return testMap_callback

    def testStringMap(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: dict of <string, string>
        """
        return self._methods['testStringMap']([ctx, thing])

    @gen.coroutine
    def _testStringMap(self, ctx, thing):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testStringMap(ctx, callback_future))
        yield self._send_testStringMap(ctx, thing)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testStringMap(self, ctx, thing):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testStringMap', TMessageType.CALL, 0)
            args = testStringMap_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testStringMap(self, ctx, future):
        def testStringMap_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testStringMap_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testStringMap failed: unknown result")
            future.set_exception(x)
            raise x
        return testStringMap_callback

    def testSet(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: set of int (signed 32 bits)
        """
        return self._methods['testSet']([ctx, thing])

    @gen.coroutine
    def _testSet(self, ctx, thing):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testSet(ctx, callback_future))
        yield self._send_testSet(ctx, thing)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testSet(self, ctx, thing):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testSet', TMessageType.CALL, 0)
            args = testSet_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testSet(self, ctx, future):
        def testSet_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testSet_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testSet failed: unknown result")
            future.set_exception(x)
            raise x
        return testSet_callback

    def testList(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: list of int (signed 32 bits)
        """
        return self._methods['testList']([ctx, thing])

    @gen.coroutine
    def _testList(self, ctx, thing):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testList(ctx, callback_future))
        yield self._send_testList(ctx, thing)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testList(self, ctx, thing):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testList', TMessageType.CALL, 0)
            args = testList_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testList(self, ctx, future):
        def testList_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testList_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testList failed: unknown result")
            future.set_exception(x)
            raise x
        return testList_callback

    def testEnum(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: Numberz
        """
        return self._methods['testEnum']([ctx, thing])

    @gen.coroutine
    def _testEnum(self, ctx, thing):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testEnum(ctx, callback_future))
        yield self._send_testEnum(ctx, thing)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testEnum(self, ctx, thing):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testEnum', TMessageType.CALL, 0)
            args = testEnum_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testEnum(self, ctx, future):
        def testEnum_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testEnum_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testEnum failed: unknown result")
            future.set_exception(x)
            raise x
        return testEnum_callback

    def testTypedef(self, ctx, thing):
        """
        Args:
            ctx: FContext
            thing: int (signed 64 bits)
        """
        return self._methods['testTypedef']([ctx, thing])

    @gen.coroutine
    def _testTypedef(self, ctx, thing):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testTypedef(ctx, callback_future))
        yield self._send_testTypedef(ctx, thing)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testTypedef(self, ctx, thing):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testTypedef', TMessageType.CALL, 0)
            args = testTypedef_args()
            args.thing = thing
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testTypedef(self, ctx, future):
        def testTypedef_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testTypedef_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testTypedef failed: unknown result")
            future.set_exception(x)
            raise x
        return testTypedef_callback

    def testMapMap(self, ctx, hello):
        """
        Args:
            ctx: FContext
            hello: int (signed 32 bits)
        """
        return self._methods['testMapMap']([ctx, hello])

    @gen.coroutine
    def _testMapMap(self, ctx, hello):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testMapMap(ctx, callback_future))
        yield self._send_testMapMap(ctx, hello)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testMapMap(self, ctx, hello):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testMapMap', TMessageType.CALL, 0)
            args = testMapMap_args()
            args.hello = hello
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testMapMap(self, ctx, future):
        def testMapMap_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testMapMap_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testMapMap failed: unknown result")
            future.set_exception(x)
            raise x
        return testMapMap_callback

    def testInsanity(self, ctx, argument):
        """
        Args:
            ctx: FContext
            argument: Insanity
        """
        return self._methods['testInsanity']([ctx, argument])

    @gen.coroutine
    def _testInsanity(self, ctx, argument):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testInsanity(ctx, callback_future))
        yield self._send_testInsanity(ctx, argument)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testInsanity(self, ctx, argument):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testInsanity', TMessageType.CALL, 0)
            args = testInsanity_args()
            args.argument = argument
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testInsanity(self, ctx, future):
        def testInsanity_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testInsanity_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testInsanity failed: unknown result")
            future.set_exception(x)
            raise x
        return testInsanity_callback

    def testMulti(self, ctx, arg0, arg1, arg2, arg3, arg4, arg5):
        """
        Args:
            ctx: FContext
            arg0: int (signed 8 bits)
            arg1: int (signed 32 bits)
            arg2: int (signed 64 bits)
            arg3: dict of <int (signed 16 bits), string>
            arg4: Numberz
            arg5: int (signed 64 bits)
        """
        return self._methods['testMulti']([ctx, arg0, arg1, arg2, arg3, arg4, arg5])

    @gen.coroutine
    def _testMulti(self, ctx, arg0, arg1, arg2, arg3, arg4, arg5):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testMulti(ctx, callback_future))
        yield self._send_testMulti(ctx, arg0, arg1, arg2, arg3, arg4, arg5)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testMulti(self, ctx, arg0, arg1, arg2, arg3, arg4, arg5):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testMulti', TMessageType.CALL, 0)
            args = testMulti_args()
            args.arg0 = arg0
            args.arg1 = arg1
            args.arg2 = arg2
            args.arg3 = arg3
            args.arg4 = arg4
            args.arg5 = arg5
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testMulti(self, ctx, future):
        def testMulti_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testMulti_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testMulti failed: unknown result")
            future.set_exception(x)
            raise x
        return testMulti_callback

    def testException(self, ctx, arg):
        """
        Args:
            ctx: FContext
            arg: string
        """
        return self._methods['testException']([ctx, arg])

    @gen.coroutine
    def _testException(self, ctx, arg):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testException(ctx, callback_future))
        yield self._send_testException(ctx, arg)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testException(self, ctx, arg):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testException', TMessageType.CALL, 0)
            args = testException_args()
            args.arg = arg
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testException(self, ctx, future):
        def testException_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testException_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.err1 is not None:
                future.set_exception(result.err1)
                return
            future.set_result(None)
        return testException_callback

    def testMultiException(self, ctx, arg0, arg1):
        """
        Args:
            ctx: FContext
            arg0: string
            arg1: string
        """
        return self._methods['testMultiException']([ctx, arg0, arg1])

    @gen.coroutine
    def _testMultiException(self, ctx, arg0, arg1):
        delta = timedelta(milliseconds=ctx.get_timeout())
        callback_future = Future()
        timeout_future = gen.with_timeout(delta, callback_future)
        self._transport.register(ctx, self._recv_testMultiException(ctx, callback_future))
        yield self._send_testMultiException(ctx, arg0, arg1)

        try:
            result = yield timeout_future
        finally:
            self._transport.unregister(ctx)
        raise gen.Return(result)

    @gen.coroutine
    def _send_testMultiException(self, ctx, arg0, arg1):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testMultiException', TMessageType.CALL, 0)
            args = testMultiException_args()
            args.arg0 = arg0
            args.arg1 = arg1
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()

    def _recv_testMultiException(self, ctx, future):
        def testMultiException_callback(transport):
            iprot = self._protocol_factory.get_protocol(transport)
            iprot.read_response_headers(ctx)
            _, mtype, _ = iprot.readMessageBegin()
            if mtype == TMessageType.EXCEPTION:
                x = TApplicationException()
                x.read(iprot)
                iprot.readMessageEnd()
                future.set_exception(x)
                raise x
            result = testMultiException_result()
            result.read(iprot)
            iprot.readMessageEnd()
            if result.err1 is not None:
                future.set_exception(result.err1)
                return
            if result.err2 is not None:
                future.set_exception(result.err2)
                return
            if result.success is not None:
                future.set_result(result.success)
                return
            x = TApplicationException(TApplicationException.MISSING_RESULT, "testMultiException failed: unknown result")
            future.set_exception(x)
            raise x
        return testMultiException_callback

    def testOneway(self, ctx, secondsToSleep):
        """
        Args:
            ctx: FContext
            secondsToSleep: int (signed 32 bits)
        """
        return self._methods['testOneway']([ctx, secondsToSleep])

    @gen.coroutine
    def _testOneway(self, ctx, secondsToSleep):
        yield self._send_testOneway(ctx, secondsToSleep)

    @gen.coroutine
    def _send_testOneway(self, ctx, secondsToSleep):
        oprot = self._oprot
        with self._write_lock:
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('testOneway', TMessageType.CALL, 0)
            args = testOneway_args()
            args.secondsToSleep = secondsToSleep
            args.write(oprot)
            oprot.writeMessageEnd()
            yield oprot.get_transport().flush()


class Processor(FBaseProcessor):

    def __init__(self, handler):
        """
        Create a new Processor.

        Args:
            handler: Iface
        """
        super(Processor, self).__init__()
        self.add_to_processor_map('testVoid', _testVoid(handler, self.get_write_lock()))
        self.add_to_processor_map('testString', _testString(handler, self.get_write_lock()))
        self.add_to_processor_map('testBool', _testBool(handler, self.get_write_lock()))
        self.add_to_processor_map('testByte', _testByte(handler, self.get_write_lock()))
        self.add_to_processor_map('testI32', _testI32(handler, self.get_write_lock()))
        self.add_to_processor_map('testI64', _testI64(handler, self.get_write_lock()))
        self.add_to_processor_map('testDouble', _testDouble(handler, self.get_write_lock()))
        self.add_to_processor_map('testBinary', _testBinary(handler, self.get_write_lock()))
        self.add_to_processor_map('testStruct', _testStruct(handler, self.get_write_lock()))
        self.add_to_processor_map('testNest', _testNest(handler, self.get_write_lock()))
        self.add_to_processor_map('testMap', _testMap(handler, self.get_write_lock()))
        self.add_to_processor_map('testStringMap', _testStringMap(handler, self.get_write_lock()))
        self.add_to_processor_map('testSet', _testSet(handler, self.get_write_lock()))
        self.add_to_processor_map('testList', _testList(handler, self.get_write_lock()))
        self.add_to_processor_map('testEnum', _testEnum(handler, self.get_write_lock()))
        self.add_to_processor_map('testTypedef', _testTypedef(handler, self.get_write_lock()))
        self.add_to_processor_map('testMapMap', _testMapMap(handler, self.get_write_lock()))
        self.add_to_processor_map('testInsanity', _testInsanity(handler, self.get_write_lock()))
        self.add_to_processor_map('testMulti', _testMulti(handler, self.get_write_lock()))
        self.add_to_processor_map('testException', _testException(handler, self.get_write_lock()))
        self.add_to_processor_map('testMultiException', _testMultiException(handler, self.get_write_lock()))
        self.add_to_processor_map('testOneway', _testOneway(handler, self.get_write_lock()))


class _testVoid(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testVoid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testVoid_result()
        yield gen.maybe_future(self._handler.testVoid(ctx))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testVoid', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testString(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testString_result()
        result.success = yield gen.maybe_future(self._handler.testString(ctx, args.thing))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testString', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testBool(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testBool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testBool_result()
        result.success = yield gen.maybe_future(self._handler.testBool(ctx, args.thing))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testBool', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testByte(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testByte_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testByte_result()
        result.success = yield gen.maybe_future(self._handler.testByte(ctx, args.thing))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testByte', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testI32(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testI32_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testI32_result()
        result.success = yield gen.maybe_future(self._handler.testI32(ctx, args.thing))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testI32', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testI64(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testI64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testI64_result()
        result.success = yield gen.maybe_future(self._handler.testI64(ctx, args.thing))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testI64', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testDouble(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testDouble_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testDouble_result()
        result.success = yield gen.maybe_future(self._handler.testDouble(ctx, args.thing))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testDouble', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testBinary(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testBinary_result()
        result.success = yield gen.maybe_future(self._handler.testBinary(ctx, args.thing))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testBinary', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testStruct(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testStruct_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testStruct_result()
        result.success = yield gen.maybe_future(self._handler.testStruct(ctx, args.thing))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testStruct', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testNest(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testNest_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testNest_result()
        result.success = yield gen.maybe_future(self._handler.testNest(ctx, args.thing))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testNest', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testMap(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testMap_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testMap_result()
        result.success = yield gen.maybe_future(self._handler.testMap(ctx, args.thing))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testMap', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testStringMap(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testStringMap_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testStringMap_result()
        result.success = yield gen.maybe_future(self._handler.testStringMap(ctx, args.thing))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testStringMap', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testSet(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testSet_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testSet_result()
        result.success = yield gen.maybe_future(self._handler.testSet(ctx, args.thing))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testSet', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testList(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testList_result()
        result.success = yield gen.maybe_future(self._handler.testList(ctx, args.thing))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testList', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testEnum(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testEnum_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testEnum_result()
        result.success = yield gen.maybe_future(self._handler.testEnum(ctx, args.thing))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testEnum', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testTypedef(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testTypedef_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testTypedef_result()
        result.success = yield gen.maybe_future(self._handler.testTypedef(ctx, args.thing))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testTypedef', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testMapMap(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testMapMap_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testMapMap_result()
        result.success = yield gen.maybe_future(self._handler.testMapMap(ctx, args.hello))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testMapMap', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testInsanity(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testInsanity_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testInsanity_result()
        result.success = yield gen.maybe_future(self._handler.testInsanity(ctx, args.argument))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testInsanity', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testMulti(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testMulti_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testMulti_result()
        result.success = yield gen.maybe_future(self._handler.testMulti(ctx, args.arg0, args.arg1, args.arg2, args.arg3, args.arg4, args.arg5))
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testMulti', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testException(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testException_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testException_result()
        try:
            yield gen.maybe_future(self._handler.testException(ctx, args.arg))
        except Xception as err1:
            result.err1 = err1
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testException', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testMultiException(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testMultiException_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testMultiException_result()
        try:
            result.success = yield gen.maybe_future(self._handler.testMultiException(ctx, args.arg0, args.arg1))
        except Xception as err1:
            result.err1 = err1
        except Xception2 as err2:
            result.err2 = err2
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('testMultiException', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _testOneway(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    @gen.coroutine
    def process(self, ctx, iprot, oprot):
        args = testOneway_args()
        args.read(iprot)
        iprot.readMessageEnd()
        yield gen.maybe_future(self._handler.testOneway(ctx, args.secondsToSleep))


