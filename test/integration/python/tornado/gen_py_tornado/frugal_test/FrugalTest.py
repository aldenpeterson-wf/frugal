#
# Autogenerated by Thrift Compiler (0.9.3-wk-3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:tornado
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import logging
from ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None

from tornado import gen
from tornado import concurrent
from thrift.transport import TTransport

class Iface(object):
  def testVoid(self):
    pass

  def testString(self, thing):
    """
    Parameters:
     - thing
    """
    pass

  def testBool(self, thing):
    """
    Parameters:
     - thing
    """
    pass

  def testByte(self, thing):
    """
    Parameters:
     - thing
    """
    pass

  def testI32(self, thing):
    """
    Parameters:
     - thing
    """
    pass

  def testI64(self, thing):
    """
    Parameters:
     - thing
    """
    pass

  def testDouble(self, thing):
    """
    Parameters:
     - thing
    """
    pass

  def testBinary(self, thing):
    """
    Parameters:
     - thing
    """
    pass

  def testStruct(self, thing):
    """
    Parameters:
     - thing
    """
    pass

  def testNest(self, thing):
    """
    Parameters:
     - thing
    """
    pass

  def testMap(self, thing):
    """
    Parameters:
     - thing
    """
    pass

  def testStringMap(self, thing):
    """
    Parameters:
     - thing
    """
    pass

  def testSet(self, thing):
    """
    Parameters:
     - thing
    """
    pass

  def testList(self, thing):
    """
    Parameters:
     - thing
    """
    pass

  def testEnum(self, thing):
    """
    Parameters:
     - thing
    """
    pass

  def testTypedef(self, thing):
    """
    Parameters:
     - thing
    """
    pass

  def testMapMap(self, hello):
    """
    Parameters:
     - hello
    """
    pass

  def testInsanity(self, argument):
    """
    Parameters:
     - argument
    """
    pass

  def testMulti(self, arg0, arg1, arg2, arg3, arg4, arg5):
    """
    Parameters:
     - arg0
     - arg1
     - arg2
     - arg3
     - arg4
     - arg5
    """
    pass

  def testException(self, arg):
    """
    Parameters:
     - arg
    """
    pass

  def testMultiException(self, arg0, arg1):
    """
    Parameters:
     - arg0
     - arg1
    """
    pass

  def testOneway(self, secondsToSleep):
    """
    Parameters:
     - secondsToSleep
    """
    pass


class Client(Iface):
  def __init__(self, transport, iprot_factory, oprot_factory=None):
    self._transport = transport
    self._iprot_factory = iprot_factory
    self._oprot_factory = (oprot_factory if oprot_factory is not None
                           else iprot_factory)
    self._seqid = 0
    self._reqs = {}
    self._transport.io_loop.spawn_callback(self._start_receiving)

  @gen.engine
  def _start_receiving(self):
    while True:
      try:
        frame = yield self._transport.readFrame()
      except TTransport.TTransportException as e:
        for future in self._reqs.itervalues():
          future.set_exception(e)
        self._reqs = {}
        return
      tr = TTransport.TMemoryBuffer(frame)
      iprot = self._iprot_factory.getProtocol(tr)
      (fname, mtype, rseqid) = iprot.readMessageBegin()
      future = self._reqs.pop(rseqid, None)
      if not future:
        # future has already been discarded
        continue
      method = getattr(self, 'recv_' + fname)
      try:
        result = method(iprot, mtype, rseqid)
      except Exception as e:
        future.set_exception(e)
      else:
        future.set_result(result)

  def testVoid(self):
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testVoid()
    return future

  def send_testVoid(self):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testVoid', TMessageType.CALL, self._seqid)
    args = testVoid_args()
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testVoid(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testVoid_result()
    result.read(iprot)
    iprot.readMessageEnd()
    return

  def testString(self, thing):
    """
    Parameters:
     - thing
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testString(thing)
    return future

  def send_testString(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testString', TMessageType.CALL, self._seqid)
    args = testString_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testString(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testString_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testString failed: unknown result")

  def testBool(self, thing):
    """
    Parameters:
     - thing
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testBool(thing)
    return future

  def send_testBool(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testBool', TMessageType.CALL, self._seqid)
    args = testBool_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testBool(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testBool_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testBool failed: unknown result")

  def testByte(self, thing):
    """
    Parameters:
     - thing
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testByte(thing)
    return future

  def send_testByte(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testByte', TMessageType.CALL, self._seqid)
    args = testByte_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testByte(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testByte_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testByte failed: unknown result")

  def testI32(self, thing):
    """
    Parameters:
     - thing
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testI32(thing)
    return future

  def send_testI32(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testI32', TMessageType.CALL, self._seqid)
    args = testI32_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testI32(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testI32_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testI32 failed: unknown result")

  def testI64(self, thing):
    """
    Parameters:
     - thing
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testI64(thing)
    return future

  def send_testI64(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testI64', TMessageType.CALL, self._seqid)
    args = testI64_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testI64(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testI64_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testI64 failed: unknown result")

  def testDouble(self, thing):
    """
    Parameters:
     - thing
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testDouble(thing)
    return future

  def send_testDouble(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testDouble', TMessageType.CALL, self._seqid)
    args = testDouble_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testDouble(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testDouble_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testDouble failed: unknown result")

  def testBinary(self, thing):
    """
    Parameters:
     - thing
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testBinary(thing)
    return future

  def send_testBinary(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testBinary', TMessageType.CALL, self._seqid)
    args = testBinary_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testBinary(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testBinary_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testBinary failed: unknown result")

  def testStruct(self, thing):
    """
    Parameters:
     - thing
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testStruct(thing)
    return future

  def send_testStruct(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testStruct', TMessageType.CALL, self._seqid)
    args = testStruct_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testStruct(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testStruct_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testStruct failed: unknown result")

  def testNest(self, thing):
    """
    Parameters:
     - thing
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testNest(thing)
    return future

  def send_testNest(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testNest', TMessageType.CALL, self._seqid)
    args = testNest_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testNest(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testNest_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testNest failed: unknown result")

  def testMap(self, thing):
    """
    Parameters:
     - thing
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testMap(thing)
    return future

  def send_testMap(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testMap', TMessageType.CALL, self._seqid)
    args = testMap_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testMap(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testMap_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testMap failed: unknown result")

  def testStringMap(self, thing):
    """
    Parameters:
     - thing
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testStringMap(thing)
    return future

  def send_testStringMap(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testStringMap', TMessageType.CALL, self._seqid)
    args = testStringMap_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testStringMap(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testStringMap_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testStringMap failed: unknown result")

  def testSet(self, thing):
    """
    Parameters:
     - thing
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testSet(thing)
    return future

  def send_testSet(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testSet', TMessageType.CALL, self._seqid)
    args = testSet_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testSet(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testSet_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testSet failed: unknown result")

  def testList(self, thing):
    """
    Parameters:
     - thing
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testList(thing)
    return future

  def send_testList(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testList', TMessageType.CALL, self._seqid)
    args = testList_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testList(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testList_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testList failed: unknown result")

  def testEnum(self, thing):
    """
    Parameters:
     - thing
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testEnum(thing)
    return future

  def send_testEnum(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testEnum', TMessageType.CALL, self._seqid)
    args = testEnum_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testEnum(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testEnum_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testEnum failed: unknown result")

  def testTypedef(self, thing):
    """
    Parameters:
     - thing
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testTypedef(thing)
    return future

  def send_testTypedef(self, thing):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testTypedef', TMessageType.CALL, self._seqid)
    args = testTypedef_args()
    args.thing = thing
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testTypedef(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testTypedef_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testTypedef failed: unknown result")

  def testMapMap(self, hello):
    """
    Parameters:
     - hello
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testMapMap(hello)
    return future

  def send_testMapMap(self, hello):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testMapMap', TMessageType.CALL, self._seqid)
    args = testMapMap_args()
    args.hello = hello
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testMapMap(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testMapMap_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testMapMap failed: unknown result")

  def testInsanity(self, argument):
    """
    Parameters:
     - argument
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testInsanity(argument)
    return future

  def send_testInsanity(self, argument):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testInsanity', TMessageType.CALL, self._seqid)
    args = testInsanity_args()
    args.argument = argument
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testInsanity(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testInsanity_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testInsanity failed: unknown result")

  def testMulti(self, arg0, arg1, arg2, arg3, arg4, arg5):
    """
    Parameters:
     - arg0
     - arg1
     - arg2
     - arg3
     - arg4
     - arg5
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testMulti(arg0, arg1, arg2, arg3, arg4, arg5)
    return future

  def send_testMulti(self, arg0, arg1, arg2, arg3, arg4, arg5):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testMulti', TMessageType.CALL, self._seqid)
    args = testMulti_args()
    args.arg0 = arg0
    args.arg1 = arg1
    args.arg2 = arg2
    args.arg3 = arg3
    args.arg4 = arg4
    args.arg5 = arg5
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testMulti(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testMulti_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testMulti failed: unknown result")

  def testException(self, arg):
    """
    Parameters:
     - arg
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testException(arg)
    return future

  def send_testException(self, arg):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testException', TMessageType.CALL, self._seqid)
    args = testException_args()
    args.arg = arg
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testException(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testException_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.err1 is not None:
      raise result.err1
    return

  def testMultiException(self, arg0, arg1):
    """
    Parameters:
     - arg0
     - arg1
    """
    self._seqid += 1
    future = self._reqs[self._seqid] = concurrent.Future()
    self.send_testMultiException(arg0, arg1)
    return future

  def send_testMultiException(self, arg0, arg1):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testMultiException', TMessageType.CALL, self._seqid)
    args = testMultiException_args()
    args.arg0 = arg0
    args.arg1 = arg1
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  def recv_testMultiException(self, iprot, mtype, rseqid):
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(iprot)
      iprot.readMessageEnd()
      raise x
    result = testMultiException_result()
    result.read(iprot)
    iprot.readMessageEnd()
    if result.success is not None:
      return result.success
    if result.err1 is not None:
      raise result.err1
    if result.err2 is not None:
      raise result.err2
    raise TApplicationException(TApplicationException.MISSING_RESULT, "testMultiException failed: unknown result")

  def testOneway(self, secondsToSleep):
    """
    Parameters:
     - secondsToSleep
    """
    self._seqid += 1
    self.send_testOneway(secondsToSleep)

  def send_testOneway(self, secondsToSleep):
    oprot = self._oprot_factory.getProtocol(self._transport)
    oprot.writeMessageBegin('testOneway', TMessageType.ONEWAY, self._seqid)
    args = testOneway_args()
    args.secondsToSleep = secondsToSleep
    args.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

class Processor(Iface, TProcessor):
  def __init__(self, handler):
    self._handler = handler
    self._processMap = {}
    self._processMap["testVoid"] = Processor.process_testVoid
    self._processMap["testString"] = Processor.process_testString
    self._processMap["testBool"] = Processor.process_testBool
    self._processMap["testByte"] = Processor.process_testByte
    self._processMap["testI32"] = Processor.process_testI32
    self._processMap["testI64"] = Processor.process_testI64
    self._processMap["testDouble"] = Processor.process_testDouble
    self._processMap["testBinary"] = Processor.process_testBinary
    self._processMap["testStruct"] = Processor.process_testStruct
    self._processMap["testNest"] = Processor.process_testNest
    self._processMap["testMap"] = Processor.process_testMap
    self._processMap["testStringMap"] = Processor.process_testStringMap
    self._processMap["testSet"] = Processor.process_testSet
    self._processMap["testList"] = Processor.process_testList
    self._processMap["testEnum"] = Processor.process_testEnum
    self._processMap["testTypedef"] = Processor.process_testTypedef
    self._processMap["testMapMap"] = Processor.process_testMapMap
    self._processMap["testInsanity"] = Processor.process_testInsanity
    self._processMap["testMulti"] = Processor.process_testMulti
    self._processMap["testException"] = Processor.process_testException
    self._processMap["testMultiException"] = Processor.process_testMultiException
    self._processMap["testOneway"] = Processor.process_testOneway

  def process(self, iprot, oprot):
    (name, type, seqid) = iprot.readMessageBegin()
    if name not in self._processMap:
      iprot.skip(TType.STRUCT)
      iprot.readMessageEnd()
      x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
      oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
      x.write(oprot)
      oprot.writeMessageEnd()
      oprot.trans.flush()
      return
    else:
      return self._processMap[name](self, seqid, iprot, oprot)

  @gen.coroutine
  def process_testVoid(self, seqid, iprot, oprot):
    args = testVoid_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testVoid_result()
    yield gen.maybe_future(self._handler.testVoid())
    oprot.writeMessageBegin("testVoid", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testString(self, seqid, iprot, oprot):
    args = testString_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testString_result()
    result.success = yield gen.maybe_future(self._handler.testString(args.thing))
    oprot.writeMessageBegin("testString", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testBool(self, seqid, iprot, oprot):
    args = testBool_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testBool_result()
    result.success = yield gen.maybe_future(self._handler.testBool(args.thing))
    oprot.writeMessageBegin("testBool", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testByte(self, seqid, iprot, oprot):
    args = testByte_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testByte_result()
    result.success = yield gen.maybe_future(self._handler.testByte(args.thing))
    oprot.writeMessageBegin("testByte", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testI32(self, seqid, iprot, oprot):
    args = testI32_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testI32_result()
    result.success = yield gen.maybe_future(self._handler.testI32(args.thing))
    oprot.writeMessageBegin("testI32", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testI64(self, seqid, iprot, oprot):
    args = testI64_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testI64_result()
    result.success = yield gen.maybe_future(self._handler.testI64(args.thing))
    oprot.writeMessageBegin("testI64", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testDouble(self, seqid, iprot, oprot):
    args = testDouble_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testDouble_result()
    result.success = yield gen.maybe_future(self._handler.testDouble(args.thing))
    oprot.writeMessageBegin("testDouble", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testBinary(self, seqid, iprot, oprot):
    args = testBinary_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testBinary_result()
    result.success = yield gen.maybe_future(self._handler.testBinary(args.thing))
    oprot.writeMessageBegin("testBinary", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testStruct(self, seqid, iprot, oprot):
    args = testStruct_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testStruct_result()
    result.success = yield gen.maybe_future(self._handler.testStruct(args.thing))
    oprot.writeMessageBegin("testStruct", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testNest(self, seqid, iprot, oprot):
    args = testNest_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testNest_result()
    result.success = yield gen.maybe_future(self._handler.testNest(args.thing))
    oprot.writeMessageBegin("testNest", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testMap(self, seqid, iprot, oprot):
    args = testMap_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testMap_result()
    result.success = yield gen.maybe_future(self._handler.testMap(args.thing))
    oprot.writeMessageBegin("testMap", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testStringMap(self, seqid, iprot, oprot):
    args = testStringMap_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testStringMap_result()
    result.success = yield gen.maybe_future(self._handler.testStringMap(args.thing))
    oprot.writeMessageBegin("testStringMap", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testSet(self, seqid, iprot, oprot):
    args = testSet_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testSet_result()
    result.success = yield gen.maybe_future(self._handler.testSet(args.thing))
    oprot.writeMessageBegin("testSet", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testList(self, seqid, iprot, oprot):
    args = testList_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testList_result()
    result.success = yield gen.maybe_future(self._handler.testList(args.thing))
    oprot.writeMessageBegin("testList", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testEnum(self, seqid, iprot, oprot):
    args = testEnum_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testEnum_result()
    result.success = yield gen.maybe_future(self._handler.testEnum(args.thing))
    oprot.writeMessageBegin("testEnum", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testTypedef(self, seqid, iprot, oprot):
    args = testTypedef_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testTypedef_result()
    result.success = yield gen.maybe_future(self._handler.testTypedef(args.thing))
    oprot.writeMessageBegin("testTypedef", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testMapMap(self, seqid, iprot, oprot):
    args = testMapMap_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testMapMap_result()
    result.success = yield gen.maybe_future(self._handler.testMapMap(args.hello))
    oprot.writeMessageBegin("testMapMap", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testInsanity(self, seqid, iprot, oprot):
    args = testInsanity_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testInsanity_result()
    result.success = yield gen.maybe_future(self._handler.testInsanity(args.argument))
    oprot.writeMessageBegin("testInsanity", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testMulti(self, seqid, iprot, oprot):
    args = testMulti_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testMulti_result()
    result.success = yield gen.maybe_future(self._handler.testMulti(args.arg0, args.arg1, args.arg2, args.arg3, args.arg4, args.arg5))
    oprot.writeMessageBegin("testMulti", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testException(self, seqid, iprot, oprot):
    args = testException_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testException_result()
    try:
      yield gen.maybe_future(self._handler.testException(args.arg))
    except Xception as err1:
      result.err1 = err1
    oprot.writeMessageBegin("testException", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testMultiException(self, seqid, iprot, oprot):
    args = testMultiException_args()
    args.read(iprot)
    iprot.readMessageEnd()
    result = testMultiException_result()
    try:
      result.success = yield gen.maybe_future(self._handler.testMultiException(args.arg0, args.arg1))
    except Xception as err1:
      result.err1 = err1
    except Xception2 as err2:
      result.err2 = err2
    oprot.writeMessageBegin("testMultiException", TMessageType.REPLY, seqid)
    result.write(oprot)
    oprot.writeMessageEnd()
    oprot.trans.flush()

  @gen.coroutine
  def process_testOneway(self, seqid, iprot, oprot):
    args = testOneway_args()
    args.read(iprot)
    iprot.readMessageEnd()
    yield gen.maybe_future(self._handler.testOneway(args.secondsToSleep))


# HELPER FUNCTIONS AND STRUCTURES

class testVoid_args:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testVoid_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testVoid_result:

  thrift_spec = (
  )

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testVoid_result')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testString_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'thing', None, None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.thing = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testString_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.STRING, 1)
      oprot.writeString(self.thing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testString_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testString_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testBool_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'thing', None, None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.thing = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testBool_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.BOOL, 1)
      oprot.writeBool(self.thing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testBool_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BOOL:
          self.success = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testBool_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BOOL, 0)
      oprot.writeBool(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testByte_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'thing', None, None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.thing = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testByte_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.BYTE, 1)
      oprot.writeByte(self.thing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testByte_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.BYTE:
          self.success = iprot.readByte()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testByte_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.BYTE, 0)
      oprot.writeByte(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testI32_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'thing', None, None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.thing = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testI32_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.I32, 1)
      oprot.writeI32(self.thing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testI32_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testI32_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testI64_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'thing', None, None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.thing = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testI64_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.I64, 1)
      oprot.writeI64(self.thing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testI64_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testI64_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testDouble_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'thing', None, None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.thing = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testDouble_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.DOUBLE, 1)
      oprot.writeDouble(self.thing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testDouble_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.DOUBLE:
          self.success = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testDouble_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.DOUBLE, 0)
      oprot.writeDouble(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testBinary_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'thing', None, None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.thing = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testBinary_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.STRING, 1)
      oprot.writeString(self.thing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testBinary_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRING, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRING:
          self.success = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testBinary_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRING, 0)
      oprot.writeString(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testStruct_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'thing', (Xtruct, Xtruct.thrift_spec), None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.thing = Xtruct()
          self.thing.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testStruct_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.STRUCT, 1)
      self.thing.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testStruct_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Xtruct, Xtruct.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Xtruct()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testStruct_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testNest_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'thing', (Xtruct2, Xtruct2.thrift_spec), None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.thing = Xtruct2()
          self.thing.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testNest_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.STRUCT, 1)
      self.thing.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testNest_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Xtruct2, Xtruct2.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Xtruct2()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testNest_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testMap_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'thing', (TType.I32,None,TType.I32,None), None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.thing = {}
          (_ktype193, _vtype194, _size192 ) = iprot.readMapBegin()
          for _i196 in xrange(_size192):
            _key197 = iprot.readI32()
            _val198 = iprot.readI32()
            self.thing[_key197] = _val198
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testMap_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.MAP, 1)
      oprot.writeMapBegin(TType.I32, TType.I32, len(self.thing))
      for kiter199,viter200 in self.thing.items():
        oprot.writeI32(kiter199)
        oprot.writeI32(viter200)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testMap_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.I32,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype202, _vtype203, _size201 ) = iprot.readMapBegin()
          for _i205 in xrange(_size201):
            _key206 = iprot.readI32()
            _val207 = iprot.readI32()
            self.success[_key206] = _val207
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testMap_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.I32, len(self.success))
      for kiter208,viter209 in self.success.items():
        oprot.writeI32(kiter208)
        oprot.writeI32(viter209)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testStringMap_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.MAP, 'thing', (TType.STRING,None,TType.STRING,None), None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.thing = {}
          (_ktype211, _vtype212, _size210 ) = iprot.readMapBegin()
          for _i214 in xrange(_size210):
            _key215 = iprot.readString()
            _val216 = iprot.readString()
            self.thing[_key215] = _val216
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testStringMap_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.thing))
      for kiter217,viter218 in self.thing.items():
        oprot.writeString(kiter217)
        oprot.writeString(viter218)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testStringMap_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING,None,TType.STRING,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype220, _vtype221, _size219 ) = iprot.readMapBegin()
          for _i223 in xrange(_size219):
            _key224 = iprot.readString()
            _val225 = iprot.readString()
            self.success[_key224] = _val225
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testStringMap_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
      for kiter226,viter227 in self.success.items():
        oprot.writeString(kiter226)
        oprot.writeString(viter227)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testSet_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.SET, 'thing', (TType.I32,None), None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.SET:
          self.thing = set()
          (_etype231, _size228) = iprot.readSetBegin()
          for _i232 in xrange(_size228):
            _elem233 = iprot.readI32()
            self.thing.add(_elem233)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testSet_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.SET, 1)
      oprot.writeSetBegin(TType.I32, len(self.thing))
      for iter234 in self.thing:
        oprot.writeI32(iter234)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testSet_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.SET, 'success', (TType.I32,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.SET:
          self.success = set()
          (_etype238, _size235) = iprot.readSetBegin()
          for _i239 in xrange(_size235):
            _elem240 = iprot.readI32()
            self.success.add(_elem240)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testSet_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.SET, 0)
      oprot.writeSetBegin(TType.I32, len(self.success))
      for iter241 in self.success:
        oprot.writeI32(iter241)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testList_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'thing', (TType.I32,None), None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.thing = []
          (_etype245, _size242) = iprot.readListBegin()
          for _i246 in xrange(_size242):
            _elem247 = iprot.readI32()
            self.thing.append(_elem247)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testList_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.LIST, 1)
      oprot.writeListBegin(TType.I32, len(self.thing))
      for iter248 in self.thing:
        oprot.writeI32(iter248)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testList_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32,None), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype252, _size249) = iprot.readListBegin()
          for _i253 in xrange(_size249):
            _elem254 = iprot.readI32()
            self.success.append(_elem254)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testList_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.I32, len(self.success))
      for iter255 in self.success:
        oprot.writeI32(iter255)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testEnum_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'thing', None, None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.thing = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testEnum_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.I32, 1)
      oprot.writeI32(self.thing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testEnum_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I32, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I32:
          self.success = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testEnum_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I32, 0)
      oprot.writeI32(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testTypedef_args:
  """
  Attributes:
   - thing
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'thing', None, None, ), # 1
  )

  def __init__(self, thing=None,):
    self.thing = thing

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.thing = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testTypedef_args')
    if self.thing is not None:
      oprot.writeFieldBegin('thing', TType.I64, 1)
      oprot.writeI64(self.thing)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.thing)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testTypedef_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.I64, 'success', None, None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testTypedef_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testMapMap_args:
  """
  Attributes:
   - hello
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'hello', None, None, ), # 1
  )

  def __init__(self, hello=None,):
    self.hello = hello

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.hello = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testMapMap_args')
    if self.hello is not None:
      oprot.writeFieldBegin('hello', TType.I32, 1)
      oprot.writeI32(self.hello)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hello)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testMapMap_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32,None,TType.MAP,(TType.I32,None,TType.I32,None)), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype257, _vtype258, _size256 ) = iprot.readMapBegin()
          for _i260 in xrange(_size256):
            _key261 = iprot.readI32()
            _val262 = {}
            (_ktype264, _vtype265, _size263 ) = iprot.readMapBegin()
            for _i267 in xrange(_size263):
              _key268 = iprot.readI32()
              _val269 = iprot.readI32()
              _val262[_key268] = _val269
            iprot.readMapEnd()
            self.success[_key261] = _val262
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testMapMap_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I32, TType.MAP, len(self.success))
      for kiter270,viter271 in self.success.items():
        oprot.writeI32(kiter270)
        oprot.writeMapBegin(TType.I32, TType.I32, len(viter271))
        for kiter272,viter273 in viter271.items():
          oprot.writeI32(kiter272)
          oprot.writeI32(viter273)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testInsanity_args:
  """
  Attributes:
   - argument
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'argument', (Insanity, Insanity.thrift_spec), None, ), # 1
  )

  def __init__(self, argument=None,):
    self.argument = argument

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.argument = Insanity()
          self.argument.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testInsanity_args')
    if self.argument is not None:
      oprot.writeFieldBegin('argument', TType.STRUCT, 1)
      self.argument.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.argument)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testInsanity_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64,None,TType.MAP,(TType.I32,None,TType.STRUCT,(Insanity, Insanity.thrift_spec))), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype275, _vtype276, _size274 ) = iprot.readMapBegin()
          for _i278 in xrange(_size274):
            _key279 = iprot.readI64()
            _val280 = {}
            (_ktype282, _vtype283, _size281 ) = iprot.readMapBegin()
            for _i285 in xrange(_size281):
              _key286 = iprot.readI32()
              _val287 = Insanity()
              _val287.read(iprot)
              _val280[_key286] = _val287
            iprot.readMapEnd()
            self.success[_key279] = _val280
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testInsanity_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
      for kiter288,viter289 in self.success.items():
        oprot.writeI64(kiter288)
        oprot.writeMapBegin(TType.I32, TType.STRUCT, len(viter289))
        for kiter290,viter291 in viter289.items():
          oprot.writeI32(kiter290)
          viter291.write(oprot)
        oprot.writeMapEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testMulti_args:
  """
  Attributes:
   - arg0
   - arg1
   - arg2
   - arg3
   - arg4
   - arg5
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'arg0', None, None, ), # 1
    (2, TType.I32, 'arg1', None, None, ), # 2
    (3, TType.I64, 'arg2', None, None, ), # 3
    (4, TType.MAP, 'arg3', (TType.I16,None,TType.STRING,None), None, ), # 4
    (5, TType.I32, 'arg4', None, None, ), # 5
    (6, TType.I64, 'arg5', None, None, ), # 6
  )

  def __init__(self, arg0=None, arg1=None, arg2=None, arg3=None, arg4=None, arg5=None,):
    self.arg0 = arg0
    self.arg1 = arg1
    self.arg2 = arg2
    self.arg3 = arg3
    self.arg4 = arg4
    self.arg5 = arg5

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.arg0 = iprot.readByte()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.arg1 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.arg2 = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.arg3 = {}
          (_ktype293, _vtype294, _size292 ) = iprot.readMapBegin()
          for _i296 in xrange(_size292):
            _key297 = iprot.readI16()
            _val298 = iprot.readString()
            self.arg3[_key297] = _val298
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.arg4 = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.arg5 = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testMulti_args')
    if self.arg0 is not None:
      oprot.writeFieldBegin('arg0', TType.BYTE, 1)
      oprot.writeByte(self.arg0)
      oprot.writeFieldEnd()
    if self.arg1 is not None:
      oprot.writeFieldBegin('arg1', TType.I32, 2)
      oprot.writeI32(self.arg1)
      oprot.writeFieldEnd()
    if self.arg2 is not None:
      oprot.writeFieldBegin('arg2', TType.I64, 3)
      oprot.writeI64(self.arg2)
      oprot.writeFieldEnd()
    if self.arg3 is not None:
      oprot.writeFieldBegin('arg3', TType.MAP, 4)
      oprot.writeMapBegin(TType.I16, TType.STRING, len(self.arg3))
      for kiter299,viter300 in self.arg3.items():
        oprot.writeI16(kiter299)
        oprot.writeString(viter300)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.arg4 is not None:
      oprot.writeFieldBegin('arg4', TType.I32, 5)
      oprot.writeI32(self.arg4)
      oprot.writeFieldEnd()
    if self.arg5 is not None:
      oprot.writeFieldBegin('arg5', TType.I64, 6)
      oprot.writeI64(self.arg5)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.arg0)
    value = (value * 31) ^ hash(self.arg1)
    value = (value * 31) ^ hash(self.arg2)
    value = (value * 31) ^ hash(self.arg3)
    value = (value * 31) ^ hash(self.arg4)
    value = (value * 31) ^ hash(self.arg5)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testMulti_result:
  """
  Attributes:
   - success
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Xtruct, Xtruct.thrift_spec), None, ), # 0
  )

  def __init__(self, success=None,):
    self.success = success

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Xtruct()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testMulti_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testException_args:
  """
  Attributes:
   - arg
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'arg', None, None, ), # 1
  )

  def __init__(self, arg=None,):
    self.arg = arg

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.arg = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testException_args')
    if self.arg is not None:
      oprot.writeFieldBegin('arg', TType.STRING, 1)
      oprot.writeString(self.arg)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.arg)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testException_result:
  """
  Attributes:
   - err1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'err1', (Xception, Xception.thrift_spec), None, ), # 1
  )

  def __init__(self, err1=None,):
    self.err1 = err1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.err1 = Xception()
          self.err1.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testException_result')
    if self.err1 is not None:
      oprot.writeFieldBegin('err1', TType.STRUCT, 1)
      self.err1.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.err1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testMultiException_args:
  """
  Attributes:
   - arg0
   - arg1
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'arg0', None, None, ), # 1
    (2, TType.STRING, 'arg1', None, None, ), # 2
  )

  def __init__(self, arg0=None, arg1=None,):
    self.arg0 = arg0
    self.arg1 = arg1

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.arg0 = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.arg1 = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testMultiException_args')
    if self.arg0 is not None:
      oprot.writeFieldBegin('arg0', TType.STRING, 1)
      oprot.writeString(self.arg0)
      oprot.writeFieldEnd()
    if self.arg1 is not None:
      oprot.writeFieldBegin('arg1', TType.STRING, 2)
      oprot.writeString(self.arg1)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.arg0)
    value = (value * 31) ^ hash(self.arg1)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testMultiException_result:
  """
  Attributes:
   - success
   - err1
   - err2
  """

  thrift_spec = (
    (0, TType.STRUCT, 'success', (Xtruct, Xtruct.thrift_spec), None, ), # 0
    (1, TType.STRUCT, 'err1', (Xception, Xception.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'err2', (Xception2, Xception2.thrift_spec), None, ), # 2
  )

  def __init__(self, success=None, err1=None, err2=None,):
    self.success = success
    self.err1 = err1
    self.err2 = err2

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.STRUCT:
          self.success = Xtruct()
          self.success.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.err1 = Xception()
          self.err1.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.err2 = Xception2()
          self.err2.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testMultiException_result')
    if self.success is not None:
      oprot.writeFieldBegin('success', TType.STRUCT, 0)
      self.success.write(oprot)
      oprot.writeFieldEnd()
    if self.err1 is not None:
      oprot.writeFieldBegin('err1', TType.STRUCT, 1)
      self.err1.write(oprot)
      oprot.writeFieldEnd()
    if self.err2 is not None:
      oprot.writeFieldBegin('err2', TType.STRUCT, 2)
      self.err2.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.success)
    value = (value * 31) ^ hash(self.err1)
    value = (value * 31) ^ hash(self.err2)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class testOneway_args:
  """
  Attributes:
   - secondsToSleep
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'secondsToSleep', None, None, ), # 1
  )

  def __init__(self, secondsToSleep=None,):
    self.secondsToSleep = secondsToSleep

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.secondsToSleep = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('testOneway_args')
    if self.secondsToSleep is not None:
      oprot.writeFieldBegin('secondsToSleep', TType.I32, 1)
      oprot.writeI32(self.secondsToSleep)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.secondsToSleep)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
