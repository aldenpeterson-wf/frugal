diff --git a/compiler/generator/generator.go b/compiler/generator/generator.go
index 4ae4ac9..94d3dee 100644
--- a/compiler/generator/generator.go
+++ b/compiler/generator/generator.go
@@ -55,6 +55,7 @@ var Languages = LanguageOptions{
 	"py": Options{
 		"tornado":         "Generate code for use with Tornado (compatible with Python 2.7)",
 		"asyncio":         "Generate code for use with asyncio (compatible with Python 3.5 or above)",
+		"gevent":          "Generate code for use with gevent (compatible with Python 2.7 or above)",
 		"package_prefix":  "Package prefix for generated files",
 	},
 	"html": Options{
diff --git a/compiler/generator/python/asyncio.go b/compiler/generator/python/asyncio.go
index 3e8f3d5..7ceb03b 100644
--- a/compiler/generator/python/asyncio.go
+++ b/compiler/generator/python/asyncio.go
@@ -263,7 +263,6 @@ func (g *AsyncIOGenerator) generateProcessor(service *parser.Service) string {
 			method.Name, method.Name, method.Name)
 	}
 	contents += "\n\n"
-
 	return contents
 }
 
@@ -271,8 +270,8 @@ func (a *AsyncIOGenerator) generateProcessorFunction(method *parser.Method) stri
 	contents := ""
 	contents += fmt.Sprintf("class _%s(FProcessorFunction):\n\n", method.Name)
 	contents += tab + "def __init__(self, handler, lock):\n"
-	contents += tabtab + fmt.Sprintf("super(_%s, self).__init__(handler, lock)\n", method.Name)
-	contents += "\n"
+	contents += tabtab + "self._handler = handler\n"
+	contents += tabtab + "self._write_lock = lock\n\n"
 
 	contents += tab + "async def process(self, ctx, iprot, oprot):\n"
 	contents += tabtab + fmt.Sprintf("args = %s_args()\n", method.Name)
@@ -290,7 +289,7 @@ func (a *AsyncIOGenerator) generateProcessorFunction(method *parser.Method) stri
 		contents += tabtabtab + "result.success = ret\n"
 	}
 	contents += tabtab + "except FRateLimitException as ex:\n"
-	contents += tabtabtab + "async with self._lock:\n"
+	contents += tabtabtab + "async with self._write_lock:\n"
 	contents += tabtabtabtab + fmt.Sprintf(
 		"_write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, \"%s\", ex.message)\n",
 		method.Name)
@@ -301,12 +300,12 @@ func (a *AsyncIOGenerator) generateProcessorFunction(method *parser.Method) stri
 	}
 	contents += tabtab + "except Exception as e:\n"
 	if !method.Oneway {
-		contents += tabtabtab + "async with self._lock:\n"
+		contents += tabtabtab + "async with self._write_lock:\n"
 		contents += tabtabtabtab + fmt.Sprintf("e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, \"%s\", e.args[0])\n", method.Name)
 	}
 	contents += tabtabtab + "raise e from None\n"
 	if !method.Oneway {
-		contents += tabtab + "async with self._lock:\n"
+		contents += tabtab + "async with self._write_lock:\n"
 		contents += tabtabtab + "try:\n"
 		contents += tabtabtabtab + "oprot.write_response_headers(ctx)\n"
 		contents += tabtabtabtab + fmt.Sprintf("oprot.writeMessageBegin('%s', TMessageType.REPLY, 0)\n", method.Name)
diff --git a/compiler/generator/python/generator.go b/compiler/generator/python/generator.go
index 5e2f4fc..0b7c351 100644
--- a/compiler/generator/python/generator.go
+++ b/compiler/generator/python/generator.go
@@ -28,6 +28,7 @@ const (
 	synchronous concurrencyModel = iota
 	tornado
 	asyncio
+	gevent
 )
 
 // Generator implements the LanguageGenerator interface for Python.
@@ -45,6 +46,8 @@ func NewGenerator(options map[string]string) generator.LanguageGenerator {
 		return &TornadoGenerator{gen}
 	case asyncio:
 		return &AsyncIOGenerator{gen}
+	case gevent:
+		return &GeventGenerator{gen}
 	}
 	return gen
 }
@@ -1192,8 +1195,8 @@ func (g *Generator) generateProcessorFunction(method *parser.Method) string {
 	contents := ""
 	contents += fmt.Sprintf("class _%s(FProcessorFunction):\n\n", method.Name)
 	contents += tab + "def __init__(self, handler, lock):\n"
-	contents += tabtab + fmt.Sprintf("super(_%s, self).__init__(handler, lock)\n", method.Name)
-	contents += "\n"
+	contents += tabtab + "self._handler = handler\n"
+	contents += tabtab + "self._lock = lock\n\n"
 
 	contents += tab + "def process(self, ctx, iprot, oprot):\n"
 	contents += tabtab + fmt.Sprintf("args = %s_args()\n", method.Name)
@@ -1377,6 +1380,8 @@ func getAsyncOpt(options map[string]string) concurrencyModel {
 		return tornado
 	} else if _, ok := options["asyncio"]; ok {
 		return asyncio
+	} else if _, ok := options["gevent"]; ok {
+		return gevent
 	}
 	return synchronous
 }
diff --git a/compiler/generator/python/gevent.go b/compiler/generator/python/gevent.go
new file mode 100644
index 0000000..5371c0d
--- /dev/null
+++ b/compiler/generator/python/gevent.go
@@ -0,0 +1,329 @@
+package python
+
+import (
+	"fmt"
+	"os"
+
+	"github.com/Workiva/frugal/compiler/globals"
+	"github.com/Workiva/frugal/compiler/parser"
+)
+
+// GeventGenerator implements the LanguageGenerator interface for Python using
+// Tornado.
+type GeventGenerator struct {
+	*Generator
+}
+
+// GenerateServiceImports generates necessary imports for the given service.
+func (t *GeventGenerator) GenerateServiceImports(file *os.File, s *parser.Service) error {
+	imports := "from datetime import timedelta\n"
+	imports += "from threading import Lock\n\n"
+
+
+	imports += "from gevent.event import AsyncResult\n"
+	imports += "from gevent import Timeout\n\n"
+
+	imports += "from frugal.exceptions import FApplicationException\n"
+	imports += "from frugal.exceptions import FMessageSizeException\n"
+	imports += "from frugal.exceptions import FRateLimitException\n"
+	imports += "from frugal.exceptions import FTimeoutException\n"
+	imports += "from frugal.middleware import Method\n"
+	imports += "from frugal.processor import FBaseProcessor\n"
+	imports += "from frugal.processor import FProcessorFunction\n"
+	imports += "from frugal.transport import TMemoryOutputBuffer\n"
+	imports += "from thrift.Thrift import TApplicationException\n"
+	imports += "from thrift.Thrift import TMessageType\n"
+
+	imports += t.generateServiceExtendsImport(s)
+	if imp, err := t.generateServiceIncludeImports(s); err != nil {
+		return err
+	} else {
+		imports += imp
+	}
+
+	_, err := file.WriteString(imports)
+	return err
+
+}
+
+// GenerateScopeImports generates necessary imports for the given scope.
+func (t *GeventGenerator) GenerateScopeImports(file *os.File, s *parser.Scope) error {
+	imports := "import sys\n"
+	imports += "import traceback\n\n"
+
+	imports += "from thrift.Thrift import TApplicationException\n"
+	imports += "from thrift.Thrift import TMessageType\n"
+	imports += "from thrift.Thrift import TType\n"
+	imports += "from frugal.middleware import Method\n"
+	imports += "from frugal.subscription import FSubscription\n"
+	imports += "from frugal.transport import TMemoryOutputBuffer\n\n"
+
+	imports += "from .ttypes import *\n"
+	_, err := file.WriteString(imports)
+	return err
+}
+
+// GenerateService generates the given service.
+func (t *GeventGenerator) GenerateService(file *os.File, s *parser.Service) error {
+	contents := ""
+	contents += t.generateServiceInterface(s)
+	contents += t.generateClient(s)
+	contents += t.generateServer(s)
+	contents += t.generateServiceArgsResults(s)
+
+	_, err := file.WriteString(contents)
+	return err
+}
+
+func (t *GeventGenerator) generateClient(service *parser.Service) string {
+	contents := "\n"
+	contents += t.generateClientConstructor(service, true)
+	for _, method := range service.Methods {
+		contents += t.generateClientMethod(method)
+	}
+	contents += "\n"
+	return contents
+}
+
+func (t *GeventGenerator) generateClientMethod(method *parser.Method) string {
+	contents := ""
+	contents += t.generateMethodSignature(method)
+	contents += tabtab + fmt.Sprintf("return self._methods['%s']([ctx%s])\n\n",
+		method.Name, t.generateClientArgs(method.Arguments))
+
+	contents += tab + fmt.Sprintf("def _%s(self, ctx%s):\n", method.Name, t.generateClientArgs(method.Arguments))
+
+	if method.Oneway {
+		contents += tabtab + fmt.Sprintf("self._send_%s(ctx%s)\n\n", method.Name, t.generateClientArgs(method.Arguments))
+		contents += t.generateClientSendMethod(method)
+		return contents
+	}
+
+	contents += tabtab + fmt.Sprintf("event = AsyncResult()\n")
+	contents += tabtab + fmt.Sprintf("self._transport.register(ctx, self._recv_%s(ctx, event))\n", method.Name)
+	contents += tabtab + "try:\n"
+	contents += tabtabtab + fmt.Sprintf("self._send_%s(ctx%s)\n", method.Name, t.generateClientArgs(method.Arguments))
+	contents += tabtabtab + fmt.Sprintf("result = event.get(timeout=ctx.timeout/1000)\n")
+	contents += tabtab+ "except Timeout:\n"
+	contents += fmt.Sprintf(tabtabtab+"raise FTimeoutException('%s timed out after {} milliseconds'.format(ctx.timeout))\n", method.Name)
+	contents += tabtab + "finally:\n"
+	contents += tabtabtab + "self._transport.unregister(ctx)\n"
+	contents += tabtab + "return result\n\n"
+	contents += t.generateClientSendMethod(method)
+	contents += t.generateClientRecvMethod(method)
+
+	return contents
+}
+
+func (t *GeventGenerator) generateClientSendMethod(method *parser.Method) string {
+	contents := ""
+	contents += tab + fmt.Sprintf("def _send_%s(self, ctx%s):\n", method.Name, t.generateClientArgs(method.Arguments))
+	contents += tabtab + "buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())\n"
+	contents += tabtab + "oprot = self._protocol_factory.get_protocol(buffer)\n"
+	contents += tabtab + "oprot.write_request_headers(ctx)\n"
+	contents += tabtab + fmt.Sprintf("oprot.writeMessageBegin('%s', TMessageType.CALL, 0)\n", method.Name)
+	contents += tabtab + fmt.Sprintf("args = %s_args()\n", method.Name)
+	for _, arg := range method.Arguments {
+		contents += tabtab + fmt.Sprintf("args.%s = %s\n", arg.Name, arg.Name)
+	}
+	contents += tabtab + "args.write(oprot)\n"
+	contents += tabtab + "oprot.writeMessageEnd()\n"
+	contents += tabtab + "self._transport.send(buffer.getvalue())\n\n"
+
+	return contents
+}
+
+func (t *GeventGenerator) generateClientRecvMethod(method *parser.Method) string {
+	contents := tab + fmt.Sprintf("def _recv_%s(self, ctx, event):\n", method.Name)
+	contents += tabtab + fmt.Sprintf("def %s_callback(transport):\n", method.Name)
+	contents += tabtabtab + "iprot = self._protocol_factory.get_protocol(transport)\n"
+	contents += tabtabtab + "iprot.read_response_headers(ctx)\n"
+	contents += tabtabtab + "_, mtype, _ = iprot.readMessageBegin()\n"
+	contents += tabtabtab + "if mtype == TMessageType.EXCEPTION:\n"
+	contents += tabtabtabtab + "x = TApplicationException()\n"
+	contents += tabtabtabtab + "x.read(iprot)\n"
+	contents += tabtabtabtab + "iprot.readMessageEnd()\n"
+	contents += tabtabtabtab + "if x.type == FApplicationException.RESPONSE_TOO_LARGE:\n"
+	contents += tabtabtabtabtab + "event.set(FMessageSizeException.response(x.message))\n"
+	contents += tabtabtabtabtab + "return\n"
+	contents += tabtabtabtab + "if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:\n"
+	contents += tabtabtabtabtab + "event.set(FRateLimitException.response(x.message))\n"
+	contents += tabtabtabtabtab + "return\n"
+	contents += tabtabtabtab + "event.set(x)\n"
+	contents += tabtabtabtab + "return\n"
+	contents += tabtabtab + fmt.Sprintf("result = %s_result()\n", method.Name)
+	contents += tabtabtab + "result.read(iprot)\n"
+	contents += tabtabtab + "iprot.readMessageEnd()\n"
+	for _, err := range method.Exceptions {
+		contents += tabtabtab + fmt.Sprintf("if result.%s is not None:\n", err.Name)
+		contents += tabtabtabtab + fmt.Sprintf("event.set(result.%s)\n", err.Name)
+		contents += tabtabtabtab + fmt.Sprintf("return\n")
+	}
+	if method.ReturnType == nil {
+		contents += tabtabtab + "return\n"
+	} else {
+		contents += tabtabtab + "if result.success is not None:\n"
+		contents += tabtabtabtab + fmt.Sprintf("event.set(result.success)\n")
+		contents += tabtabtabtab + "return\n"
+		contents += tabtabtab + fmt.Sprintf(
+			"raise TApplicationException(TApplicationException.MISSING_RESULT, \"%s failed: unknown result\")\n", method.Name)
+	}
+	contents += tabtab + fmt.Sprintf("return %s_callback\n\n", method.Name)
+
+	return contents
+}
+
+func (t *GeventGenerator) generateServer(service *parser.Service) string {
+	contents := ""
+	contents += t.generateProcessor(service)
+	for _, method := range service.Methods {
+		contents += t.generateProcessorFunction(method)
+	}
+
+	contents += t.generateWriteApplicationException()
+	return contents
+}
+
+func (t *GeventGenerator) generateProcessorFunction(method *parser.Method) string {
+	contents := ""
+	contents += fmt.Sprintf("class _%s(FProcessorFunction):\n\n", method.Name)
+	contents += tab + "def __init__(self, handler, lock):\n"
+	contents += tabtab + "self._handler = handler\n"
+	contents += tabtab + "self._lock = lock\n\n"
+
+	contents += tab + "def process(self, ctx, iprot, oprot):\n"
+	contents += tabtab + fmt.Sprintf("args = %s_args()\n", method.Name)
+	contents += tabtab + "args.read(iprot)\n"
+	contents += tabtab + "iprot.readMessageEnd()\n"
+	if !method.Oneway {
+		contents += tabtab + fmt.Sprintf("result = %s_result()\n", method.Name)
+	}
+	contents += tabtab + "try:\n"
+	if method.ReturnType == nil {
+		contents += tabtabtab + fmt.Sprintf("self._handler([ctx%s])\n",
+			t.generateServerArgs(method.Arguments))
+	} else {
+		contents += tabtabtab + fmt.Sprintf("result.success = self._handler([ctx%s])\n",
+			t.generateServerArgs(method.Arguments))
+	}
+	for _, err := range method.Exceptions {
+		contents += tabtab + fmt.Sprintf("except %s as %s:\n", t.qualifiedTypeName(err.Type), err.Name)
+		contents += tabtabtab + fmt.Sprintf("result.%s = %s\n", err.Name, err.Name)
+	}
+	contents += tabtab + "except FRateLimitException as ex:\n"
+	contents += tabtabtab + "with self._lock:\n"
+	contents += tabtabtabtab +
+		fmt.Sprintf("_write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, \"%s\", ex.message)\n",
+			method.Name)
+	contents += tabtabtabtab + "return\n"
+	contents += tabtab + "except Exception as e:\n"
+	if !method.Oneway {
+		contents += tabtabtab + "with self._lock:\n"
+		contents += tabtabtabtab + fmt.Sprintf("e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, \"%s\", e.message)\n", method.Name)
+	}
+	contents += tabtabtab + "raise e\n"
+	if !method.Oneway {
+		contents += tabtab + "with self._lock:\n"
+		contents += tabtabtab + "try:\n"
+		contents += tabtabtabtab + "oprot.write_response_headers(ctx)\n"
+		contents += tabtabtabtab + fmt.Sprintf("oprot.writeMessageBegin('%s', TMessageType.REPLY, 0)\n", method.Name)
+		contents += tabtabtabtab + "result.write(oprot)\n"
+		contents += tabtabtabtab + "oprot.writeMessageEnd()\n"
+		contents += tabtabtabtab + "oprot.get_transport().flush()\n"
+		contents += tabtabtab + "except FMessageSizeException as e:\n"
+		contents += tabtabtabtab + fmt.Sprintf(
+			"raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, \"%s\", e.message)\n", method.Name)
+	}
+	contents += "\n\n"
+
+	return contents
+}
+
+// GenerateSubscriber generates the subscriber for the given scope.
+func (t *GeventGenerator) GenerateSubscriber(file *os.File, scope *parser.Scope) error {
+	subscriber := ""
+	subscriber += fmt.Sprintf("class %sSubscriber(object):\n", scope.Name)
+	if scope.Comment != nil {
+		subscriber += t.generateDocString(scope.Comment, tab)
+	}
+	subscriber += "\n"
+
+	subscriber += tab + fmt.Sprintf("_DELIMITER = '%s'\n\n", globals.TopicDelimiter)
+
+	subscriber += tab + "def __init__(self, provider, middleware=None):\n"
+	subscriber += t.generateDocString([]string{
+		fmt.Sprintf("Create a new %sSubscriber.\n", scope.Name),
+		"Args:",
+		tab + "provider: FScopeProvider",
+		tab + "middleware: ServiceMiddleware or list of ServiceMiddleware",
+	}, tabtab)
+	subscriber += "\n"
+	subscriber += tabtab + "if middleware and not isinstance(middleware, list):\n"
+	subscriber += tabtabtab + "middleware = [middleware]\n"
+	subscriber += tabtab + "self._middleware = middleware\n"
+	subscriber += tabtab + "self._provider = provider\n\n"
+
+	for _, op := range scope.Operations {
+		subscriber += t.generateSubscribeMethod(scope, op)
+		subscriber += "\n\n"
+	}
+
+	_, err := file.WriteString(subscriber)
+	return err
+}
+
+func (t *GeventGenerator) generateSubscribeMethod(scope *parser.Scope, op *parser.Operation) string {
+	args := ""
+	docstr := []string{}
+	if len(scope.Prefix.Variables) > 0 {
+		docstr = append(docstr, "Args:")
+		prefix := ""
+		for _, variable := range scope.Prefix.Variables {
+			docstr = append(docstr, tab+fmt.Sprintf("%s: string", variable))
+			args += prefix + variable
+			prefix = ", "
+		}
+		args += ", "
+	}
+	docstr = append(docstr, tab+fmt.Sprintf("%s_handler: function which takes FContext and %s", op.Name, op.Type))
+	if op.Comment != nil {
+		docstr[0] = "\n" + tabtab + docstr[0]
+		docstr = append(op.Comment, docstr...)
+	}
+	method := tab + fmt.Sprintf("def subscribe_%s(self, %s%s_handler):\n", op.Name, args, op.Name)
+	method += t.generateDocString(docstr, tabtab)
+	method += "\n"
+
+	method += tabtab + fmt.Sprintf("op = '%s'\n", op.Name)
+	method += tabtab + fmt.Sprintf("prefix = %s\n", generatePrefixStringTemplate(scope))
+	method += tabtab + fmt.Sprintf("topic = '{}%s{}{}'.format(prefix, self._DELIMITER, op)\n\n", scope.Name)
+
+	method += tabtab + "transport, protocol_factory = self._provider.new_subscriber()\n"
+	method += tabtab + fmt.Sprintf(
+		"transport.subscribe(topic, self._recv_%s(protocol_factory, op, %s_handler))\n\n",
+		op.Name, op.Name)
+
+	method += tab + fmt.Sprintf("def _recv_%s(self, protocol_factory, op, handler):\n", op.Name)
+	method += tabtab + "method = Method(handler, self._middleware)\n\n"
+
+	method += tabtab + "def callback(transport):\n"
+	method += tabtabtab + "iprot = protocol_factory.get_protocol(transport)\n"
+	method += tabtabtab + "ctx = iprot.read_request_headers()\n"
+	method += tabtabtab + "mname, _, _ = iprot.readMessageBegin()\n"
+	method += tabtabtab + "if mname != op:\n"
+	method += tabtabtabtab + "iprot.skip(TType.STRUCT)\n"
+	method += tabtabtabtab + "iprot.readMessageEnd()\n"
+	method += tabtabtabtab + "raise TApplicationException(TApplicationException.UNKNOWN_METHOD)\n"
+	method += tabtabtab + fmt.Sprintf("req = %s()\n", op.Type.Name)
+	method += tabtabtab + "req.read(iprot)\n"
+	method += tabtabtab + "iprot.readMessageEnd()\n"
+	method += tabtabtab + "try:\n"
+	method += tabtabtabtab + "method([ctx, req])\n"
+	method += tabtabtab + "except:\n"
+	method += tabtabtabtab + "traceback.print_exc()\n"
+	method += tabtabtabtab + "sys.exit(1)\n\n"
+
+	method += tabtab + "return callback\n\n"
+
+	return method
+}
diff --git a/compiler/generator/python/tornado.go b/compiler/generator/python/tornado.go
index ed8178a..f239a94 100644
--- a/compiler/generator/python/tornado.go
+++ b/compiler/generator/python/tornado.go
@@ -193,8 +193,8 @@ func (t *TornadoGenerator) generateProcessorFunction(method *parser.Method) stri
 	contents := ""
 	contents += fmt.Sprintf("class _%s(FProcessorFunction):\n\n", method.Name)
 	contents += tab + "def __init__(self, handler, lock):\n"
-	contents += tabtab + fmt.Sprintf("super(_%s, self).__init__(handler, lock)\n", method.Name)
-	contents += "\n"
+	contents += tabtab + "self._handler = handler\n"
+	contents += tabtab + "self._lock = lock\n\n"
 
 	contents += tab + "@gen.coroutine\n"
 	contents += tab + "def process(self, ctx, iprot, oprot):\n"
diff --git a/examples/Makefile b/examples/Makefile
index 28660e6..56d68d8 100644
--- a/examples/Makefile
+++ b/examples/Makefile
@@ -4,6 +4,7 @@ GO = go/gen-go
 PYTHON = python/gen-py
 PYTHON_TORNADO = python.tornado/gen-py.tornado
 PYTHON_ASYNCIO = python.asyncio/gen-py.asyncio
+PYTHON_GEVENT = python.gevent/gen-py.gevent
 DART = dart/gen-dart
 JAVA = java/src/main/java/
 
@@ -13,6 +14,7 @@ clean:
 	@-rm -rf $(PYTHON)
 	@-rm -rf $(PYTHON_TORNADO)
 	@-rm -rf $(PYTHON_ASYNCIO)
+	@-rm -rf $(PYTHON_GEVENT)
 	@-rm -rf $(DART)
 
 generate: clean
@@ -22,4 +24,5 @@ generate: clean
 		-exec frugal -out $(PYTHON) --gen py {} \; \
 		-exec frugal -out $(PYTHON_TORNADO) --gen py:tornado {} \; \
 		-exec frugal -out $(PYTHON_ASYNCIO) --gen py:asyncio {} \; \
+		-exec frugal -out $(PYTHON_GEVENT) --gen py:gevent {} \; \
 		-exec frugal -out $(DART) --gen dart {} \;
diff --git a/examples/python.asyncio/gen-py.asyncio/v1/music/f_Store.py b/examples/python.asyncio/gen-py.asyncio/v1/music/f_Store.py
index 892d016..80faff0 100644
--- a/examples/python.asyncio/gen-py.asyncio/v1/music/f_Store.py
+++ b/examples/python.asyncio/gen-py.asyncio/v1/music/f_Store.py
@@ -218,7 +218,8 @@ class Processor(FBaseProcessor):
 class _buyAlbum(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_buyAlbum, self).__init__(handler, lock)
+        self._handler = handler
+        self._write_lock = lock
 
     async def process(self, ctx, iprot, oprot):
         args = buyAlbum_args()
@@ -231,16 +232,16 @@ class _buyAlbum(FProcessorFunction):
                 ret = await ret
             result.success = ret
         except FRateLimitException as ex:
-            async with self._lock:
+            async with self._write_lock:
                 _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "buyAlbum", ex.message)
                 return
         except PurchasingError as error:
             result.error = error
         except Exception as e:
-            async with self._lock:
+            async with self._write_lock:
                 e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "buyAlbum", e.args[0])
             raise e from None
-        async with self._lock:
+        async with self._write_lock:
             try:
                 oprot.write_response_headers(ctx)
                 oprot.writeMessageBegin('buyAlbum', TMessageType.REPLY, 0)
@@ -254,7 +255,8 @@ class _buyAlbum(FProcessorFunction):
 class _enterAlbumGiveaway(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_enterAlbumGiveaway, self).__init__(handler, lock)
+        self._handler = handler
+        self._write_lock = lock
 
     async def process(self, ctx, iprot, oprot):
         args = enterAlbumGiveaway_args()
@@ -267,14 +269,14 @@ class _enterAlbumGiveaway(FProcessorFunction):
                 ret = await ret
             result.success = ret
         except FRateLimitException as ex:
-            async with self._lock:
+            async with self._write_lock:
                 _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "enterAlbumGiveaway", ex.message)
                 return
         except Exception as e:
-            async with self._lock:
+            async with self._write_lock:
                 e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "enterAlbumGiveaway", e.args[0])
             raise e from None
-        async with self._lock:
+        async with self._write_lock:
             try:
                 oprot.write_response_headers(ctx)
                 oprot.writeMessageBegin('enterAlbumGiveaway', TMessageType.REPLY, 0)
diff --git a/examples/python.asyncio/http_server.py b/examples/python.asyncio/http_server.py
index 7c5113a..3ad9331 100644
--- a/examples/python.asyncio/http_server.py
+++ b/examples/python.asyncio/http_server.py
@@ -10,7 +10,6 @@ from frugal.protocol import FProtocolFactory
 from frugal.aio.server.http_handler import new_http_handler
 
 sys.path.append(os.path.join(os.path.dirname(__file__), "gen-py.asyncio"))
-from http_client import logging_middleware
 from v1.music.f_Store import Processor as FStoreProcessor  # noqa
 from v1.music.f_Store import Iface  # noqa
 from v1.music.ttypes import Album, Track  # noqa
@@ -59,10 +58,6 @@ if __name__ == '__main__':
     # Results from the handler are returned back to the client.
     processor = FStoreProcessor(StoreHandler())
 
-    # Optionally add middleware to the processor before starting the server.
-    # add_middleware can take a list or single middleware.
-    processor.add_middleware(logging_middleware)
-
     store_handler = new_http_handler(processor, prot_factory)
     app = web.Application()
     app.router.add_route("*", "/frugal", store_handler)
diff --git a/examples/python.gevent/__init__.py b/examples/python.gevent/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/examples/python.gevent/gen-py.gevent/__init__.py b/examples/python.gevent/gen-py.gevent/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/examples/python.gevent/gen-py.gevent/v1/__init__.py b/examples/python.gevent/gen-py.gevent/v1/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/examples/python.gevent/gen-py.gevent/v1/music/__init__.py b/examples/python.gevent/gen-py.gevent/v1/music/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/examples/python.gevent/gen-py.gevent/v1/music/constants.py b/examples/python.gevent/gen-py.gevent/v1/music/constants.py
new file mode 100644
index 0000000..933c812
--- /dev/null
+++ b/examples/python.gevent/gen-py.gevent/v1/music/constants.py
@@ -0,0 +1,9 @@
+#
+# Autogenerated by Frugal Compiler (2.0.0-RC5)
+#
+# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+#
+
+from thrift.Thrift import TType, TMessageType, TException, TApplicationException
+from .ttypes import *
+
diff --git a/examples/python.gevent/gen-py.gevent/v1/music/f_AlbumWinners_publisher.py b/examples/python.gevent/gen-py.gevent/v1/music/f_AlbumWinners_publisher.py
new file mode 100644
index 0000000..8825b84
--- /dev/null
+++ b/examples/python.gevent/gen-py.gevent/v1/music/f_AlbumWinners_publisher.py
@@ -0,0 +1,74 @@
+#
+# Autogenerated by Frugal Compiler (2.0.0-RC5)
+#
+# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+#
+
+
+
+import sys
+import traceback
+
+from thrift.Thrift import TApplicationException
+from thrift.Thrift import TMessageType
+from thrift.Thrift import TType
+from frugal.middleware import Method
+from frugal.subscription import FSubscription
+from frugal.transport import TMemoryOutputBuffer
+
+from .ttypes import *
+
+
+
+
+class AlbumWinnersPublisher(object):
+    """
+    Scopes are a Frugal extension to the IDL for declaring PubSub
+    semantics. Subscribers to this scope will be notified if they win a contest.
+    Scopes must have a prefix.
+    """
+
+    _DELIMITER = '.'
+
+    def __init__(self, provider, middleware=None):
+        """
+        Create a new AlbumWinnersPublisher.
+
+        Args:
+            provider: FScopeProvider
+            middleware: ServiceMiddleware or list of ServiceMiddleware
+        """
+
+        if middleware and not isinstance(middleware, list):
+            middleware = [middleware]
+        self._transport, self._protocol_factory = provider.new_publisher()
+        self._methods = {
+            'publish_Winner': Method(self._publish_Winner, middleware),
+        }
+
+    def open(self):
+        self._transport.open()
+
+    def close(self):
+        self._transport.close()
+
+    def publish_Winner(self, ctx, req):
+        """
+        Args:
+            ctx: FContext
+            req: Album
+        """
+        self._methods['publish_Winner']([ctx, req])
+
+    def _publish_Winner(self, ctx, req):
+        op = 'Winner'
+        prefix = 'v1.music.'
+        topic = '{}AlbumWinners{}{}'.format(prefix, self._DELIMITER, op)
+        buffer = TMemoryOutputBuffer(self._transport.get_publish_size_limit())
+        oprot = self._protocol_factory.get_protocol(buffer)
+        oprot.write_request_headers(ctx)
+        oprot.writeMessageBegin(op, TMessageType.CALL, 0)
+        req.write(oprot)
+        oprot.writeMessageEnd()
+        self._transport.publish(topic, buffer.getvalue())
+
diff --git a/examples/python.gevent/gen-py.gevent/v1/music/f_AlbumWinners_subscriber.py b/examples/python.gevent/gen-py.gevent/v1/music/f_AlbumWinners_subscriber.py
new file mode 100644
index 0000000..13f2626
--- /dev/null
+++ b/examples/python.gevent/gen-py.gevent/v1/music/f_AlbumWinners_subscriber.py
@@ -0,0 +1,83 @@
+#
+# Autogenerated by Frugal Compiler (2.0.0-RC5)
+#
+# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+#
+
+
+
+import sys
+import traceback
+
+from thrift.Thrift import TApplicationException
+from thrift.Thrift import TMessageType
+from thrift.Thrift import TType
+from frugal.middleware import Method
+from frugal.subscription import FSubscription
+from frugal.transport import TMemoryOutputBuffer
+
+from .ttypes import *
+
+
+
+
+class AlbumWinnersSubscriber(object):
+    """
+    Scopes are a Frugal extension to the IDL for declaring PubSub
+    semantics. Subscribers to this scope will be notified if they win a contest.
+    Scopes must have a prefix.
+    """
+
+    _DELIMITER = '.'
+
+    def __init__(self, provider, middleware=None):
+        """
+        Create a new AlbumWinnersSubscriber.
+
+        Args:
+            provider: FScopeProvider
+            middleware: ServiceMiddleware or list of ServiceMiddleware
+        """
+
+        if middleware and not isinstance(middleware, list):
+            middleware = [middleware]
+        self._middleware = middleware
+        self._provider = provider
+
+    def subscribe_Winner(self, Winner_handler):
+        """
+            Winner_handler: function which takes FContext and Album
+        """
+
+        op = 'Winner'
+        prefix = 'v1.music.'
+        topic = '{}AlbumWinners{}{}'.format(prefix, self._DELIMITER, op)
+
+        transport, protocol_factory = self._provider.new_subscriber()
+        transport.subscribe(topic, self._recv_Winner(protocol_factory, op, Winner_handler))
+
+    def _recv_Winner(self, protocol_factory, op, handler):
+        method = Method(handler, self._middleware)
+
+        def callback(transport):
+            iprot = protocol_factory.get_protocol(transport)
+            ctx = iprot.read_request_headers()
+            mname, _, _ = iprot.readMessageBegin()
+            if mname != op:
+                iprot.skip(TType.STRUCT)
+                iprot.readMessageEnd()
+                raise TApplicationException(TApplicationException.UNKNOWN_METHOD)
+            req = Album()
+            req.read(iprot)
+            iprot.readMessageEnd()
+            try:
+                method([ctx, req])
+            except:
+                traceback.print_exc()
+                sys.exit(1)
+
+        return callback
+
+
+
+
diff --git a/examples/python.gevent/gen-py.gevent/v1/music/f_Store.py b/examples/python.gevent/gen-py.gevent/v1/music/f_Store.py
new file mode 100644
index 0000000..2b183b7
--- /dev/null
+++ b/examples/python.gevent/gen-py.gevent/v1/music/f_Store.py
@@ -0,0 +1,534 @@
+#
+# Autogenerated by Frugal Compiler (2.0.0-RC5)
+#
+# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+#
+
+
+
+from datetime import timedelta
+from threading import Lock
+
+from gevent.event import AsyncResult
+from gevent import Timeout
+
+from frugal.exceptions import FApplicationException
+from frugal.exceptions import FMessageSizeException
+from frugal.exceptions import FRateLimitException
+from frugal.exceptions import FTimeoutException
+from frugal.middleware import Method
+from frugal.processor import FBaseProcessor
+from frugal.processor import FProcessorFunction
+from frugal.transport import TMemoryOutputBuffer
+from thrift.Thrift import TApplicationException
+from thrift.Thrift import TMessageType
+from .ttypes import *
+
+
+class Iface(object):
+    """
+    Services are the API for client and server interaction.
+    Users can buy an album or enter a giveaway for a free album.
+    """
+
+    def buyAlbum(self, ctx, ASIN, acct):
+        """
+        Args:
+            ctx: FContext
+            ASIN: string
+            acct: string
+        """
+        pass
+
+    def enterAlbumGiveaway(self, ctx, email, name):
+        """
+        Args:
+            ctx: FContext
+            email: string
+            name: string
+        """
+        pass
+
+
+class Client(Iface):
+
+    def __init__(self, transport, protocol_factory, middleware=None):
+        """
+        Create a new Client with a transport and protocol factory.
+
+        Args:
+            transport: FTransport
+            protocol_factory: FProtocolFactory
+            middleware: ServiceMiddleware or list of ServiceMiddleware
+        """
+        if middleware and not isinstance(middleware, list):
+            middleware = [middleware]
+        self._transport = transport
+        self._protocol_factory = protocol_factory
+        self._oprot = protocol_factory.get_protocol(transport)
+        self._write_lock = Lock()
+        self._methods = {
+            'buyAlbum': Method(self._buyAlbum, middleware),
+            'enterAlbumGiveaway': Method(self._enterAlbumGiveaway, middleware),
+        }
+
+    def buyAlbum(self, ctx, ASIN, acct):
+        """
+        Args:
+            ctx: FContext
+            ASIN: string
+            acct: string
+        """
+        return self._methods['buyAlbum']([ctx, ASIN, acct])
+
+    def _buyAlbum(self, ctx, ASIN, acct):
+        event = AsyncResult()
+        self._transport.register(ctx, self._recv_buyAlbum(ctx, event))
+        try:
+            self._send_buyAlbum(ctx, ASIN, acct)
+            result = event.get(timeout=ctx.timeout/1000)
+        except Timeout:
+            raise FTimeoutException('buyAlbum timed out after {} milliseconds'.format(ctx.timeout))
+        finally:
+            self._transport.unregister(ctx)
+        return result
+
+    def _send_buyAlbum(self, ctx, ASIN, acct):
+        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
+        oprot = self._protocol_factory.get_protocol(buffer)
+        oprot.write_request_headers(ctx)
+        oprot.writeMessageBegin('buyAlbum', TMessageType.CALL, 0)
+        args = buyAlbum_args()
+        args.ASIN = ASIN
+        args.acct = acct
+        args.write(oprot)
+        oprot.writeMessageEnd()
+        self._transport.send(buffer.getvalue())
+
+    def _recv_buyAlbum(self, ctx, event):
+        def buyAlbum_callback(transport):
+            iprot = self._protocol_factory.get_protocol(transport)
+            iprot.read_response_headers(ctx)
+            _, mtype, _ = iprot.readMessageBegin()
+            if mtype == TMessageType.EXCEPTION:
+                x = TApplicationException()
+                x.read(iprot)
+                iprot.readMessageEnd()
+                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
+                    event.set(FMessageSizeException.response(x.message))
+                    return
+                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
+                    event.set(FRateLimitException.response(x.message))
+                    return
+                event.set(x)
+                return
+            result = buyAlbum_result()
+            result.read(iprot)
+            iprot.readMessageEnd()
+            if result.error is not None:
+                event.set(result.error)
+                return
+            if result.success is not None:
+                event.set(result.success)
+                return
+            raise TApplicationException(TApplicationException.MISSING_RESULT, "buyAlbum failed: unknown result")
+        return buyAlbum_callback
+
+    def enterAlbumGiveaway(self, ctx, email, name):
+        """
+        Args:
+            ctx: FContext
+            email: string
+            name: string
+        """
+        return self._methods['enterAlbumGiveaway']([ctx, email, name])
+
+    def _enterAlbumGiveaway(self, ctx, email, name):
+        event = AsyncResult()
+        self._transport.register(ctx, self._recv_enterAlbumGiveaway(ctx, event))
+        try:
+            self._send_enterAlbumGiveaway(ctx, email, name)
+            result = event.get(timeout=ctx.timeout/1000)
+        except Timeout:
+            raise FTimeoutException('enterAlbumGiveaway timed out after {} milliseconds'.format(ctx.timeout))
+        finally:
+            self._transport.unregister(ctx)
+        return result
+
+    def _send_enterAlbumGiveaway(self, ctx, email, name):
+        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
+        oprot = self._protocol_factory.get_protocol(buffer)
+        oprot.write_request_headers(ctx)
+        oprot.writeMessageBegin('enterAlbumGiveaway', TMessageType.CALL, 0)
+        args = enterAlbumGiveaway_args()
+        args.email = email
+        args.name = name
+        args.write(oprot)
+        oprot.writeMessageEnd()
+        self._transport.send(buffer.getvalue())
+
+    def _recv_enterAlbumGiveaway(self, ctx, event):
+        def enterAlbumGiveaway_callback(transport):
+            iprot = self._protocol_factory.get_protocol(transport)
+            iprot.read_response_headers(ctx)
+            _, mtype, _ = iprot.readMessageBegin()
+            if mtype == TMessageType.EXCEPTION:
+                x = TApplicationException()
+                x.read(iprot)
+                iprot.readMessageEnd()
+                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
+                    event.set(FMessageSizeException.response(x.message))
+                    return
+                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
+                    event.set(FRateLimitException.response(x.message))
+                    return
+                event.set(x)
+                return
+            result = enterAlbumGiveaway_result()
+            result.read(iprot)
+            iprot.readMessageEnd()
+            if result.success is not None:
+                event.set(result.success)
+                return
+            raise TApplicationException(TApplicationException.MISSING_RESULT, "enterAlbumGiveaway failed: unknown result")
+        return enterAlbumGiveaway_callback
+
+
+class Processor(FBaseProcessor):
+
+    def __init__(self, handler, middleware=None):
+        """
+        Create a new Processor.
+
+        Args:
+            handler: Iface
+        """
+        if middleware and not isinstance(middleware, list):
+            middleware = [middleware]
+
+        super(Processor, self).__init__()
+        self.add_to_processor_map('buyAlbum', _buyAlbum(Method(handler.buyAlbum, middleware), self.get_write_lock()))
+        self.add_to_processor_map('enterAlbumGiveaway', _enterAlbumGiveaway(Method(handler.enterAlbumGiveaway, middleware), self.get_write_lock()))
+
+
+class _buyAlbum(FProcessorFunction):
+
+    def __init__(self, handler, lock):
+        self._handler = handler
+        self._lock = lock
+
+    def process(self, ctx, iprot, oprot):
+        args = buyAlbum_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = buyAlbum_result()
+        try:
+            result.success = self._handler([ctx, args.ASIN, args.acct])
+        except PurchasingError as error:
+            result.error = error
+        except FRateLimitException as ex:
+            with self._lock:
+                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "buyAlbum", ex.message)
+                return
+        except Exception as e:
+            with self._lock:
+                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "buyAlbum", e.message)
+            raise e
+        with self._lock:
+            try:
+                oprot.write_response_headers(ctx)
+                oprot.writeMessageBegin('buyAlbum', TMessageType.REPLY, 0)
+                result.write(oprot)
+                oprot.writeMessageEnd()
+                oprot.get_transport().flush()
+            except FMessageSizeException as e:
+                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "buyAlbum", e.message)
+
+
+class _enterAlbumGiveaway(FProcessorFunction):
+
+    def __init__(self, handler, lock):
+        self._handler = handler
+        self._lock = lock
+
+    def process(self, ctx, iprot, oprot):
+        args = enterAlbumGiveaway_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = enterAlbumGiveaway_result()
+        try:
+            result.success = self._handler([ctx, args.email, args.name])
+        except FRateLimitException as ex:
+            with self._lock:
+                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "enterAlbumGiveaway", ex.message)
+                return
+        except Exception as e:
+            with self._lock:
+                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "enterAlbumGiveaway", e.message)
+            raise e
+        with self._lock:
+            try:
+                oprot.write_response_headers(ctx)
+                oprot.writeMessageBegin('enterAlbumGiveaway', TMessageType.REPLY, 0)
+                result.write(oprot)
+                oprot.writeMessageEnd()
+                oprot.get_transport().flush()
+            except FMessageSizeException as e:
+                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "enterAlbumGiveaway", e.message)
+
+
+def _write_application_exception(ctx, oprot, typ, method, message):
+    x = TApplicationException(type=typ, message=message)
+    oprot.write_response_headers(ctx)
+    oprot.writeMessageBegin(method, TMessageType.EXCEPTION, 0)
+    x.write(oprot)
+    oprot.writeMessageEnd()
+    oprot.get_transport().flush()
+    return x
+
+class buyAlbum_args(object):
+    """
+    Attributes:
+     - ASIN
+     - acct
+    """
+    def __init__(self, ASIN=None, acct=None):
+        self.ASIN = ASIN
+        self.acct = acct
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.ASIN = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.acct = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('buyAlbum_args')
+        if self.ASIN is not None:
+            oprot.writeFieldBegin('ASIN', TType.STRING, 1)
+            oprot.writeString(self.ASIN)
+            oprot.writeFieldEnd()
+        if self.acct is not None:
+            oprot.writeFieldBegin('acct', TType.STRING, 2)
+            oprot.writeString(self.acct)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.ASIN)
+        value = (value * 31) ^ hash(self.acct)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class buyAlbum_result(object):
+    """
+    Attributes:
+     - success
+     - error
+    """
+    def __init__(self, success=None, error=None):
+        self.success = success
+        self.error = error
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRUCT:
+                    self.success = Album()
+                    self.success.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.error = PurchasingError()
+                    self.error.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('buyAlbum_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRUCT, 0)
+            self.success.write(oprot)
+            oprot.writeFieldEnd()
+        if self.error is not None:
+            oprot.writeFieldBegin('error', TType.STRUCT, 1)
+            self.error.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.success)
+        value = (value * 31) ^ hash(self.error)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class enterAlbumGiveaway_args(object):
+    """
+    Attributes:
+     - email
+     - name
+    """
+    def __init__(self, email=None, name=None):
+        self.email = email
+        self.name = name
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.email = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.name = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('enterAlbumGiveaway_args')
+        if self.email is not None:
+            oprot.writeFieldBegin('email', TType.STRING, 1)
+            oprot.writeString(self.email)
+            oprot.writeFieldEnd()
+        if self.name is not None:
+            oprot.writeFieldBegin('name', TType.STRING, 2)
+            oprot.writeString(self.name)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.email)
+        value = (value * 31) ^ hash(self.name)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class enterAlbumGiveaway_result(object):
+    """
+    Attributes:
+     - success
+    """
+    def __init__(self, success=None):
+        self.success = success
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.BOOL:
+                    self.success = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('enterAlbumGiveaway_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.BOOL, 0)
+            oprot.writeBool(self.success)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.success)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
diff --git a/examples/python.gevent/gen-py.gevent/v1/music/ttypes.py b/examples/python.gevent/gen-py.gevent/v1/music/ttypes.py
new file mode 100644
index 0000000..bf23de0
--- /dev/null
+++ b/examples/python.gevent/gen-py.gevent/v1/music/ttypes.py
@@ -0,0 +1,304 @@
+#
+# Autogenerated by Frugal Compiler (2.0.0-RC5)
+#
+# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+#
+
+from thrift.Thrift import TType, TMessageType, TException, TApplicationException
+
+from thrift.transport import TTransport
+from thrift.protocol import TBinaryProtocol, TProtocol
+
+
+class PerfRightsOrg(object):
+    ASCAP = 1
+    BMI = 2
+    SESAC = 3
+    Other = 4
+
+    _VALUES_TO_NAMES = {
+        1: "ASCAP",
+        2: "BMI",
+        3: "SESAC",
+        4: "Other",
+    }
+
+    _NAMES_TO_VALUES = {
+        "ASCAP": 1,
+        "BMI": 2,
+        "SESAC": 3,
+        "Other": 4,
+    }
+
+class Track(object):
+    """
+    Comments (with an @ symbol) will be added to generated code.
+    
+    Attributes:
+     - title
+     - artist
+     - publisher
+     - composer
+     - duration
+     - pro
+    """
+    def __init__(self, title=None, artist=None, publisher=None, composer=None, duration=None, pro=None):
+        self.title = title
+        self.artist = artist
+        self.publisher = publisher
+        self.composer = composer
+        self.duration = duration
+        self.pro = pro
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.title = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.artist = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.publisher = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.STRING:
+                    self.composer = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.DOUBLE:
+                    self.duration = iprot.readDouble()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 6:
+                if ftype == TType.I32:
+                    self.pro = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('Track')
+        if self.title is not None:
+            oprot.writeFieldBegin('title', TType.STRING, 1)
+            oprot.writeString(self.title)
+            oprot.writeFieldEnd()
+        if self.artist is not None:
+            oprot.writeFieldBegin('artist', TType.STRING, 2)
+            oprot.writeString(self.artist)
+            oprot.writeFieldEnd()
+        if self.publisher is not None:
+            oprot.writeFieldBegin('publisher', TType.STRING, 3)
+            oprot.writeString(self.publisher)
+            oprot.writeFieldEnd()
+        if self.composer is not None:
+            oprot.writeFieldBegin('composer', TType.STRING, 4)
+            oprot.writeString(self.composer)
+            oprot.writeFieldEnd()
+        if self.duration is not None:
+            oprot.writeFieldBegin('duration', TType.DOUBLE, 5)
+            oprot.writeDouble(self.duration)
+            oprot.writeFieldEnd()
+        if self.pro is not None:
+            oprot.writeFieldBegin('pro', TType.I32, 6)
+            oprot.writeI32(self.pro)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.title)
+        value = (value * 31) ^ hash(self.artist)
+        value = (value * 31) ^ hash(self.publisher)
+        value = (value * 31) ^ hash(self.composer)
+        value = (value * 31) ^ hash(self.duration)
+        value = (value * 31) ^ hash(self.pro)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class Album(object):
+    """
+    The IDL provides set, list, and map types for representing collections
+    of data.  Our Album struct contains a list of Tracks.
+    
+    Attributes:
+     - tracks
+     - duration
+     - ASIN
+    """
+    def __init__(self, tracks=None, duration=None, ASIN=None):
+        self.tracks = tracks
+        self.duration = duration
+        self.ASIN = ASIN
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.LIST:
+                    self.tracks = []
+                    (_, elem0) = iprot.readListBegin()
+                    for _ in range(elem0):
+                        elem1 = Track()
+                        elem1.read(iprot)
+                        self.tracks.append(elem1)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.DOUBLE:
+                    self.duration = iprot.readDouble()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRING:
+                    self.ASIN = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('Album')
+        if self.tracks is not None:
+            oprot.writeFieldBegin('tracks', TType.LIST, 1)
+            oprot.writeListBegin(TType.STRUCT, len(self.tracks))
+            for elem2 in self.tracks:
+                elem2.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.duration is not None:
+            oprot.writeFieldBegin('duration', TType.DOUBLE, 2)
+            oprot.writeDouble(self.duration)
+            oprot.writeFieldEnd()
+        if self.ASIN is not None:
+            oprot.writeFieldBegin('ASIN', TType.STRING, 3)
+            oprot.writeString(self.ASIN)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.tracks)
+        value = (value * 31) ^ hash(self.duration)
+        value = (value * 31) ^ hash(self.ASIN)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class PurchasingError(TException):
+    """
+    Exceptions are converted to the native format for each compiled
+    language.
+    
+    Attributes:
+     - message
+     - error_code
+    """
+    def __init__(self, message=None, error_code=None):
+        self.message = message
+        self.error_code = error_code
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.message = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.I16:
+                    self.error_code = iprot.readI16()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('PurchasingError')
+        if self.message is not None:
+            oprot.writeFieldBegin('message', TType.STRING, 1)
+            oprot.writeString(self.message)
+            oprot.writeFieldEnd()
+        if self.error_code is not None:
+            oprot.writeFieldBegin('error_code', TType.I16, 2)
+            oprot.writeI16(self.error_code)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.message)
+        value = (value * 31) ^ hash(self.error_code)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
diff --git a/examples/python.gevent/nats_client.py b/examples/python.gevent/nats_client.py
new file mode 100644
index 0000000..d4f3b92
--- /dev/null
+++ b/examples/python.gevent/nats_client.py
@@ -0,0 +1,83 @@
+import logging
+import sys
+import uuid
+import gevent
+
+from gnats import Client as NATS
+from thrift.protocol import TJSONProtocol
+from thrift.transport.TTransport import TTransportException
+from frugal.context import FContext
+from frugal.protocol import FProtocolFactory
+from frugal.gevent.transport import FNatsTransport
+sys.path.append('gen-py.gevent')
+
+from v1.music.f_Store import Client as FStoreClient  # noqa
+from v1.music.ttypes import Album  # noqa
+
+
+root = logging.getLogger()
+root.setLevel(logging.DEBUG)
+
+ch = logging.StreamHandler(sys.stdout)
+ch.setLevel(logging.DEBUG)
+formatter = logging.Formatter(
+    '%(asctime)s - %(levelname)s - %(message)s')
+ch.setFormatter(formatter)
+root.addHandler(ch)
+
+
+def main():
+    # Declare the protocol stack used for serialization.
+    # Protocol stacks must match between clients and servers.
+    prot_factory = FProtocolFactory(TJSONProtocol.TJSONProtocolFactory())
+
+    # Open a NATS connection to send requests
+    nats_client = NATS()
+    options = {
+        "verbose": True,
+        "servers": ["nats://127.0.0.1:4222"]
+    }
+    nats_client.connect(**options)
+
+    # Create a nats transport using the connected client
+    # The transport sends data on the music-service NATS topic
+    nats_transport = FNatsTransport(nats_client, "music-service")
+
+    try:
+        nats_transport.open()
+    except TTransportException as ex:
+        root.error(ex)
+        raise ex
+
+    # Using the configured transport and protocol, create a client
+    # to talk to the music store service.
+    store_client = FStoreClient(nats_transport, prot_factory,
+                                middleware=logging_middleware)
+
+    album = store_client.buyAlbum(FContext(),
+                                        str(uuid.uuid4()),
+                                        "ACT-12345")
+
+    root.info("Bought an album %s\n", album)
+
+    store_client.enterAlbumGiveaway(FContext(),
+                                          "kevin@workiva.com",
+                                          "Kevin")
+
+    nats_transport.close()
+    nats_client.close()
+
+
+def logging_middleware(next):
+    def handler(method, args):
+        service = '%s.%s' % (method.im_self.__module__,
+                             method.im_class.__name__)
+        print '==== CALLING %s.%s ====' % (service, method.im_func.func_name)
+        ret = next(method, args)
+        print '==== CALLED  %s.%s ====' % (service, method.im_func.func_name)
+        return ret
+    return handler
+
+
+if __name__ == '__main__':
+    gevent.joinall([gevent.spawn(main)])
diff --git a/examples/python.gevent/nats_publisher.py b/examples/python.gevent/nats_publisher.py
new file mode 100644
index 0000000..25011e5
--- /dev/null
+++ b/examples/python.gevent/nats_publisher.py
@@ -0,0 +1,74 @@
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+import logging
+import sys
+import uuid
+import gevent
+
+from thrift.protocol import TBinaryProtocol
+
+from gnats import Client as NATS
+
+from frugal.protocol import FProtocolFactory
+from frugal.provider import FScopeProvider
+from frugal.context import FContext
+from frugal.gevent.transport import FNatsPublisherTransportFactory
+
+sys.path.append('gen-py.gevent')
+from v1.music.f_AlbumWinners_publisher import AlbumWinnersPublisher  # noqa
+from v1.music.ttypes import Album, Track, PerfRightsOrg  # noqa
+
+
+root = logging.getLogger()
+root.setLevel(logging.DEBUG)
+
+ch = logging.StreamHandler(sys.stdout)
+ch.setLevel(logging.DEBUG)
+formatter = logging.Formatter(
+    '%(asctime)s - %(levelname)s - %(message)s')
+ch.setFormatter(formatter)
+root.addHandler(ch)
+
+
+def main():
+    # Declare the protocol stack used for serialization.
+    # Protocol stacks must match between publishers and subscribers.
+    prot_factory = FProtocolFactory(TBinaryProtocol.TBinaryProtocolFactory())
+
+    # Open a NATS connection to receive requests
+    nats_client = NATS()
+    options = {
+        "verbose": True,
+        "servers": ["nats://127.0.0.1:4222"]
+    }
+
+    nats_client.connect(**options)
+
+    # Create a pub sub scope using the configured transport and protocol
+    transport_factory = FNatsPublisherTransportFactory(nats_client)
+    provider = FScopeProvider(transport_factory, None, prot_factory)
+
+    # Create a publisher
+    publisher = AlbumWinnersPublisher(provider)
+    publisher.open()
+
+    # Publish an album win event
+    album = Album()
+    album.ASIN = str(uuid.uuid4())
+    album.duration = 12000
+    album.tracks = [Track(title="Comme des enfants",
+                          artist="Coeur de pirate",
+                          publisher="Grosse Bote",
+                          composer="Batrice Martin",
+                          duration=169,
+                          pro=PerfRightsOrg.ASCAP)]
+
+    publisher.publish_Winner(FContext(), album)
+
+    publisher.close()
+    nats_client.close()
+
+
+if __name__ == '__main__':
+    gevent.joinall([gevent.spawn(main)])
+
diff --git a/examples/python.gevent/nats_server.py b/examples/python.gevent/nats_server.py
new file mode 100644
index 0000000..ec8d4b7
--- /dev/null
+++ b/examples/python.gevent/nats_server.py
@@ -0,0 +1,96 @@
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+import logging
+import sys
+import uuid
+import gevent
+
+from thrift.protocol import TJSONProtocol
+
+
+from gnats import Client as NATS
+
+from frugal.protocol import FProtocolFactory
+from frugal.gevent.server import FNatsGeventServer
+
+sys.path.append('gen-py.gevent')
+
+from v1.music.f_Store import Processor as FStoreProcessor  # noqa
+from v1.music.f_Store import Iface  # noqa
+from v1.music.ttypes import Album, Track, PerfRightsOrg  # noqa
+
+
+root = logging.getLogger()
+root.setLevel(logging.DEBUG)
+
+ch = logging.StreamHandler(sys.stdout)
+ch.setLevel(logging.DEBUG)
+formatter = logging.Formatter(
+    '%(asctime)s - %(levelname)s - %(message)s')
+ch.setFormatter(formatter)
+root.addHandler(ch)
+
+
+class StoreHandler(Iface):
+    """
+    A handler handles all incoming requests to the server.
+    The handler must satisfy the interface the server exposes.
+    """
+
+    def buyAlbum(self, ctx, ASIN, acct):
+        """
+        Return an album; always buy the same one.
+        """
+        album = Album()
+        album.ASIN = str(uuid.uuid4())
+        album.duration = 12000
+        album.tracks = [Track(title="Comme des enfants",
+                              artist="Coeur de pirate",
+                              publisher="Grosse Boite",
+                              composer="Beatrice Martin",
+                              duration=169,
+                              pro=PerfRightsOrg.ASCAP)]
+
+        print("buy album called")
+
+        return album
+
+    def enterAlbumGiveaway(self, ctx, email, name):
+        """
+        Always return success (true)
+        """
+        return True
+
+
+def main():
+    # Declare the protocol stack used for serialization.
+    # Protocol stacks must match between clients and servers.
+    prot_factory = FProtocolFactory(TJSONProtocol.TJSONProtocolFactory())
+
+    # Open a NATS connection to receive requests
+    nats_client = NATS()
+    options = {
+        "verbose": True,
+        "servers": ["nats://127.0.0.1:4222"]
+    }
+
+    nats_client.connect(**options)
+
+    # Create a new server processor.
+    # Incoming requests to the processor are passed to the handler.
+    # Results from the handler are returned back to the client.
+    processor = FStoreProcessor(StoreHandler())
+
+    # Create a new music store server using the processor,
+    # The server will listen on the music-service NATS topic
+    server = FNatsGeventServer(nats_client, "music-service",
+                                processor, prot_factory)
+
+    root.info("Starting server...")
+
+    server.serve()
+    # gevent.sleep(100)
+
+
+if __name__ == '__main__':
+    gevent.joinall([gevent.spawn(main)])
\ No newline at end of file
diff --git a/examples/python.gevent/nats_subscriber.py b/examples/python.gevent/nats_subscriber.py
new file mode 100644
index 0000000..f4fc9c5
--- /dev/null
+++ b/examples/python.gevent/nats_subscriber.py
@@ -0,0 +1,69 @@
+import logging
+import sys
+import uuid
+
+from thrift.protocol import TBinaryProtocol
+import gevent
+from gnats import Client as NATS
+
+from frugal.protocol.protocol_factory import FProtocolFactory
+from frugal.provider import FScopeProvider
+from frugal.gevent.transport import FNatsSubscriberTransportFactory
+
+from frugal.protocol import FProtocolFactory
+from frugal.provider import FScopeProvider
+from frugal.context import FContext
+from frugal.gevent.transport import FNatsPublisherTransportFactory
+
+from gevent.event import Event
+
+sys.path.append('gen-py.gevent')
+from v1.music.f_AlbumWinners_subscriber import AlbumWinnersSubscriber  # noqa
+from v1.music.f_AlbumWinners_publisher import AlbumWinnersPublisher  # noqa
+from v1.music.ttypes import Album, Track, PerfRightsOrg  # noqa
+
+
+root = logging.getLogger()
+root.setLevel(logging.DEBUG)
+
+ch = logging.StreamHandler(sys.stdout)
+ch.setLevel(logging.DEBUG)
+formatter = logging.Formatter(
+    '%(asctime)s - %(levelname)s - %(message)s')
+ch.setFormatter(formatter)
+root.addHandler(ch)
+
+
+def main():
+    # Declare the protocol stack used for serialization.
+    # Protocol stacks must match between publishers and subscribers.
+    prot_factory = FProtocolFactory(TBinaryProtocol.TBinaryProtocolFactory())
+
+    # Open a NATS connection to receive requests
+    nats_client = NATS()
+    options = {
+        "verbose": True,
+        "servers": ["nats://127.0.0.1:4222"]
+    }
+
+    nats_client.connect(**options)
+
+    # Create a pub sub scope using the configured transport and protocol
+    transport_factory = FNatsSubscriberTransportFactory(nats_client)
+    provider = FScopeProvider(None, transport_factory, prot_factory)
+
+    subscriber = AlbumWinnersSubscriber(provider)
+
+    def event_handler(ctx, req):
+        print("You won! {}".format(req))
+
+    print("Subscribing...")
+    subscriber.subscribe_Winner(event_handler)
+    print("Subscriber starting...")
+
+    blocking_event = Event()
+    blocking_event.wait()
+
+
+if __name__ == '__main__':
+    gevent.joinall([gevent.spawn(main)])
diff --git a/examples/python.gevent/requirements.txt b/examples/python.gevent/requirements.txt
new file mode 100644
index 0000000..f2faef3
--- /dev/null
+++ b/examples/python.gevent/requirements.txt
@@ -0,0 +1,3 @@
+thrift==0.9.3
+frugal
+httplib2==0.9.2
diff --git a/examples/python.tornado/gen-py.tornado/v1/music/f_Store.py b/examples/python.tornado/gen-py.tornado/v1/music/f_Store.py
index ace378c..ad1a65d 100644
--- a/examples/python.tornado/gen-py.tornado/v1/music/f_Store.py
+++ b/examples/python.tornado/gen-py.tornado/v1/music/f_Store.py
@@ -226,7 +226,8 @@ class Processor(FBaseProcessor):
 class _buyAlbum(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_buyAlbum, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     @gen.coroutine
     def process(self, ctx, iprot, oprot):
@@ -260,7 +261,8 @@ class _buyAlbum(FProcessorFunction):
 class _enterAlbumGiveaway(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_enterAlbumGiveaway, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     @gen.coroutine
     def process(self, ctx, iprot, oprot):
diff --git a/examples/python.tornado/http_server.py b/examples/python.tornado/http_server.py
index 561dbac..c02e426 100644
--- a/examples/python.tornado/http_server.py
+++ b/examples/python.tornado/http_server.py
@@ -10,7 +10,6 @@ from frugal.protocol import FProtocolFactory
 from frugal.tornado.server.http_handler import FTornadoHttpHandler
 
 sys.path.append('gen-py.tornado')
-from http_client import logging_middleware
 from v1.music.f_Store import Processor as FStoreProcessor  # noqa
 from v1.music.f_Store import Iface  # noqa
 from v1.music.ttypes import Album, Track, PerfRightsOrg  # noqa
@@ -66,10 +65,6 @@ if __name__ == "__main__":
     # Results from the handler are returned back to the client.
     processor = FStoreProcessor(StoreHandler())
 
-    # Optionally add middleware to the processor before starting the server.
-    # add_middleware can take a list or single middleware.
-    processor.add_middleware(logging_middleware)
-
     # Create a new music store server using the a tornado handler
     # and our configured processor and protocol
     application = tornado.web.Application([
diff --git a/examples/python.tornado/nats_client.py b/examples/python.tornado/nats_client.py
index 5d0daae..96932b8 100644
--- a/examples/python.tornado/nats_client.py
+++ b/examples/python.tornado/nats_client.py
@@ -4,7 +4,7 @@ import uuid
 
 from nats.io.client import Client as NATS
 from tornado import ioloop, gen
-from thrift.protocol import TBinaryProtocol
+from thrift.protocol import TJSONProtocol
 from thrift.transport.TTransport import TTransportException
 from frugal.context import FContext
 from frugal.protocol import FProtocolFactory
@@ -30,7 +30,7 @@ root.addHandler(ch)
 def main():
     # Declare the protocol stack used for serialization.
     # Protocol stacks must match between clients and servers.
-    prot_factory = FProtocolFactory(TBinaryProtocol.TBinaryProtocolFactory())
+    prot_factory = FProtocolFactory(TJSONProtocol.TJSONProtocolFactory())
 
     # Open a NATS connection to send requests
     nats_client = NATS()
@@ -61,9 +61,9 @@ def main():
 
     root.info("Bought an album %s\n", album)
 
-    yield store_client.enterAlbumGiveaway(FContext(),
-                                          "kevin@workiva.com",
-                                          "Kevin")
+    # yield store_client.enterAlbumGiveaway(FContext(),
+    #                                       "kevin@workiva.com",
+    #                                       "Kevin")
 
     yield nats_transport.close()
     yield nats_client.close()
diff --git a/examples/python.tornado/nats_server.py b/examples/python.tornado/nats_server.py
index e2a0552..110e069 100644
--- a/examples/python.tornado/nats_server.py
+++ b/examples/python.tornado/nats_server.py
@@ -4,7 +4,7 @@ import logging
 import sys
 import uuid
 
-from thrift.protocol import TBinaryProtocol
+from thrift.protocol import TJSONProtocol
 
 from tornado import gen, ioloop
 
@@ -64,7 +64,7 @@ class StoreHandler(Iface):
 def main():
     # Declare the protocol stack used for serialization.
     # Protocol stacks must match between clients and servers.
-    prot_factory = FProtocolFactory(TBinaryProtocol.TBinaryProtocolFactory())
+    prot_factory = FProtocolFactory(TJSONProtocol.TJSONProtocolFactory())
 
     # Open a NATS connection to receive requests
     nats_client = NATS()
diff --git a/examples/python/__init__.py b/examples/python/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/examples/python/gen-py/v1/music/f_Store.py b/examples/python/gen-py/v1/music/f_Store.py
index 9d17542..fcaf0ab 100644
--- a/examples/python/gen-py/v1/music/f_Store.py
+++ b/examples/python/gen-py/v1/music/f_Store.py
@@ -176,7 +176,8 @@ class Processor(FBaseProcessor):
 class _buyAlbum(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_buyAlbum, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     def process(self, ctx, iprot, oprot):
         args = buyAlbum_args()
@@ -206,7 +207,8 @@ class _buyAlbum(FProcessorFunction):
 class _enterAlbumGiveaway(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_enterAlbumGiveaway, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     def process(self, ctx, iprot, oprot):
         args = enterAlbumGiveaway_args()
diff --git a/examples/python/http_client.py b/examples/python/http_client.py
index e346376..913b340 100644
--- a/examples/python/http_client.py
+++ b/examples/python/http_client.py
@@ -56,13 +56,6 @@ def main():
     # Close the transport
     transport.close()
 
-def logging_middleware(next):
-    def handler(method, args):
-        print('==== CALLING %s ====', method.__name__)
-        ret = next(method, args)
-        print('==== CALLED  %s ====', method.__name__)
-        return ret
-    return handler
 
 if __name__ == '__main__':
     main()
diff --git a/examples/python/http_server.py b/examples/python/http_server.py
index 0068025..2189f1e 100644
--- a/examples/python/http_server.py
+++ b/examples/python/http_server.py
@@ -11,7 +11,6 @@ from frugal.protocol import FProtocolFactory
 from frugal.server.http_server import FHttpServer
 
 sys.path.append(os.path.join(os.path.dirname(__file__), "gen-py"))
-from http_client import logging_middleware
 from v1.music.f_Store import Processor as FStoreProcessor  # noqa
 from v1.music.f_Store import Iface  # noqa
 from v1.music.ttypes import Album, Track, PerfRightsOrg  # noqa
@@ -69,10 +68,6 @@ def main():
     # Results from the handler are returned back to the client.
     processor = FStoreProcessor(StoreHandler())
 
-    # Optionally add middleware to the processor before starting the server.
-    # add_middleware can take a list or single middleware.
-    processor.add_middleware(logging_middleware)
-
     # Create a new music store server using the processor,
     # The sever will listen on the configured URL
     server = FHttpServer(processor, ('/frugal', 9090), prot_factory)
diff --git a/lib/python/frugal/aio/processor.py b/lib/python/frugal/aio/processor.py
index a933445..daa11b3 100644
--- a/lib/python/frugal/aio/processor.py
+++ b/lib/python/frugal/aio/processor.py
@@ -10,39 +10,10 @@ logger = logging.getLogger(__name__)
 
 
 class FProcessorFunction(object):
-    """FProcessorFunction is a generic object that exposes a single process
-    call, which is used to handle a method invocation. FProcessorFunction
-    should be implemented by the generated code."""
-
-    def __init__(self, handler, lock):
-        """
-            Args:
-                handler: frugal.middleware.Method
-                lock: asyncio.Lock
-        """
-        self._handler = handler
-        self._lock = lock
 
     async def process(self, ctx, iprot, oprot):
-        """Process the request from the input protocol and write the
-        response to the output protocol.
-
-        Args:
-            iprot: input FProtocol
-            oprot: output FProtocol
-        """
         pass
 
-    def add_middleware(self, middleware):
-        """Add the given middleware to the FProcessorFunction
-        This should only be called before the server is started.
-
-            Args:
-             middleware: ServiceMiddleware
-         """
-
-        self._handler.add_middleware(middleware)
-
 
 class FProcessor(object):
     """FProcessor is a generic object which operates upon an input stream and
@@ -50,29 +21,10 @@ class FProcessor(object):
     """
 
     async def process(self, iprot, oprot):
-        """Process the request from the input protocol and write the
-        response to the output protocol.
-
-        Args:
-            iprot: input FProtocol
-            oprot: output FProtocol
-        """
-        pass
-
-    def add_middleware(self, serviceMiddleware):
-        """Add the given ServiceMiddleware to the FProcessor.
-        This should only called before the server is started.
-
-        Args:
-            serviceMiddleware: ServiceMiddleware
-        """
         pass
 
 
 class FBaseProcessor(FProcessor):
-    """FBaseProcessor is a base implementation of FProcessor. FProcessors
-    should extend this and map FProcessorFunctions. This should only be used
-    by generated code."""
 
     def __init__(self):
         """Create new instance of FBaseProcessor that will process requests."""
@@ -139,17 +91,3 @@ class FBaseProcessor(FProcessor):
 
         logger.exception(ex)
         raise ex
-
-    def add_middleware(self, middleware):
-        """Add the given middleware to the FProcessor.
-        This should only be called before the server is started.
-
-        Args:
-            middleware: ServiceMiddleware
-        """
-
-        if middleware and not isinstance(middleware, list):
-            middleware = [middleware]
-
-        for proc in self._processor_function_map.values():
-            proc.add_middleware(middleware)
diff --git a/lib/python/frugal/gevent/__init__.py b/lib/python/frugal/gevent/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/lib/python/frugal/gevent/server/__init__.py b/lib/python/frugal/gevent/server/__init__.py
new file mode 100644
index 0000000..15edf9d
--- /dev/null
+++ b/lib/python/frugal/gevent/server/__init__.py
@@ -0,0 +1,5 @@
+from frugal.gevent.server.nats_server import FNatsGeventServer
+
+__all__ = [
+    'FNatGeventServer',
+]
diff --git a/lib/python/frugal/gevent/server/nats_server.py b/lib/python/frugal/gevent/server/nats_server.py
new file mode 100644
index 0000000..314d703
--- /dev/null
+++ b/lib/python/frugal/gevent/server/nats_server.py
@@ -0,0 +1,98 @@
+import logging
+import struct
+
+import gevent
+from gevent.event import Event
+from thrift.Thrift import TApplicationException
+from thrift.transport.TTransport import TMemoryBuffer
+
+from frugal import _NATS_MAX_MESSAGE_SIZE
+from frugal.server import FServer
+from frugal.transport import TMemoryOutputBuffer
+
+logger = logging.getLogger(__name__)
+
+
+class FNatsGeventServer(FServer):
+    """An implementation of FServer which uses NATS as the underlying transport.
+    Clients must connect with the FNatsTransport"""
+
+    def __init__(self, nats_client, subjects, processor,
+                 protocol_factory, queue=""):
+        """Create a new instance of FStatelessNatsTornadoServer
+
+        Args:
+            nats_client: connected instance of gnats.Client
+            subject: subject to listen on
+            processor: FProcess
+            protocol_factory: FProtocolFactory
+        """
+        self._nats_client = nats_client
+        self._subjects = [subjects] if isinstance(subjects, basestring) \
+            else subjects
+        self._processor = processor
+        self._iprot_factory = protocol_factory
+        self._oprot_factory = protocol_factory
+        self._queue = queue
+        self._subs = []
+
+    def serve(self):
+        """Subscribe to provided subject and listen on provided queue"""
+        queue = self._queue
+        cb = self._on_message_callback
+
+        self._subs = [
+            self._nats_client.subscribe(
+                subject,
+                queue=queue,
+                cb=cb
+            ) for subject in self._subjects
+        ]
+
+        logger.info("Frugal server running...")
+        blocking_event = Event()
+        blocking_event.wait()
+
+    def stop(self):
+        """Unsubscribe from server subject"""
+        logger.debug("Frugal server stopping...")
+        for sid in self._sub_ids:
+            self._nats_client.unsubscribe(sid)
+
+    def _on_message_callback(self, msg):
+        """Process and respond to server request on server subject
+
+        Args:
+            msg: request message published to server subject
+        """
+        reply_to = msg.reply
+        if not reply_to:
+            logger.warn("Discarding invalid NATS request (no reply)")
+            return
+
+        frame_size = struct.unpack('!I', msg.data[:4])[0]
+        if frame_size > _NATS_MAX_MESSAGE_SIZE - 4:
+            logger.warning("Invalid frame size, dropping message.")
+            return
+
+        # Read and process frame (exclude first 4 bytes which
+        # represent frame size).
+        iprot = self._iprot_factory.get_protocol(
+            TMemoryBuffer(msg.data[4:])
+        )
+        otrans = TMemoryOutputBuffer(_NATS_MAX_MESSAGE_SIZE)
+        oprot = self._oprot_factory.get_protocol(otrans)
+
+        try:
+            self._processor.process(iprot, oprot)
+        except TApplicationException:
+            # Continue so the exception is sent to the client
+            pass
+        except Exception as e:
+            print(e)
+            return
+
+        if len(otrans) == 4:
+            return
+
+        self._nats_client.publish(reply_to, otrans.getvalue())
diff --git a/lib/python/frugal/gevent/transport/__init__.py b/lib/python/frugal/gevent/transport/__init__.py
new file mode 100644
index 0000000..a4956ee
--- /dev/null
+++ b/lib/python/frugal/gevent/transport/__init__.py
@@ -0,0 +1,18 @@
+from .gevent_transport import FGeventTransport
+from .nats_scope_transport import (
+    FNatsPublisherTransportFactory,
+    FNatsPublisherTranpsort,
+    FNatsSubscriberTransportFactory,
+    FNatsSubscriberTransport,
+)
+from .nats_transport import FNatsTransport
+
+
+__all__ = [
+    'FGeventTransport',
+    'FNatsTransport',
+    'FNatsPublisherTransportFactory',
+    'FNatsSubscriberTransportFactory',
+    'FNatsPublisherTranpsort',
+    'FNatsSubscriberTransport',
+]
diff --git a/lib/python/frugal/gevent/transport/gevent_transport.py b/lib/python/frugal/gevent/transport/gevent_transport.py
new file mode 100644
index 0000000..ed46c2d
--- /dev/null
+++ b/lib/python/frugal/gevent/transport/gevent_transport.py
@@ -0,0 +1,60 @@
+from frugal.registry import FRegistryImpl
+from frugal.transport import FTransport
+
+
+class FGeventTransport(FTransport):
+    """ FTornadoTransport implements the buffered write data and registry
+    interactions shared by all FTransports.
+    """
+
+    def __init__(self, max_message_size=1024 * 1024):
+        super(FGeventTransport, self).__init__()
+        self._max_message_size = max_message_size
+
+        self._registry = FRegistryImpl()
+
+    def register(self, context, callback):
+        """Register a provided FContext and callback function with the
+        transport's internal FRegistry.
+
+        Args:
+            context: FContext to register.
+            callback: function to register.
+
+        Raises:
+            StandardError: if registry has not been set.
+        """
+        self._registry.register(context, callback)
+
+    def unregister(self, context):
+        """Unregsiter the given context from the transports internal registry.
+
+        Args:
+            context: FContext to remove from the registry.
+
+        Raises:
+            StandardError: if registry has not been set.
+        """
+        self._registry.unregister(context)
+
+    def is_open(self):
+        raise NotImplementedError("You must override this.")
+
+    def open(self):
+        raise NotImplementedError("You must override this.")
+
+    def close(self):
+        raise NotImplementedError("You must override this.")
+
+    def get_request_size_limit(self):
+        return self._max_message_size
+
+    def send(self, data):
+        raise NotImplementedError('You must override this.')
+
+    def execute_frame(self, frame):
+        """Execute a frugal frame.
+        NOTE: this frame must include the frame size.
+        """
+        self._registry.execute(frame[4:])
+
diff --git a/lib/python/frugal/gevent/transport/nats_scope_transport.py b/lib/python/frugal/gevent/transport/nats_scope_transport.py
new file mode 100644
index 0000000..b41d02b
--- /dev/null
+++ b/lib/python/frugal/gevent/transport/nats_scope_transport.py
@@ -0,0 +1,99 @@
+import logging
+
+import gevent
+from thrift.transport.TTransport import TTransportException, TMemoryBuffer
+
+from frugal import _NATS_MAX_MESSAGE_SIZE
+from frugal.transport import FPublisherTransportFactory
+from frugal.transport import FPublisherTransport
+from frugal.transport import FSubscriberTransportFactory
+from frugal.transport import FSubscriberTransport
+from frugal.exceptions import FMessageSizeException
+
+_FRAME_BUFFER_SIZE = 5
+_FRUGAL_PREFIX = "frugal."
+
+logger = logging.getLogger(__name__)
+
+
+class FNatsPublisherTransportFactory(FPublisherTransportFactory):
+    def __init__(self, nats_client):
+        self._nats_client = nats_client
+
+    def get_transport(self):
+        return FNatsPublisherTranpsort(self._nats_client)
+
+
+class FNatsPublisherTranpsort(FPublisherTransport):
+
+    def __init__(self, nats_client):
+        super(FNatsPublisherTranpsort, self).__init__(_NATS_MAX_MESSAGE_SIZE)
+        self._nats_client = nats_client
+
+    def open(self):
+        if not self._nats_client.is_connected:
+            msg = "Nats not connected!"
+            raise TTransportException(TTransportException.NOT_OPEN, msg)
+
+    def close(self):
+        if not self.is_open():
+            return
+
+        self._nats_client.flush()
+
+    def is_open(self):
+        return self._nats_client.is_connected
+
+    def publish(self, topic, data):
+        if not self.is_open():
+            msg = 'Nats not connected!'
+            raise TTransportException(TTransportException.NOT_OPEN, msg)
+        if self._check_publish_size(data):
+            msg = 'Message exceeds NATS max message size'
+            raise FMessageSizeException.request(msg)
+        self._nats_client.publish('frugal.{0}'.format(topic), data)
+
+
+class FNatsSubscriberTransportFactory(FSubscriberTransportFactory):
+    def __init__(self, nats_client, queue=''):
+        self._nats_client = nats_client
+        self._queue = queue
+
+    def get_transport(self):
+        return FNatsSubscriberTransport(self._nats_client, self._queue)
+
+
+class FNatsSubscriberTransport(FSubscriberTransport):
+
+    def __init__(self, nats_client, queue):
+        self._nats_client = nats_client
+        self._queue = queue
+        self._is_subscribed = False
+        self._sub = None
+
+    def subscribe(self, topic, callback):
+        if not self._nats_client.is_connected:
+            msg = "Nats not connected!"
+            raise TTransportException(TTransportException.NOT_OPEN, msg)
+
+        if self.is_subscribed():
+            msg = "Already subscribed to nats topic!"
+            raise TTransportException(TTransportException.ALREADY_OPEN, msg)
+
+        self._sub = self._nats_client.subscribe(
+            'frugal.{0}'.format(topic),
+            queue=self._queue,
+            cb=lambda message: callback(TMemoryBuffer(message.data[4:]))
+        )
+        self._is_subscribed = True
+
+
+    def unsubscribe(self):
+        if not self.is_subscribed():
+            return
+        self._nats_client.unsubscribe(self._sub.id)
+        self._sub = None
+        self._is_subscribed = False
+
+    def is_subscribed(self):
+        return self._is_subscribed and self._nats_client.is_connected
diff --git a/lib/python/frugal/gevent/transport/nats_transport.py b/lib/python/frugal/gevent/transport/nats_transport.py
new file mode 100644
index 0000000..0ead236
--- /dev/null
+++ b/lib/python/frugal/gevent/transport/nats_transport.py
@@ -0,0 +1,68 @@
+from gnats.client.utils import new_inbox
+from thrift.transport.TTransport import TTransportException
+import gevent
+from frugal.gevent.transport import FGeventTransport
+
+_NOT_OPEN = 'NATS not connected.'
+_ALREAD_OPEN = 'NATS transport already open.'
+
+
+class FNatsTransport(FGeventTransport):
+    """FNatsTransport is an extension of FTransport. This is a "stateless"
+    transport in the sense that there is no connection with a server. A request
+    is simply published to a subject and responses are received on another
+    subject. This assumes requests/responses fit within a single NATS message.
+    """
+
+    def __init__(self, nats_client, subject, inbox=""):
+        """Create a new instance of FStatelessNatsTornadoServer
+
+        Args:
+            nats_client: connected instance of nats.io.Client
+            subject: subject to publish to
+        """
+        super(FNatsTransport, self).__init__()
+        self._nats_client = nats_client
+        self._subject = subject
+        self._inbox = inbox or new_inbox()
+        self._is_open = False
+        self._sub = None
+
+    def is_open(self):
+        return self._is_open and self._nats_client.is_connected
+
+    def open(self):
+        """Subscribes to the configured inbox subject"""
+        if not self._nats_client.is_connected:
+            raise TTransportException(TTransportException.NOT_OPEN, _NOT_OPEN)
+
+        elif self.is_open():
+            already_open = TTransportException.ALREADY_OPEN
+            raise TTransportException(already_open, _ALREAD_OPEN)
+
+        cb = self._on_message_callback
+        inbox = self._inbox
+        self._sub = self._nats_client.subscribe(inbox, cb=cb)
+
+        self._is_open = True
+
+    def _on_message_callback(self, msg):
+        self.execute_frame(msg.data)
+
+    def close(self):
+        """Unsubscribes from the inbox subject"""
+        if not self._sub:
+            return
+        self._nats_client.flush()
+        self._nats_client.unsubscribe(self._sub)
+        self._is_open = False
+
+    def send(self, data):
+        """Sends the buffered bytes over NATS"""
+        if not self.is_open():
+            raise TTransportException(TTransportException.NOT_OPEN, _NOT_OPEN)
+
+        subject = self._subject
+        inbox = self._inbox
+        self._nats_client.publish(subject, data, reply=inbox)
+
diff --git a/lib/python/frugal/middleware.py b/lib/python/frugal/middleware.py
index b9669ea..b60293f 100644
--- a/lib/python/frugal/middleware.py
+++ b/lib/python/frugal/middleware.py
@@ -53,20 +53,6 @@ class Method(object):
 
         return self._handler(self._proxied_method, *args)
 
-    def add_middleware(self, middleware):
-        """Add the given middleware to the Method.
-        This should only be called before the server is started.
-
-            Args:
-             middleware: ServiceMiddleware
-         """
-
-        handler = self._handler
-        if middleware:
-            for m in middleware:
-                handler = m(handler)
-        self._handler = handler
-
 
 def _compose_middleware(method, middleware):
     """Apply the given ServiceMiddleware to the provided method and return
diff --git a/lib/python/frugal/processor.py b/lib/python/frugal/processor.py
index ddcddc6..0a2de98 100644
--- a/lib/python/frugal/processor.py
+++ b/lib/python/frugal/processor.py
@@ -10,69 +10,21 @@ logger = logging.getLogger(__name__)
 
 
 class FProcessorFunction(object):
-    """FProcessorFunction is a generic object that exposes a single process
-    call, which is used to handle a method invocation. FProcessorFunction
-    should be implemented by the generated code."""
-
-    def __init__(self, handler, lock):
-        """
-            Args:
-                handler: frugal.middleware.Method
-                lock: threading.Lock
-        """
-        self._handler = handler
-        self._lock = lock
 
     def process(self, ctx, iprot, oprot):
-        """Process the request from the input protocol and write the
-        response to the output protocol.
-
-        Args:
-            iprot: input FProtocol
-            oprot: output FProtocol
-        """
         pass
 
-    def add_middleware(self, middleware):
-        """Add the given middleware to the FProcessorFunction
-        This should only be called before the server is started.
-
-            Args:
-             middleware: ServiceMiddleware
-         """
-
-        self._handler.add_middleware(middleware)
-
 
 class FProcessor(object):
     """FProcessor is a generic object which operates upon an input stream and
-    writes to some output stream. FProcessor extends object.
+    writes to some output stream.
     """
 
     def process(self, iprot, oprot):
-        """Process the request from the input protocol and write the
-        response to the output protocol.
-
-        Args:
-            iprot: input FProtocol
-            oprot: output FProtocol
-        """
-        pass
-
-    def add_middleware(self, serviceMiddleware):
-        """Adds the given ServiceMiddleware to the FProcessor. This should
-        only called before the server is started.
-
-        Args:
-            serviceMiddleware: ServiceMiddleware
-        """
         pass
 
 
 class FBaseProcessor(FProcessor):
-    """FBaseProcessor is a base implementation of FProcessor. FProcessors
-    should extend this and map FProcessorFunctions. This should only be used
-    by generated code."""
 
     def __init__(self):
         """Create new instance of FBaseProcessor that will process requests."""
@@ -142,18 +94,3 @@ class FBaseProcessor(FProcessor):
 
         logger.exception(ex)
         raise ex
-
-    def add_middleware(self, middleware):
-        """Add the given middleware to the FProcessor.
-        This should only be called before the server is started.
-
-        Args:
-            middleware: ServiceMiddleware
-        """
-
-        if middleware and not isinstance(middleware, list):
-            middleware = [middleware]
-
-        for proc in self._processor_function_map.values():
-            proc.add_middleware(middleware)
-
diff --git a/lib/python/frugal/tests/tornado/transport/test_nats_scope_transport.py b/lib/python/frugal/tests/tornado/transport/test_nats_scope_transport.py
index 0d52ad0..30c502a 100644
--- a/lib/python/frugal/tests/tornado/transport/test_nats_scope_transport.py
+++ b/lib/python/frugal/tests/tornado/transport/test_nats_scope_transport.py
@@ -6,7 +6,7 @@ from tornado.testing import gen_test, AsyncTestCase
 from thrift.transport.TTransport import TTransportException
 
 from frugal.exceptions import FMessageSizeException
-from frugal.tornado.transport import FNatsPublisherTransport
+from frugal.tornado.transport import FNatsPublisherTranpsort
 from frugal.tornado.transport import FNatsSubscriberTransport
 
 
@@ -17,7 +17,7 @@ class TestFNatsScopeTransport(AsyncTestCase):
 
         self.nats_client = mock.Mock()
 
-        self.publisher_transport = FNatsPublisherTransport(self.nats_client)
+        self.publisher_transport = FNatsPublisherTranpsort(self.nats_client)
         self.subscriber_transport = FNatsSubscriberTransport(
             self.nats_client, "Q")
 
diff --git a/lib/python/frugal/tornado/processor.py b/lib/python/frugal/tornado/processor.py
index 77c644e..5c413c8 100644
--- a/lib/python/frugal/tornado/processor.py
+++ b/lib/python/frugal/tornado/processor.py
@@ -11,40 +11,11 @@ logger = logging.getLogger(__name__)
 
 
 class FProcessorFunction(object):
-    """FProcessorFunction is a generic object that exposes a single process
-    call, which is used to handle a method invocation. FProcessorFunction
-    should be implemented by the generated code."""
-
-    def __init__(self, handler, lock):
-        """
-            Args:
-                handler: frugal.middleware.Method
-                lock: tornado.locks.Lock
-        """
-        self._handler = handler
-        self._lock = lock
 
     @gen.coroutine
     def process(self, ctx, iprot, oprot):
-        """Process the request from the input protocol and write the
-        response to the output protocol.
-
-        Args:
-            iprot: input FProtocol
-            oprot: output FProtocol
-        """
         pass
 
-    def add_middleware(self, middleware):
-        """Add the given middleware to the FProcessorFunction
-        This should only be called before the server is started.
-
-            Args:
-             middleware: ServiceMiddleware
-         """
-
-        self._handler.add_middleware(middleware)
-
 
 class FProcessor(object):
     """FProcessor is a generic object which operates upon an input stream and
@@ -52,29 +23,10 @@ class FProcessor(object):
     """
     @gen.coroutine
     def process(self, iprot, oprot):
-        """Process the request from the input protocol and write the
-        response to the output protocol.
-
-        Args:
-            iprot: input FProtocol
-            oprot: output FProtocol
-        """
-        pass
-
-    def add_middleware(self, middleware):
-        """Add the given middleware to the FProcessor
-        This should only be called before the server is started.
-
-            Args:
-             middleware: ServiceMiddleware
-         """
         pass
 
 
 class FBaseProcessor(FProcessor):
-    """FBaseProcessor is a base implementation of FProcessor. FProcessors
-    should extend this and map FProcessorFunctions. This should only be used
-    by generated code."""
 
     def __init__(self):
         """Create new instance of FBaseProcessor that will process requests."""
@@ -142,17 +94,3 @@ class FBaseProcessor(FProcessor):
 
         logger.exception(ex)
         raise ex
-
-    def add_middleware(self, middleware):
-        """Add the given middleware to the FProcessor.
-        This should only be called before the server is started.
-
-        Args:
-            middleware: ServiceMiddleware
-        """
-
-        if middleware and not isinstance(middleware, list):
-            middleware = [middleware]
-
-        for proc in self._processor_function_map.values():
-            proc.add_middleware(middleware)
\ No newline at end of file
diff --git a/lib/python/frugal/tornado/transport/__init__.py b/lib/python/frugal/tornado/transport/__init__.py
index 78636c5..0f61e7e 100644
--- a/lib/python/frugal/tornado/transport/__init__.py
+++ b/lib/python/frugal/tornado/transport/__init__.py
@@ -2,7 +2,7 @@ from .tornado_transport import FTornadoTransport
 from .http_transport import FHttpTransport
 from .nats_scope_transport import (
     FNatsPublisherTransportFactory,
-    FNatsPublisherTransport,
+    FNatsPublisherTranpsort,
     FNatsSubscriberTransportFactory,
     FNatsSubscriberTransport,
 )
@@ -15,6 +15,6 @@ __all__ = [
     'FHttpTransport',
     'FNatsPublisherTransportFactory',
     'FNatsSubscriberTransportFactory',
-    'FNatsPublisherTransport',
+    'FNatsPublisherTranpsort',
     'FNatsSubscriberTransport',
 ]
diff --git a/lib/python/frugal/tornado/transport/nats_scope_transport.py b/lib/python/frugal/tornado/transport/nats_scope_transport.py
index ef02c2d..588a43c 100644
--- a/lib/python/frugal/tornado/transport/nats_scope_transport.py
+++ b/lib/python/frugal/tornado/transport/nats_scope_transport.py
@@ -21,12 +21,12 @@ class FNatsPublisherTransportFactory(FPublisherTransportFactory):
         self._nats_client = nats_client
 
     def get_transport(self):
-        return FNatsPublisherTransport(self._nats_client)
+        return FNatsPublisherTranpsort(self._nats_client)
 
 
-class FNatsPublisherTransport(FPublisherTransport):
+class FNatsPublisherTranpsort(FPublisherTransport):
     def __init__(self, nats_client):
-        super(FNatsPublisherTransport, self).__init__(_NATS_MAX_MESSAGE_SIZE)
+        super(FNatsPublisherTranpsort, self).__init__(_NATS_MAX_MESSAGE_SIZE)
         self._nats_client = nats_client
 
     @gen.coroutine
diff --git a/test/expected/python.asyncio/actual_base/f_BaseFoo.py b/test/expected/python.asyncio/actual_base/f_BaseFoo.py
index fe92967..3bdf1ee 100644
--- a/test/expected/python.asyncio/actual_base/f_BaseFoo.py
+++ b/test/expected/python.asyncio/actual_base/f_BaseFoo.py
@@ -126,7 +126,8 @@ class Processor(FBaseProcessor):
 class _basePing(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_basePing, self).__init__(handler, lock)
+        self._handler = handler
+        self._write_lock = lock
 
     async def process(self, ctx, iprot, oprot):
         args = basePing_args()
@@ -138,14 +139,14 @@ class _basePing(FProcessorFunction):
             if inspect.iscoroutine(ret):
                 ret = await ret
         except FRateLimitException as ex:
-            async with self._lock:
+            async with self._write_lock:
                 _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "basePing", ex.message)
                 return
         except Exception as e:
-            async with self._lock:
+            async with self._write_lock:
                 e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "basePing", e.args[0])
             raise e from None
-        async with self._lock:
+        async with self._write_lock:
             try:
                 oprot.write_response_headers(ctx)
                 oprot.writeMessageBegin('basePing', TMessageType.REPLY, 0)
diff --git a/test/expected/python.asyncio/service_extension_same_file/f_BasePinger.py b/test/expected/python.asyncio/service_extension_same_file/f_BasePinger.py
index fe92967..3bdf1ee 100644
--- a/test/expected/python.asyncio/service_extension_same_file/f_BasePinger.py
+++ b/test/expected/python.asyncio/service_extension_same_file/f_BasePinger.py
@@ -126,7 +126,8 @@ class Processor(FBaseProcessor):
 class _basePing(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_basePing, self).__init__(handler, lock)
+        self._handler = handler
+        self._write_lock = lock
 
     async def process(self, ctx, iprot, oprot):
         args = basePing_args()
@@ -138,14 +139,14 @@ class _basePing(FProcessorFunction):
             if inspect.iscoroutine(ret):
                 ret = await ret
         except FRateLimitException as ex:
-            async with self._lock:
+            async with self._write_lock:
                 _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "basePing", ex.message)
                 return
         except Exception as e:
-            async with self._lock:
+            async with self._write_lock:
                 e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "basePing", e.args[0])
             raise e from None
-        async with self._lock:
+        async with self._write_lock:
             try:
                 oprot.write_response_headers(ctx)
                 oprot.writeMessageBegin('basePing', TMessageType.REPLY, 0)
diff --git a/test/expected/python.asyncio/service_extension_same_file/f_Pinger.py b/test/expected/python.asyncio/service_extension_same_file/f_Pinger.py
index f0ac9da..0002154 100644
--- a/test/expected/python.asyncio/service_extension_same_file/f_Pinger.py
+++ b/test/expected/python.asyncio/service_extension_same_file/f_Pinger.py
@@ -127,7 +127,8 @@ class Processor(f_BasePinger.Processor):
 class _ping(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_ping, self).__init__(handler, lock)
+        self._handler = handler
+        self._write_lock = lock
 
     async def process(self, ctx, iprot, oprot):
         args = ping_args()
@@ -139,14 +140,14 @@ class _ping(FProcessorFunction):
             if inspect.iscoroutine(ret):
                 ret = await ret
         except FRateLimitException as ex:
-            async with self._lock:
+            async with self._write_lock:
                 _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "ping", ex.message)
                 return
         except Exception as e:
-            async with self._lock:
+            async with self._write_lock:
                 e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "ping", e.args[0])
             raise e from None
-        async with self._lock:
+        async with self._write_lock:
             try:
                 oprot.write_response_headers(ctx)
                 oprot.writeMessageBegin('ping', TMessageType.REPLY, 0)
diff --git a/test/expected/python.asyncio/variety/f_Foo.py b/test/expected/python.asyncio/variety/f_Foo.py
index 73f1155..3dd5900 100644
--- a/test/expected/python.asyncio/variety/f_Foo.py
+++ b/test/expected/python.asyncio/variety/f_Foo.py
@@ -707,7 +707,8 @@ class Processor(actual_base.python.f_BaseFoo.Processor):
 class _ping(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_ping, self).__init__(handler, lock)
+        self._handler = handler
+        self._write_lock = lock
 
     async def process(self, ctx, iprot, oprot):
         args = ping_args()
@@ -719,14 +720,14 @@ class _ping(FProcessorFunction):
             if inspect.iscoroutine(ret):
                 ret = await ret
         except FRateLimitException as ex:
-            async with self._lock:
+            async with self._write_lock:
                 _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "ping", ex.message)
                 return
         except Exception as e:
-            async with self._lock:
+            async with self._write_lock:
                 e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "ping", e.args[0])
             raise e from None
-        async with self._lock:
+        async with self._write_lock:
             try:
                 oprot.write_response_headers(ctx)
                 oprot.writeMessageBegin('ping', TMessageType.REPLY, 0)
@@ -740,7 +741,8 @@ class _ping(FProcessorFunction):
 class _blah(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_blah, self).__init__(handler, lock)
+        self._handler = handler
+        self._write_lock = lock
 
     async def process(self, ctx, iprot, oprot):
         args = blah_args()
@@ -753,7 +755,7 @@ class _blah(FProcessorFunction):
                 ret = await ret
             result.success = ret
         except FRateLimitException as ex:
-            async with self._lock:
+            async with self._write_lock:
                 _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "blah", ex.message)
                 return
         except AwesomeException as awe:
@@ -761,10 +763,10 @@ class _blah(FProcessorFunction):
         except actual_base.python.ttypes.api_exception as api:
             result.api = api
         except Exception as e:
-            async with self._lock:
+            async with self._write_lock:
                 e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "blah", e.args[0])
             raise e from None
-        async with self._lock:
+        async with self._write_lock:
             try:
                 oprot.write_response_headers(ctx)
                 oprot.writeMessageBegin('blah', TMessageType.REPLY, 0)
@@ -778,7 +780,8 @@ class _blah(FProcessorFunction):
 class _oneWay(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_oneWay, self).__init__(handler, lock)
+        self._handler = handler
+        self._write_lock = lock
 
     async def process(self, ctx, iprot, oprot):
         args = oneWay_args()
@@ -789,7 +792,7 @@ class _oneWay(FProcessorFunction):
             if inspect.iscoroutine(ret):
                 ret = await ret
         except FRateLimitException as ex:
-            async with self._lock:
+            async with self._write_lock:
                 _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "oneWay", ex.message)
                 return
         except Exception as e:
@@ -799,7 +802,8 @@ class _oneWay(FProcessorFunction):
 class _bin_method(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_bin_method, self).__init__(handler, lock)
+        self._handler = handler
+        self._write_lock = lock
 
     async def process(self, ctx, iprot, oprot):
         args = bin_method_args()
@@ -812,16 +816,16 @@ class _bin_method(FProcessorFunction):
                 ret = await ret
             result.success = ret
         except FRateLimitException as ex:
-            async with self._lock:
+            async with self._write_lock:
                 _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "bin_method", ex.message)
                 return
         except actual_base.python.ttypes.api_exception as api:
             result.api = api
         except Exception as e:
-            async with self._lock:
+            async with self._write_lock:
                 e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "bin_method", e.args[0])
             raise e from None
-        async with self._lock:
+        async with self._write_lock:
             try:
                 oprot.write_response_headers(ctx)
                 oprot.writeMessageBegin('bin_method', TMessageType.REPLY, 0)
@@ -835,7 +839,8 @@ class _bin_method(FProcessorFunction):
 class _param_modifiers(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_param_modifiers, self).__init__(handler, lock)
+        self._handler = handler
+        self._write_lock = lock
 
     async def process(self, ctx, iprot, oprot):
         args = param_modifiers_args()
@@ -848,14 +853,14 @@ class _param_modifiers(FProcessorFunction):
                 ret = await ret
             result.success = ret
         except FRateLimitException as ex:
-            async with self._lock:
+            async with self._write_lock:
                 _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "param_modifiers", ex.message)
                 return
         except Exception as e:
-            async with self._lock:
+            async with self._write_lock:
                 e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "param_modifiers", e.args[0])
             raise e from None
-        async with self._lock:
+        async with self._write_lock:
             try:
                 oprot.write_response_headers(ctx)
                 oprot.writeMessageBegin('param_modifiers', TMessageType.REPLY, 0)
@@ -869,7 +874,8 @@ class _param_modifiers(FProcessorFunction):
 class _underlying_types_test(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_underlying_types_test, self).__init__(handler, lock)
+        self._handler = handler
+        self._write_lock = lock
 
     async def process(self, ctx, iprot, oprot):
         args = underlying_types_test_args()
@@ -882,14 +888,14 @@ class _underlying_types_test(FProcessorFunction):
                 ret = await ret
             result.success = ret
         except FRateLimitException as ex:
-            async with self._lock:
+            async with self._write_lock:
                 _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "underlying_types_test", ex.message)
                 return
         except Exception as e:
-            async with self._lock:
+            async with self._write_lock:
                 e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "underlying_types_test", e.args[0])
             raise e from None
-        async with self._lock:
+        async with self._write_lock:
             try:
                 oprot.write_response_headers(ctx)
                 oprot.writeMessageBegin('underlying_types_test', TMessageType.REPLY, 0)
@@ -903,7 +909,8 @@ class _underlying_types_test(FProcessorFunction):
 class _getThing(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_getThing, self).__init__(handler, lock)
+        self._handler = handler
+        self._write_lock = lock
 
     async def process(self, ctx, iprot, oprot):
         args = getThing_args()
@@ -916,14 +923,14 @@ class _getThing(FProcessorFunction):
                 ret = await ret
             result.success = ret
         except FRateLimitException as ex:
-            async with self._lock:
+            async with self._write_lock:
                 _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "getThing", ex.message)
                 return
         except Exception as e:
-            async with self._lock:
+            async with self._write_lock:
                 e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "getThing", e.args[0])
             raise e from None
-        async with self._lock:
+        async with self._write_lock:
             try:
                 oprot.write_response_headers(ctx)
                 oprot.writeMessageBegin('getThing', TMessageType.REPLY, 0)
@@ -937,7 +944,8 @@ class _getThing(FProcessorFunction):
 class _getMyInt(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_getMyInt, self).__init__(handler, lock)
+        self._handler = handler
+        self._write_lock = lock
 
     async def process(self, ctx, iprot, oprot):
         args = getMyInt_args()
@@ -950,14 +958,14 @@ class _getMyInt(FProcessorFunction):
                 ret = await ret
             result.success = ret
         except FRateLimitException as ex:
-            async with self._lock:
+            async with self._write_lock:
                 _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "getMyInt", ex.message)
                 return
         except Exception as e:
-            async with self._lock:
+            async with self._write_lock:
                 e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "getMyInt", e.args[0])
             raise e from None
-        async with self._lock:
+        async with self._write_lock:
             try:
                 oprot.write_response_headers(ctx)
                 oprot.writeMessageBegin('getMyInt', TMessageType.REPLY, 0)
@@ -971,7 +979,8 @@ class _getMyInt(FProcessorFunction):
 class _use_subdir_struct(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_use_subdir_struct, self).__init__(handler, lock)
+        self._handler = handler
+        self._write_lock = lock
 
     async def process(self, ctx, iprot, oprot):
         args = use_subdir_struct_args()
@@ -984,14 +993,14 @@ class _use_subdir_struct(FProcessorFunction):
                 ret = await ret
             result.success = ret
         except FRateLimitException as ex:
-            async with self._lock:
+            async with self._write_lock:
                 _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "use_subdir_struct", ex.message)
                 return
         except Exception as e:
-            async with self._lock:
+            async with self._write_lock:
                 e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "use_subdir_struct", e.args[0])
             raise e from None
-        async with self._lock:
+        async with self._write_lock:
             try:
                 oprot.write_response_headers(ctx)
                 oprot.writeMessageBegin('use_subdir_struct', TMessageType.REPLY, 0)
diff --git a/test/expected/python.gevent/actual_base/constants.py b/test/expected/python.gevent/actual_base/constants.py
new file mode 100644
index 0000000..b20f4da
--- /dev/null
+++ b/test/expected/python.gevent/actual_base/constants.py
@@ -0,0 +1,10 @@
+#
+# Autogenerated by Frugal Compiler (2.0.0-RC5)
+#
+# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+#
+
+from thrift.Thrift import TType, TMessageType, TException, TApplicationException
+from .ttypes import *
+
+const_i32_from_base = 582
diff --git a/test/expected/python.gevent/actual_base/f_BaseFoo.py b/test/expected/python.gevent/actual_base/f_BaseFoo.py
new file mode 100644
index 0000000..14e1cd3
--- /dev/null
+++ b/test/expected/python.gevent/actual_base/f_BaseFoo.py
@@ -0,0 +1,238 @@
+#
+# Autogenerated by Frugal Compiler (2.0.0-RC5)
+#
+# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+#
+
+
+
+from datetime import timedelta
+from threading import Lock
+
+from gevent.event import AsyncResult
+from gevent import Timeout
+
+from frugal.exceptions import FApplicationException
+from frugal.exceptions import FMessageSizeException
+from frugal.exceptions import FRateLimitException
+from frugal.exceptions import FTimeoutException
+from frugal.middleware import Method
+from frugal.processor import FBaseProcessor
+from frugal.processor import FProcessorFunction
+from frugal.transport import TMemoryOutputBuffer
+from thrift.Thrift import TApplicationException
+from thrift.Thrift import TMessageType
+from .ttypes import *
+
+
+class Iface(object):
+
+    def basePing(self, ctx):
+        """
+        Args:
+            ctx: FContext
+        """
+        pass
+
+
+class Client(Iface):
+
+    def __init__(self, transport, protocol_factory, middleware=None):
+        """
+        Create a new Client with a transport and protocol factory.
+
+        Args:
+            transport: FTransport
+            protocol_factory: FProtocolFactory
+            middleware: ServiceMiddleware or list of ServiceMiddleware
+        """
+        if middleware and not isinstance(middleware, list):
+            middleware = [middleware]
+        self._transport = transport
+        self._protocol_factory = protocol_factory
+        self._oprot = protocol_factory.get_protocol(transport)
+        self._write_lock = Lock()
+        self._methods = {
+            'basePing': Method(self._basePing, middleware),
+        }
+
+    def basePing(self, ctx):
+        """
+        Args:
+            ctx: FContext
+        """
+        return self._methods['basePing']([ctx])
+
+    def _basePing(self, ctx):
+        event = AsyncResult()
+        self._transport.register(ctx, self._recv_basePing(ctx, event))
+        try:
+            self._send_basePing(ctx)
+            result = event.get(timeout=ctx.timeout/1000)
+        except Timeout:
+            raise FTimeoutException('basePing timed out after {} milliseconds'.format(ctx.timeout))
+        finally:
+            self._transport.unregister(ctx)
+        return result
+
+    def _send_basePing(self, ctx):
+        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
+        oprot = self._protocol_factory.get_protocol(buffer)
+        oprot.write_request_headers(ctx)
+        oprot.writeMessageBegin('basePing', TMessageType.CALL, 0)
+        args = basePing_args()
+        args.write(oprot)
+        oprot.writeMessageEnd()
+        self._transport.send(buffer.getvalue())
+
+    def _recv_basePing(self, ctx, event):
+        def basePing_callback(transport):
+            iprot = self._protocol_factory.get_protocol(transport)
+            iprot.read_response_headers(ctx)
+            _, mtype, _ = iprot.readMessageBegin()
+            if mtype == TMessageType.EXCEPTION:
+                x = TApplicationException()
+                x.read(iprot)
+                iprot.readMessageEnd()
+                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
+                    event.set(FMessageSizeException.response(x.message))
+                    return
+                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
+                    event.set(FRateLimitException.response(x.message))
+                    return
+                event.set(x)
+                return
+            result = basePing_result()
+            result.read(iprot)
+            iprot.readMessageEnd()
+            return
+        return basePing_callback
+
+
+class Processor(FBaseProcessor):
+
+    def __init__(self, handler, middleware=None):
+        """
+        Create a new Processor.
+
+        Args:
+            handler: Iface
+        """
+        if middleware and not isinstance(middleware, list):
+            middleware = [middleware]
+
+        super(Processor, self).__init__()
+        self.add_to_processor_map('basePing', _basePing(Method(handler.basePing, middleware), self.get_write_lock()))
+
+
+class _basePing(FProcessorFunction):
+
+    def __init__(self, handler, lock):
+        self._handler = handler
+        self._lock = lock
+
+    def process(self, ctx, iprot, oprot):
+        args = basePing_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = basePing_result()
+        try:
+            self._handler([ctx])
+        except FRateLimitException as ex:
+            with self._lock:
+                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "basePing", ex.message)
+                return
+        except Exception as e:
+            with self._lock:
+                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "basePing", e.message)
+            raise e
+        with self._lock:
+            try:
+                oprot.write_response_headers(ctx)
+                oprot.writeMessageBegin('basePing', TMessageType.REPLY, 0)
+                result.write(oprot)
+                oprot.writeMessageEnd()
+                oprot.get_transport().flush()
+            except FMessageSizeException as e:
+                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "basePing", e.message)
+
+
+def _write_application_exception(ctx, oprot, typ, method, message):
+    x = TApplicationException(type=typ, message=message)
+    oprot.write_response_headers(ctx)
+    oprot.writeMessageBegin(method, TMessageType.EXCEPTION, 0)
+    x.write(oprot)
+    oprot.writeMessageEnd()
+    oprot.get_transport().flush()
+    return x
+
+class basePing_args(object):
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('basePing_args')
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class basePing_result(object):
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('basePing_result')
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
diff --git a/test/expected/python.gevent/actual_base/ttypes.py b/test/expected/python.gevent/actual_base/ttypes.py
new file mode 100644
index 0000000..9f2a7dd
--- /dev/null
+++ b/test/expected/python.gevent/actual_base/ttypes.py
@@ -0,0 +1,195 @@
+#
+# Autogenerated by Frugal Compiler (2.0.0-RC5)
+#
+# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+#
+
+from thrift.Thrift import TType, TMessageType, TException, TApplicationException
+
+from thrift.transport import TTransport
+from thrift.protocol import TBinaryProtocol, TProtocol
+
+
+class base_health_condition(object):
+    PASS = 1
+    WARN = 2
+    FAIL = 3
+    UNKNOWN = 4
+
+    _VALUES_TO_NAMES = {
+        1: "PASS",
+        2: "WARN",
+        3: "FAIL",
+        4: "UNKNOWN",
+    }
+
+    _NAMES_TO_VALUES = {
+        "PASS": 1,
+        "WARN": 2,
+        "FAIL": 3,
+        "UNKNOWN": 4,
+    }
+
+class thing(object):
+    """
+    Attributes:
+     - an_id
+     - a_string
+    """
+    def __init__(self, an_id=None, a_string=None):
+        self.an_id = an_id
+        self.a_string = a_string
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.I32:
+                    self.an_id = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.a_string = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('thing')
+        if self.an_id is not None:
+            oprot.writeFieldBegin('an_id', TType.I32, 1)
+            oprot.writeI32(self.an_id)
+            oprot.writeFieldEnd()
+        if self.a_string is not None:
+            oprot.writeFieldBegin('a_string', TType.STRING, 2)
+            oprot.writeString(self.a_string)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.an_id)
+        value = (value * 31) ^ hash(self.a_string)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class nested_thing(object):
+    """
+    Attributes:
+     - things
+    """
+    def __init__(self, things=None):
+        self.things = things
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.LIST:
+                    self.things = []
+                    (_, elem56) = iprot.readListBegin()
+                    for _ in range(elem56):
+                        elem57 = thing()
+                        elem57.read(iprot)
+                        self.things.append(elem57)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('nested_thing')
+        if self.things is not None:
+            oprot.writeFieldBegin('things', TType.LIST, 1)
+            oprot.writeListBegin(TType.STRUCT, len(self.things))
+            for elem58 in self.things:
+                elem58.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.things)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class api_exception(TException):
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('api_exception')
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __hash__(self):
+        value = 17
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
diff --git a/test/expected/python.gevent/variety/constants.py b/test/expected/python.gevent/variety/constants.py
new file mode 100644
index 0000000..8035167
--- /dev/null
+++ b/test/expected/python.gevent/variety/constants.py
@@ -0,0 +1,64 @@
+#
+# Autogenerated by Frugal Compiler (2.0.0-RC5)
+#
+# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+#
+
+from thrift.Thrift import TType, TMessageType, TException, TApplicationException
+from .ttypes import *
+
+import actual_base.python.ttypes
+import actual_base.python.constants
+
+import validStructs.ttypes
+import validStructs.constants
+
+import ValidTypes.ttypes
+import ValidTypes.constants
+
+import subdir_include.ttypes
+import subdir_include.constants
+
+redef_const = actual_base.python.constants.const_i32_from_base
+DEFAULT_ID = -1
+other_default = DEFAULT_ID
+thirtyfour = 34
+MAPCONSTANT = {
+    "hello": "world",
+    "goodnight": "moon",
+}
+ConstEvent1 = Event(**{
+    "ID": -2,
+    "Message": "first one",
+})
+ConstEvent2 = Event(**{
+    "ID": -7,
+    "Message": "second one",
+})
+NumsList = [
+    2,
+    4,
+    7,
+    1,
+]
+NumsSet = set([
+    1,
+    3,
+    8,
+    0,
+])
+MAPCONSTANT2 = {
+    "hello": Event(**{
+        "ID": -2,
+        "Message": "first here",
+    }),
+}
+bin_const = "hello"
+true_constant = True
+false_constant = False
+const_hc = 2
+evil_string = "thin'g\" \""
+evil_string2 = "th'ing\"ad\"f"
+const_lower = TestLowercase(**{
+    "lowercaseInt": 2,
+})
diff --git a/test/expected/python.gevent/variety/f_Events_publisher.py b/test/expected/python.gevent/variety/f_Events_publisher.py
new file mode 100644
index 0000000..2c6e199
--- /dev/null
+++ b/test/expected/python.gevent/variety/f_Events_publisher.py
@@ -0,0 +1,77 @@
+#
+# Autogenerated by Frugal Compiler (2.0.0-RC5)
+#
+# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+#
+
+
+
+import sys
+import traceback
+
+from thrift.Thrift import TApplicationException
+from thrift.Thrift import TMessageType
+from thrift.Thrift import TType
+from frugal.middleware import Method
+from frugal.subscription import FSubscription
+from frugal.transport import TMemoryOutputBuffer
+
+from .ttypes import *
+
+
+
+
+class EventsPublisher(object):
+    """
+    This docstring gets added to the generated code because it has
+    the @ sign. Prefix specifies topic prefix tokens, which can be static or
+    variable.
+    """
+
+    _DELIMITER = '.'
+
+    def __init__(self, provider, middleware=None):
+        """
+        Create a new EventsPublisher.
+
+        Args:
+            provider: FScopeProvider
+            middleware: ServiceMiddleware or list of ServiceMiddleware
+        """
+
+        if middleware and not isinstance(middleware, list):
+            middleware = [middleware]
+        self._transport, self._protocol_factory = provider.new_publisher()
+        self._methods = {
+            'publish_EventCreated': Method(self._publish_EventCreated, middleware),
+        }
+
+    def open(self):
+        self._transport.open()
+
+    def close(self):
+        self._transport.close()
+
+    def publish_EventCreated(self, ctx, user, req):
+        """
+        This is a docstring.
+        
+        Args:
+            ctx: FContext
+            user: string
+            req: Event
+        """
+        self._methods['publish_EventCreated']([ctx, user, req])
+
+    def _publish_EventCreated(self, ctx, user, req):
+        op = 'EventCreated'
+        prefix = 'foo.{}.'.format(user)
+        topic = '{}Events{}{}'.format(prefix, self._DELIMITER, op)
+        buffer = TMemoryOutputBuffer(self._transport.get_publish_size_limit())
+        oprot = self._protocol_factory.get_protocol(buffer)
+        oprot.write_request_headers(ctx)
+        oprot.writeMessageBegin(op, TMessageType.CALL, 0)
+        req.write(oprot)
+        oprot.writeMessageEnd()
+        self._transport.publish(topic, buffer.getvalue())
+
diff --git a/test/expected/python.gevent/variety/f_Events_subscriber.py b/test/expected/python.gevent/variety/f_Events_subscriber.py
new file mode 100644
index 0000000..1e20f53
--- /dev/null
+++ b/test/expected/python.gevent/variety/f_Events_subscriber.py
@@ -0,0 +1,87 @@
+#
+# Autogenerated by Frugal Compiler (2.0.0-RC5)
+#
+# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+#
+
+
+
+import sys
+import traceback
+
+from thrift.Thrift import TApplicationException
+from thrift.Thrift import TMessageType
+from thrift.Thrift import TType
+from frugal.middleware import Method
+from frugal.subscription import FSubscription
+from frugal.transport import TMemoryOutputBuffer
+
+from .ttypes import *
+
+
+
+
+class EventsSubscriber(object):
+    """
+    This docstring gets added to the generated code because it has
+    the @ sign. Prefix specifies topic prefix tokens, which can be static or
+    variable.
+    """
+
+    _DELIMITER = '.'
+
+    def __init__(self, provider, middleware=None):
+        """
+        Create a new EventsSubscriber.
+
+        Args:
+            provider: FScopeProvider
+            middleware: ServiceMiddleware or list of ServiceMiddleware
+        """
+
+        if middleware and not isinstance(middleware, list):
+            middleware = [middleware]
+        self._middleware = middleware
+        self._provider = provider
+
+    def subscribe_EventCreated(self, user, EventCreated_handler):
+        """
+        This is a docstring.
+        
+        Args:
+            user: string
+            EventCreated_handler: function which takes FContext and Event
+        """
+
+        op = 'EventCreated'
+        prefix = 'foo.{}.'.format(user)
+        topic = '{}Events{}{}'.format(prefix, self._DELIMITER, op)
+
+        transport, protocol_factory = self._provider.new_subscriber()
+        transport.subscribe(topic, self._recv_EventCreated(protocol_factory, op, EventCreated_handler))
+
+    def _recv_EventCreated(self, protocol_factory, op, handler):
+        method = Method(handler, self._middleware)
+
+        def callback(transport):
+            iprot = protocol_factory.get_protocol(transport)
+            ctx = iprot.read_request_headers()
+            mname, _, _ = iprot.readMessageBegin()
+            if mname != op:
+                iprot.skip(TType.STRUCT)
+                iprot.readMessageEnd()
+                raise TApplicationException(TApplicationException.UNKNOWN_METHOD)
+            req = Event()
+            req.read(iprot)
+            iprot.readMessageEnd()
+            try:
+                method([ctx, req])
+            except:
+                traceback.print_exc()
+                sys.exit(1)
+
+        return callback
+
+
+
+
diff --git a/test/expected/python.gevent/variety/f_Foo.py b/test/expected/python.gevent/variety/f_Foo.py
new file mode 100644
index 0000000..397c417
--- /dev/null
+++ b/test/expected/python.gevent/variety/f_Foo.py
@@ -0,0 +1,1948 @@
+#
+# Autogenerated by Frugal Compiler (2.0.0-RC5)
+#
+# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+#
+
+
+
+from datetime import timedelta
+from threading import Lock
+
+from gevent.event import AsyncResult
+from gevent import Timeout
+
+from frugal.exceptions import FApplicationException
+from frugal.exceptions import FMessageSizeException
+from frugal.exceptions import FRateLimitException
+from frugal.exceptions import FTimeoutException
+from frugal.middleware import Method
+from frugal.processor import FBaseProcessor
+from frugal.processor import FProcessorFunction
+from frugal.transport import TMemoryOutputBuffer
+from thrift.Thrift import TApplicationException
+from thrift.Thrift import TMessageType
+import actual_base.python.ttypes
+import actual_base.python.constants
+import actual_base.python.f_BaseFoo
+import validStructs.ttypes
+import validStructs.constants
+import validStructs.f_BaseFoo
+import ValidTypes.ttypes
+import ValidTypes.constants
+import ValidTypes.f_BaseFoo
+import subdir_include.ttypes
+import subdir_include.constants
+import subdir_include.f_BaseFoo
+from .ttypes import *
+
+
+class Iface(actual_base.python.f_BaseFoo.Iface):
+    """
+    This is a thrift service. Frugal will generate bindings that include
+    a frugal Context for each service call.
+    """
+
+    def ping(self, ctx):
+        """
+        Ping the server.
+        
+        Args:
+            ctx: FContext
+        """
+        pass
+
+    def blah(self, ctx, num, Str, event):
+        """
+        Blah the server.
+        
+        Args:
+            ctx: FContext
+            num: int (signed 32 bits)
+            Str: string
+            event: Event
+        """
+        pass
+
+    def oneWay(self, ctx, id, req):
+        """
+        oneway methods don't receive a response from the server.
+        
+        Args:
+            ctx: FContext
+            id: int (signed 64 bits)
+            req: dict of <int (signed 32 bits), string>
+        """
+        pass
+
+    def bin_method(self, ctx, bin, Str):
+        """
+        Args:
+            ctx: FContext
+            bin: binary string
+            Str: string
+        """
+        pass
+
+    def param_modifiers(self, ctx, opt_num, default_num, req_num):
+        """
+        Args:
+            ctx: FContext
+            opt_num: int (signed 32 bits)
+            default_num: int (signed 32 bits)
+            req_num: int (signed 32 bits)
+        """
+        pass
+
+    def underlying_types_test(self, ctx, list_type, set_type):
+        """
+        Args:
+            ctx: FContext
+            list_type: list of int (signed 64 bits)
+            set_type: set of int (signed 64 bits)
+        """
+        pass
+
+    def getThing(self, ctx):
+        """
+        Args:
+            ctx: FContext
+        """
+        pass
+
+    def getMyInt(self, ctx):
+        """
+        Args:
+            ctx: FContext
+        """
+        pass
+
+    def use_subdir_struct(self, ctx, a):
+        """
+        Args:
+            ctx: FContext
+            a: subdir_include.A
+        """
+        pass
+
+
+class Client(actual_base.python.f_BaseFoo.Client, Iface):
+
+    def __init__(self, transport, protocol_factory, middleware=None):
+        """
+        Create a new Client with a transport and protocol factory.
+
+        Args:
+            transport: FTransport
+            protocol_factory: FProtocolFactory
+            middleware: ServiceMiddleware or list of ServiceMiddleware
+        """
+        if middleware and not isinstance(middleware, list):
+            middleware = [middleware]
+        super(Client, self).__init__(transport, protocol_factory,
+                                     middleware=middleware)
+        self._methods.update({
+            'ping': Method(self._ping, middleware),
+            'blah': Method(self._blah, middleware),
+            'oneWay': Method(self._oneWay, middleware),
+            'bin_method': Method(self._bin_method, middleware),
+            'param_modifiers': Method(self._param_modifiers, middleware),
+            'underlying_types_test': Method(self._underlying_types_test, middleware),
+            'getThing': Method(self._getThing, middleware),
+            'getMyInt': Method(self._getMyInt, middleware),
+            'use_subdir_struct': Method(self._use_subdir_struct, middleware),
+        })
+
+    def ping(self, ctx):
+        """
+        Ping the server.
+        
+        Args:
+            ctx: FContext
+        """
+        return self._methods['ping']([ctx])
+
+    def _ping(self, ctx):
+        event = AsyncResult()
+        self._transport.register(ctx, self._recv_ping(ctx, event))
+        try:
+            self._send_ping(ctx)
+            result = event.get(timeout=ctx.timeout/1000)
+        except Timeout:
+            raise FTimeoutException('ping timed out after {} milliseconds'.format(ctx.timeout))
+        finally:
+            self._transport.unregister(ctx)
+        return result
+
+    def _send_ping(self, ctx):
+        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
+        oprot = self._protocol_factory.get_protocol(buffer)
+        oprot.write_request_headers(ctx)
+        oprot.writeMessageBegin('ping', TMessageType.CALL, 0)
+        args = ping_args()
+        args.write(oprot)
+        oprot.writeMessageEnd()
+        self._transport.send(buffer.getvalue())
+
+    def _recv_ping(self, ctx, event):
+        def ping_callback(transport):
+            iprot = self._protocol_factory.get_protocol(transport)
+            iprot.read_response_headers(ctx)
+            _, mtype, _ = iprot.readMessageBegin()
+            if mtype == TMessageType.EXCEPTION:
+                x = TApplicationException()
+                x.read(iprot)
+                iprot.readMessageEnd()
+                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
+                    event.set(FMessageSizeException.response(x.message))
+                    return
+                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
+                    event.set(FRateLimitException.response(x.message))
+                    return
+                event.set(x)
+                return
+            result = ping_result()
+            result.read(iprot)
+            iprot.readMessageEnd()
+            return
+        return ping_callback
+
+    def blah(self, ctx, num, Str, event):
+        """
+        Blah the server.
+        
+        Args:
+            ctx: FContext
+            num: int (signed 32 bits)
+            Str: string
+            event: Event
+        """
+        return self._methods['blah']([ctx, num, Str, event])
+
+    def _blah(self, ctx, num, Str, event):
+        event = AsyncResult()
+        self._transport.register(ctx, self._recv_blah(ctx, event))
+        try:
+            self._send_blah(ctx, num, Str, event)
+            result = event.get(timeout=ctx.timeout/1000)
+        except Timeout:
+            raise FTimeoutException('blah timed out after {} milliseconds'.format(ctx.timeout))
+        finally:
+            self._transport.unregister(ctx)
+        return result
+
+    def _send_blah(self, ctx, num, Str, event):
+        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
+        oprot = self._protocol_factory.get_protocol(buffer)
+        oprot.write_request_headers(ctx)
+        oprot.writeMessageBegin('blah', TMessageType.CALL, 0)
+        args = blah_args()
+        args.num = num
+        args.Str = Str
+        args.event = event
+        args.write(oprot)
+        oprot.writeMessageEnd()
+        self._transport.send(buffer.getvalue())
+
+    def _recv_blah(self, ctx, event):
+        def blah_callback(transport):
+            iprot = self._protocol_factory.get_protocol(transport)
+            iprot.read_response_headers(ctx)
+            _, mtype, _ = iprot.readMessageBegin()
+            if mtype == TMessageType.EXCEPTION:
+                x = TApplicationException()
+                x.read(iprot)
+                iprot.readMessageEnd()
+                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
+                    event.set(FMessageSizeException.response(x.message))
+                    return
+                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
+                    event.set(FRateLimitException.response(x.message))
+                    return
+                event.set(x)
+                return
+            result = blah_result()
+            result.read(iprot)
+            iprot.readMessageEnd()
+            if result.awe is not None:
+                event.set(result.awe)
+                return
+            if result.api is not None:
+                event.set(result.api)
+                return
+            if result.success is not None:
+                event.set(result.success)
+                return
+            raise TApplicationException(TApplicationException.MISSING_RESULT, "blah failed: unknown result")
+        return blah_callback
+
+    def oneWay(self, ctx, id, req):
+        """
+        oneway methods don't receive a response from the server.
+        
+        Args:
+            ctx: FContext
+            id: int (signed 64 bits)
+            req: dict of <int (signed 32 bits), string>
+        """
+        return self._methods['oneWay']([ctx, id, req])
+
+    def _oneWay(self, ctx, id, req):
+        self._send_oneWay(ctx, id, req)
+
+    def _send_oneWay(self, ctx, id, req):
+        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
+        oprot = self._protocol_factory.get_protocol(buffer)
+        oprot.write_request_headers(ctx)
+        oprot.writeMessageBegin('oneWay', TMessageType.CALL, 0)
+        args = oneWay_args()
+        args.id = id
+        args.req = req
+        args.write(oprot)
+        oprot.writeMessageEnd()
+        self._transport.send(buffer.getvalue())
+
+    def bin_method(self, ctx, bin, Str):
+        """
+        Args:
+            ctx: FContext
+            bin: binary string
+            Str: string
+        """
+        return self._methods['bin_method']([ctx, bin, Str])
+
+    def _bin_method(self, ctx, bin, Str):
+        event = AsyncResult()
+        self._transport.register(ctx, self._recv_bin_method(ctx, event))
+        try:
+            self._send_bin_method(ctx, bin, Str)
+            result = event.get(timeout=ctx.timeout/1000)
+        except Timeout:
+            raise FTimeoutException('bin_method timed out after {} milliseconds'.format(ctx.timeout))
+        finally:
+            self._transport.unregister(ctx)
+        return result
+
+    def _send_bin_method(self, ctx, bin, Str):
+        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
+        oprot = self._protocol_factory.get_protocol(buffer)
+        oprot.write_request_headers(ctx)
+        oprot.writeMessageBegin('bin_method', TMessageType.CALL, 0)
+        args = bin_method_args()
+        args.bin = bin
+        args.Str = Str
+        args.write(oprot)
+        oprot.writeMessageEnd()
+        self._transport.send(buffer.getvalue())
+
+    def _recv_bin_method(self, ctx, event):
+        def bin_method_callback(transport):
+            iprot = self._protocol_factory.get_protocol(transport)
+            iprot.read_response_headers(ctx)
+            _, mtype, _ = iprot.readMessageBegin()
+            if mtype == TMessageType.EXCEPTION:
+                x = TApplicationException()
+                x.read(iprot)
+                iprot.readMessageEnd()
+                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
+                    event.set(FMessageSizeException.response(x.message))
+                    return
+                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
+                    event.set(FRateLimitException.response(x.message))
+                    return
+                event.set(x)
+                return
+            result = bin_method_result()
+            result.read(iprot)
+            iprot.readMessageEnd()
+            if result.api is not None:
+                event.set(result.api)
+                return
+            if result.success is not None:
+                event.set(result.success)
+                return
+            raise TApplicationException(TApplicationException.MISSING_RESULT, "bin_method failed: unknown result")
+        return bin_method_callback
+
+    def param_modifiers(self, ctx, opt_num, default_num, req_num):
+        """
+        Args:
+            ctx: FContext
+            opt_num: int (signed 32 bits)
+            default_num: int (signed 32 bits)
+            req_num: int (signed 32 bits)
+        """
+        return self._methods['param_modifiers']([ctx, opt_num, default_num, req_num])
+
+    def _param_modifiers(self, ctx, opt_num, default_num, req_num):
+        event = AsyncResult()
+        self._transport.register(ctx, self._recv_param_modifiers(ctx, event))
+        try:
+            self._send_param_modifiers(ctx, opt_num, default_num, req_num)
+            result = event.get(timeout=ctx.timeout/1000)
+        except Timeout:
+            raise FTimeoutException('param_modifiers timed out after {} milliseconds'.format(ctx.timeout))
+        finally:
+            self._transport.unregister(ctx)
+        return result
+
+    def _send_param_modifiers(self, ctx, opt_num, default_num, req_num):
+        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
+        oprot = self._protocol_factory.get_protocol(buffer)
+        oprot.write_request_headers(ctx)
+        oprot.writeMessageBegin('param_modifiers', TMessageType.CALL, 0)
+        args = param_modifiers_args()
+        args.opt_num = opt_num
+        args.default_num = default_num
+        args.req_num = req_num
+        args.write(oprot)
+        oprot.writeMessageEnd()
+        self._transport.send(buffer.getvalue())
+
+    def _recv_param_modifiers(self, ctx, event):
+        def param_modifiers_callback(transport):
+            iprot = self._protocol_factory.get_protocol(transport)
+            iprot.read_response_headers(ctx)
+            _, mtype, _ = iprot.readMessageBegin()
+            if mtype == TMessageType.EXCEPTION:
+                x = TApplicationException()
+                x.read(iprot)
+                iprot.readMessageEnd()
+                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
+                    event.set(FMessageSizeException.response(x.message))
+                    return
+                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
+                    event.set(FRateLimitException.response(x.message))
+                    return
+                event.set(x)
+                return
+            result = param_modifiers_result()
+            result.read(iprot)
+            iprot.readMessageEnd()
+            if result.success is not None:
+                event.set(result.success)
+                return
+            raise TApplicationException(TApplicationException.MISSING_RESULT, "param_modifiers failed: unknown result")
+        return param_modifiers_callback
+
+    def underlying_types_test(self, ctx, list_type, set_type):
+        """
+        Args:
+            ctx: FContext
+            list_type: list of int (signed 64 bits)
+            set_type: set of int (signed 64 bits)
+        """
+        return self._methods['underlying_types_test']([ctx, list_type, set_type])
+
+    def _underlying_types_test(self, ctx, list_type, set_type):
+        event = AsyncResult()
+        self._transport.register(ctx, self._recv_underlying_types_test(ctx, event))
+        try:
+            self._send_underlying_types_test(ctx, list_type, set_type)
+            result = event.get(timeout=ctx.timeout/1000)
+        except Timeout:
+            raise FTimeoutException('underlying_types_test timed out after {} milliseconds'.format(ctx.timeout))
+        finally:
+            self._transport.unregister(ctx)
+        return result
+
+    def _send_underlying_types_test(self, ctx, list_type, set_type):
+        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
+        oprot = self._protocol_factory.get_protocol(buffer)
+        oprot.write_request_headers(ctx)
+        oprot.writeMessageBegin('underlying_types_test', TMessageType.CALL, 0)
+        args = underlying_types_test_args()
+        args.list_type = list_type
+        args.set_type = set_type
+        args.write(oprot)
+        oprot.writeMessageEnd()
+        self._transport.send(buffer.getvalue())
+
+    def _recv_underlying_types_test(self, ctx, event):
+        def underlying_types_test_callback(transport):
+            iprot = self._protocol_factory.get_protocol(transport)
+            iprot.read_response_headers(ctx)
+            _, mtype, _ = iprot.readMessageBegin()
+            if mtype == TMessageType.EXCEPTION:
+                x = TApplicationException()
+                x.read(iprot)
+                iprot.readMessageEnd()
+                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
+                    event.set(FMessageSizeException.response(x.message))
+                    return
+                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
+                    event.set(FRateLimitException.response(x.message))
+                    return
+                event.set(x)
+                return
+            result = underlying_types_test_result()
+            result.read(iprot)
+            iprot.readMessageEnd()
+            if result.success is not None:
+                event.set(result.success)
+                return
+            raise TApplicationException(TApplicationException.MISSING_RESULT, "underlying_types_test failed: unknown result")
+        return underlying_types_test_callback
+
+    def getThing(self, ctx):
+        """
+        Args:
+            ctx: FContext
+        """
+        return self._methods['getThing']([ctx])
+
+    def _getThing(self, ctx):
+        event = AsyncResult()
+        self._transport.register(ctx, self._recv_getThing(ctx, event))
+        try:
+            self._send_getThing(ctx)
+            result = event.get(timeout=ctx.timeout/1000)
+        except Timeout:
+            raise FTimeoutException('getThing timed out after {} milliseconds'.format(ctx.timeout))
+        finally:
+            self._transport.unregister(ctx)
+        return result
+
+    def _send_getThing(self, ctx):
+        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
+        oprot = self._protocol_factory.get_protocol(buffer)
+        oprot.write_request_headers(ctx)
+        oprot.writeMessageBegin('getThing', TMessageType.CALL, 0)
+        args = getThing_args()
+        args.write(oprot)
+        oprot.writeMessageEnd()
+        self._transport.send(buffer.getvalue())
+
+    def _recv_getThing(self, ctx, event):
+        def getThing_callback(transport):
+            iprot = self._protocol_factory.get_protocol(transport)
+            iprot.read_response_headers(ctx)
+            _, mtype, _ = iprot.readMessageBegin()
+            if mtype == TMessageType.EXCEPTION:
+                x = TApplicationException()
+                x.read(iprot)
+                iprot.readMessageEnd()
+                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
+                    event.set(FMessageSizeException.response(x.message))
+                    return
+                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
+                    event.set(FRateLimitException.response(x.message))
+                    return
+                event.set(x)
+                return
+            result = getThing_result()
+            result.read(iprot)
+            iprot.readMessageEnd()
+            if result.success is not None:
+                event.set(result.success)
+                return
+            raise TApplicationException(TApplicationException.MISSING_RESULT, "getThing failed: unknown result")
+        return getThing_callback
+
+    def getMyInt(self, ctx):
+        """
+        Args:
+            ctx: FContext
+        """
+        return self._methods['getMyInt']([ctx])
+
+    def _getMyInt(self, ctx):
+        event = AsyncResult()
+        self._transport.register(ctx, self._recv_getMyInt(ctx, event))
+        try:
+            self._send_getMyInt(ctx)
+            result = event.get(timeout=ctx.timeout/1000)
+        except Timeout:
+            raise FTimeoutException('getMyInt timed out after {} milliseconds'.format(ctx.timeout))
+        finally:
+            self._transport.unregister(ctx)
+        return result
+
+    def _send_getMyInt(self, ctx):
+        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
+        oprot = self._protocol_factory.get_protocol(buffer)
+        oprot.write_request_headers(ctx)
+        oprot.writeMessageBegin('getMyInt', TMessageType.CALL, 0)
+        args = getMyInt_args()
+        args.write(oprot)
+        oprot.writeMessageEnd()
+        self._transport.send(buffer.getvalue())
+
+    def _recv_getMyInt(self, ctx, event):
+        def getMyInt_callback(transport):
+            iprot = self._protocol_factory.get_protocol(transport)
+            iprot.read_response_headers(ctx)
+            _, mtype, _ = iprot.readMessageBegin()
+            if mtype == TMessageType.EXCEPTION:
+                x = TApplicationException()
+                x.read(iprot)
+                iprot.readMessageEnd()
+                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
+                    event.set(FMessageSizeException.response(x.message))
+                    return
+                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
+                    event.set(FRateLimitException.response(x.message))
+                    return
+                event.set(x)
+                return
+            result = getMyInt_result()
+            result.read(iprot)
+            iprot.readMessageEnd()
+            if result.success is not None:
+                event.set(result.success)
+                return
+            raise TApplicationException(TApplicationException.MISSING_RESULT, "getMyInt failed: unknown result")
+        return getMyInt_callback
+
+    def use_subdir_struct(self, ctx, a):
+        """
+        Args:
+            ctx: FContext
+            a: subdir_include.A
+        """
+        return self._methods['use_subdir_struct']([ctx, a])
+
+    def _use_subdir_struct(self, ctx, a):
+        event = AsyncResult()
+        self._transport.register(ctx, self._recv_use_subdir_struct(ctx, event))
+        try:
+            self._send_use_subdir_struct(ctx, a)
+            result = event.get(timeout=ctx.timeout/1000)
+        except Timeout:
+            raise FTimeoutException('use_subdir_struct timed out after {} milliseconds'.format(ctx.timeout))
+        finally:
+            self._transport.unregister(ctx)
+        return result
+
+    def _send_use_subdir_struct(self, ctx, a):
+        buffer = TMemoryOutputBuffer(self._transport.get_request_size_limit())
+        oprot = self._protocol_factory.get_protocol(buffer)
+        oprot.write_request_headers(ctx)
+        oprot.writeMessageBegin('use_subdir_struct', TMessageType.CALL, 0)
+        args = use_subdir_struct_args()
+        args.a = a
+        args.write(oprot)
+        oprot.writeMessageEnd()
+        self._transport.send(buffer.getvalue())
+
+    def _recv_use_subdir_struct(self, ctx, event):
+        def use_subdir_struct_callback(transport):
+            iprot = self._protocol_factory.get_protocol(transport)
+            iprot.read_response_headers(ctx)
+            _, mtype, _ = iprot.readMessageBegin()
+            if mtype == TMessageType.EXCEPTION:
+                x = TApplicationException()
+                x.read(iprot)
+                iprot.readMessageEnd()
+                if x.type == FApplicationException.RESPONSE_TOO_LARGE:
+                    event.set(FMessageSizeException.response(x.message))
+                    return
+                if x.type == FApplicationException.RATE_LIMIT_EXCEEDED:
+                    event.set(FRateLimitException.response(x.message))
+                    return
+                event.set(x)
+                return
+            result = use_subdir_struct_result()
+            result.read(iprot)
+            iprot.readMessageEnd()
+            if result.success is not None:
+                event.set(result.success)
+                return
+            raise TApplicationException(TApplicationException.MISSING_RESULT, "use_subdir_struct failed: unknown result")
+        return use_subdir_struct_callback
+
+
+class Processor(actual_base.python.f_BaseFoo.Processor):
+
+    def __init__(self, handler, middleware=None):
+        """
+        Create a new Processor.
+
+        Args:
+            handler: Iface
+        """
+        if middleware and not isinstance(middleware, list):
+            middleware = [middleware]
+
+        super(Processor, self).__init__(handler, middleware=middleware)
+        self.add_to_processor_map('ping', _ping(Method(handler.ping, middleware), self.get_write_lock()))
+        self.add_to_processor_map('blah', _blah(Method(handler.blah, middleware), self.get_write_lock()))
+        self.add_to_processor_map('oneWay', _oneWay(Method(handler.oneWay, middleware), self.get_write_lock()))
+        self.add_to_processor_map('bin_method', _bin_method(Method(handler.bin_method, middleware), self.get_write_lock()))
+        self.add_to_processor_map('param_modifiers', _param_modifiers(Method(handler.param_modifiers, middleware), self.get_write_lock()))
+        self.add_to_processor_map('underlying_types_test', _underlying_types_test(Method(handler.underlying_types_test, middleware), self.get_write_lock()))
+        self.add_to_processor_map('getThing', _getThing(Method(handler.getThing, middleware), self.get_write_lock()))
+        self.add_to_processor_map('getMyInt', _getMyInt(Method(handler.getMyInt, middleware), self.get_write_lock()))
+        self.add_to_processor_map('use_subdir_struct', _use_subdir_struct(Method(handler.use_subdir_struct, middleware), self.get_write_lock()))
+
+
+class _ping(FProcessorFunction):
+
+    def __init__(self, handler, lock):
+        self._handler = handler
+        self._lock = lock
+
+    def process(self, ctx, iprot, oprot):
+        args = ping_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = ping_result()
+        try:
+            self._handler([ctx])
+        except FRateLimitException as ex:
+            with self._lock:
+                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "ping", ex.message)
+                return
+        except Exception as e:
+            with self._lock:
+                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "ping", e.message)
+            raise e
+        with self._lock:
+            try:
+                oprot.write_response_headers(ctx)
+                oprot.writeMessageBegin('ping', TMessageType.REPLY, 0)
+                result.write(oprot)
+                oprot.writeMessageEnd()
+                oprot.get_transport().flush()
+            except FMessageSizeException as e:
+                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "ping", e.message)
+
+
+class _blah(FProcessorFunction):
+
+    def __init__(self, handler, lock):
+        self._handler = handler
+        self._lock = lock
+
+    def process(self, ctx, iprot, oprot):
+        args = blah_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = blah_result()
+        try:
+            result.success = self._handler([ctx, args.num, args.Str, args.event])
+        except AwesomeException as awe:
+            result.awe = awe
+        except actual_base.python.ttypes.api_exception as api:
+            result.api = api
+        except FRateLimitException as ex:
+            with self._lock:
+                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "blah", ex.message)
+                return
+        except Exception as e:
+            with self._lock:
+                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "blah", e.message)
+            raise e
+        with self._lock:
+            try:
+                oprot.write_response_headers(ctx)
+                oprot.writeMessageBegin('blah', TMessageType.REPLY, 0)
+                result.write(oprot)
+                oprot.writeMessageEnd()
+                oprot.get_transport().flush()
+            except FMessageSizeException as e:
+                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "blah", e.message)
+
+
+class _oneWay(FProcessorFunction):
+
+    def __init__(self, handler, lock):
+        self._handler = handler
+        self._lock = lock
+
+    def process(self, ctx, iprot, oprot):
+        args = oneWay_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        try:
+            self._handler([ctx, args.id, args.req])
+        except FRateLimitException as ex:
+            with self._lock:
+                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "oneWay", ex.message)
+                return
+        except Exception as e:
+            raise e
+
+
+class _bin_method(FProcessorFunction):
+
+    def __init__(self, handler, lock):
+        self._handler = handler
+        self._lock = lock
+
+    def process(self, ctx, iprot, oprot):
+        args = bin_method_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = bin_method_result()
+        try:
+            result.success = self._handler([ctx, args.bin, args.Str])
+        except actual_base.python.ttypes.api_exception as api:
+            result.api = api
+        except FRateLimitException as ex:
+            with self._lock:
+                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "bin_method", ex.message)
+                return
+        except Exception as e:
+            with self._lock:
+                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "bin_method", e.message)
+            raise e
+        with self._lock:
+            try:
+                oprot.write_response_headers(ctx)
+                oprot.writeMessageBegin('bin_method', TMessageType.REPLY, 0)
+                result.write(oprot)
+                oprot.writeMessageEnd()
+                oprot.get_transport().flush()
+            except FMessageSizeException as e:
+                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "bin_method", e.message)
+
+
+class _param_modifiers(FProcessorFunction):
+
+    def __init__(self, handler, lock):
+        self._handler = handler
+        self._lock = lock
+
+    def process(self, ctx, iprot, oprot):
+        args = param_modifiers_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = param_modifiers_result()
+        try:
+            result.success = self._handler([ctx, args.opt_num, args.default_num, args.req_num])
+        except FRateLimitException as ex:
+            with self._lock:
+                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "param_modifiers", ex.message)
+                return
+        except Exception as e:
+            with self._lock:
+                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "param_modifiers", e.message)
+            raise e
+        with self._lock:
+            try:
+                oprot.write_response_headers(ctx)
+                oprot.writeMessageBegin('param_modifiers', TMessageType.REPLY, 0)
+                result.write(oprot)
+                oprot.writeMessageEnd()
+                oprot.get_transport().flush()
+            except FMessageSizeException as e:
+                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "param_modifiers", e.message)
+
+
+class _underlying_types_test(FProcessorFunction):
+
+    def __init__(self, handler, lock):
+        self._handler = handler
+        self._lock = lock
+
+    def process(self, ctx, iprot, oprot):
+        args = underlying_types_test_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = underlying_types_test_result()
+        try:
+            result.success = self._handler([ctx, args.list_type, args.set_type])
+        except FRateLimitException as ex:
+            with self._lock:
+                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "underlying_types_test", ex.message)
+                return
+        except Exception as e:
+            with self._lock:
+                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "underlying_types_test", e.message)
+            raise e
+        with self._lock:
+            try:
+                oprot.write_response_headers(ctx)
+                oprot.writeMessageBegin('underlying_types_test', TMessageType.REPLY, 0)
+                result.write(oprot)
+                oprot.writeMessageEnd()
+                oprot.get_transport().flush()
+            except FMessageSizeException as e:
+                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "underlying_types_test", e.message)
+
+
+class _getThing(FProcessorFunction):
+
+    def __init__(self, handler, lock):
+        self._handler = handler
+        self._lock = lock
+
+    def process(self, ctx, iprot, oprot):
+        args = getThing_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getThing_result()
+        try:
+            result.success = self._handler([ctx])
+        except FRateLimitException as ex:
+            with self._lock:
+                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "getThing", ex.message)
+                return
+        except Exception as e:
+            with self._lock:
+                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "getThing", e.message)
+            raise e
+        with self._lock:
+            try:
+                oprot.write_response_headers(ctx)
+                oprot.writeMessageBegin('getThing', TMessageType.REPLY, 0)
+                result.write(oprot)
+                oprot.writeMessageEnd()
+                oprot.get_transport().flush()
+            except FMessageSizeException as e:
+                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "getThing", e.message)
+
+
+class _getMyInt(FProcessorFunction):
+
+    def __init__(self, handler, lock):
+        self._handler = handler
+        self._lock = lock
+
+    def process(self, ctx, iprot, oprot):
+        args = getMyInt_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = getMyInt_result()
+        try:
+            result.success = self._handler([ctx])
+        except FRateLimitException as ex:
+            with self._lock:
+                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "getMyInt", ex.message)
+                return
+        except Exception as e:
+            with self._lock:
+                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "getMyInt", e.message)
+            raise e
+        with self._lock:
+            try:
+                oprot.write_response_headers(ctx)
+                oprot.writeMessageBegin('getMyInt', TMessageType.REPLY, 0)
+                result.write(oprot)
+                oprot.writeMessageEnd()
+                oprot.get_transport().flush()
+            except FMessageSizeException as e:
+                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "getMyInt", e.message)
+
+
+class _use_subdir_struct(FProcessorFunction):
+
+    def __init__(self, handler, lock):
+        self._handler = handler
+        self._lock = lock
+
+    def process(self, ctx, iprot, oprot):
+        args = use_subdir_struct_args()
+        args.read(iprot)
+        iprot.readMessageEnd()
+        result = use_subdir_struct_result()
+        try:
+            result.success = self._handler([ctx, args.a])
+        except FRateLimitException as ex:
+            with self._lock:
+                _write_application_exception(ctx, oprot, FApplicationException.RATE_LIMIT_EXCEEDED, "use_subdir_struct", ex.message)
+                return
+        except Exception as e:
+            with self._lock:
+                e = _write_application_exception(ctx, oprot, TApplicationException.UNKNOWN, "use_subdir_struct", e.message)
+            raise e
+        with self._lock:
+            try:
+                oprot.write_response_headers(ctx)
+                oprot.writeMessageBegin('use_subdir_struct', TMessageType.REPLY, 0)
+                result.write(oprot)
+                oprot.writeMessageEnd()
+                oprot.get_transport().flush()
+            except FMessageSizeException as e:
+                raise _write_application_exception(ctx, oprot, FApplicationException.RESPONSE_TOO_LARGE, "use_subdir_struct", e.message)
+
+
+def _write_application_exception(ctx, oprot, typ, method, message):
+    x = TApplicationException(type=typ, message=message)
+    oprot.write_response_headers(ctx)
+    oprot.writeMessageBegin(method, TMessageType.EXCEPTION, 0)
+    x.write(oprot)
+    oprot.writeMessageEnd()
+    oprot.get_transport().flush()
+    return x
+
+class ping_args(object):
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('ping_args')
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class ping_result(object):
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('ping_result')
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class blah_args(object):
+    """
+    Attributes:
+     - num
+     - Str
+     - event
+    """
+    def __init__(self, num=None, Str=None, event=None):
+        self.num = num
+        self.Str = Str
+        self.event = event
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.I32:
+                    self.num = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.Str = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.event = Event()
+                    self.event.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('blah_args')
+        if self.num is not None:
+            oprot.writeFieldBegin('num', TType.I32, 1)
+            oprot.writeI32(self.num)
+            oprot.writeFieldEnd()
+        if self.Str is not None:
+            oprot.writeFieldBegin('Str', TType.STRING, 2)
+            oprot.writeString(self.Str)
+            oprot.writeFieldEnd()
+        if self.event is not None:
+            oprot.writeFieldBegin('event', TType.STRUCT, 3)
+            self.event.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.num)
+        value = (value * 31) ^ hash(self.Str)
+        value = (value * 31) ^ hash(self.event)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class blah_result(object):
+    """
+    Attributes:
+     - success
+     - awe
+     - api
+    """
+    def __init__(self, success=None, awe=None, api=None):
+        self.success = success
+        self.awe = awe
+        self.api = api
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.I64:
+                    self.success = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.awe = AwesomeException()
+                    self.awe.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.api = actual_base.python.ttypes.api_exception()
+                    self.api.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('blah_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.I64, 0)
+            oprot.writeI64(self.success)
+            oprot.writeFieldEnd()
+        if self.awe is not None:
+            oprot.writeFieldBegin('awe', TType.STRUCT, 1)
+            self.awe.write(oprot)
+            oprot.writeFieldEnd()
+        if self.api is not None:
+            oprot.writeFieldBegin('api', TType.STRUCT, 2)
+            self.api.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.success)
+        value = (value * 31) ^ hash(self.awe)
+        value = (value * 31) ^ hash(self.api)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class oneWay_args(object):
+    """
+    Attributes:
+     - id
+     - req
+    """
+    def __init__(self, id=None, req=None):
+        self.id = id
+        self.req = req
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.I64:
+                    self.id = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.MAP:
+                    self.req = {}
+                    (_, _, elem42) = iprot.readMapBegin()
+                    for _ in range(elem42):
+                        elem44 = iprot.readI32()
+                        elem43 = iprot.readString()
+                        self.req[elem44] = elem43
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('oneWay_args')
+        if self.id is not None:
+            oprot.writeFieldBegin('id', TType.I64, 1)
+            oprot.writeI64(self.id)
+            oprot.writeFieldEnd()
+        if self.req is not None:
+            oprot.writeFieldBegin('req', TType.MAP, 2)
+            oprot.writeMapBegin(TType.I32, TType.STRING, len(self.req))
+            for elem46, elem45 in self.req.items():
+                oprot.writeI32(elem46)
+                oprot.writeString(elem45)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.id)
+        value = (value * 31) ^ hash(self.req)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class bin_method_args(object):
+    """
+    Attributes:
+     - bin
+     - Str
+    """
+    def __init__(self, bin=None, Str=None):
+        self.bin = bin
+        self.Str = Str
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRING:
+                    self.bin = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.Str = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('bin_method_args')
+        if self.bin is not None:
+            oprot.writeFieldBegin('bin', TType.STRING, 1)
+            oprot.writeBinary(self.bin)
+            oprot.writeFieldEnd()
+        if self.Str is not None:
+            oprot.writeFieldBegin('Str', TType.STRING, 2)
+            oprot.writeString(self.Str)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.bin)
+        value = (value * 31) ^ hash(self.Str)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class bin_method_result(object):
+    """
+    Attributes:
+     - success
+     - api
+    """
+    def __init__(self, success=None, api=None):
+        self.success = success
+        self.api = api
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRING:
+                    self.success = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 1:
+                if ftype == TType.STRUCT:
+                    self.api = actual_base.python.ttypes.api_exception()
+                    self.api.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('bin_method_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRING, 0)
+            oprot.writeBinary(self.success)
+            oprot.writeFieldEnd()
+        if self.api is not None:
+            oprot.writeFieldBegin('api', TType.STRUCT, 1)
+            self.api.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.success)
+        value = (value * 31) ^ hash(self.api)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class param_modifiers_args(object):
+    """
+    Attributes:
+     - opt_num
+     - default_num
+     - req_num
+    """
+    def __init__(self, opt_num=None, default_num=None, req_num=None):
+        self.opt_num = opt_num
+        self.default_num = default_num
+        self.req_num = req_num
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.I32:
+                    self.opt_num = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.I32:
+                    self.default_num = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.I32:
+                    self.req_num = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('param_modifiers_args')
+        if self.opt_num is not None:
+            oprot.writeFieldBegin('opt_num', TType.I32, 1)
+            oprot.writeI32(self.opt_num)
+            oprot.writeFieldEnd()
+        if self.default_num is not None:
+            oprot.writeFieldBegin('default_num', TType.I32, 2)
+            oprot.writeI32(self.default_num)
+            oprot.writeFieldEnd()
+        if self.req_num is not None:
+            oprot.writeFieldBegin('req_num', TType.I32, 3)
+            oprot.writeI32(self.req_num)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        if self.req_num is None:
+            raise TProtocol.TProtocolException(message='Required field req_num is unset!')
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.opt_num)
+        value = (value * 31) ^ hash(self.default_num)
+        value = (value * 31) ^ hash(self.req_num)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class param_modifiers_result(object):
+    """
+    Attributes:
+     - success
+    """
+    def __init__(self, success=None):
+        self.success = success
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.I64:
+                    self.success = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('param_modifiers_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.I64, 0)
+            oprot.writeI64(self.success)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.success)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class underlying_types_test_args(object):
+    """
+    Attributes:
+     - list_type
+     - set_type
+    """
+    def __init__(self, list_type=None, set_type=None):
+        self.list_type = list_type
+        self.set_type = set_type
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.LIST:
+                    self.list_type = []
+                    (_, elem47) = iprot.readListBegin()
+                    for _ in range(elem47):
+                        elem48 = iprot.readI64()
+                        self.list_type.append(elem48)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.SET:
+                    self.set_type = set()
+                    (_, elem49) = iprot.readSetBegin()
+                    for _ in range(elem49):
+                        elem50 = iprot.readI64()
+                        self.set_type.add(elem50)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('underlying_types_test_args')
+        if self.list_type is not None:
+            oprot.writeFieldBegin('list_type', TType.LIST, 1)
+            oprot.writeListBegin(TType.I64, len(self.list_type))
+            for elem51 in self.list_type:
+                oprot.writeI64(elem51)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.set_type is not None:
+            oprot.writeFieldBegin('set_type', TType.SET, 2)
+            oprot.writeSetBegin(TType.I64, len(self.set_type))
+            for elem52 in self.set_type:
+                oprot.writeI64(elem52)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.list_type)
+        value = (value * 31) ^ hash(self.set_type)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class underlying_types_test_result(object):
+    """
+    Attributes:
+     - success
+    """
+    def __init__(self, success=None):
+        self.success = success
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.LIST:
+                    self.success = []
+                    (_, elem53) = iprot.readListBegin()
+                    for _ in range(elem53):
+                        elem54 = iprot.readI64()
+                        self.success.append(elem54)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('underlying_types_test_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.LIST, 0)
+            oprot.writeListBegin(TType.I64, len(self.success))
+            for elem55 in self.success:
+                oprot.writeI64(elem55)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.success)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class getThing_args(object):
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('getThing_args')
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class getThing_result(object):
+    """
+    Attributes:
+     - success
+    """
+    def __init__(self, success=None):
+        self.success = success
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRUCT:
+                    self.success = validStructs.ttypes.Thing()
+                    self.success.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('getThing_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRUCT, 0)
+            self.success.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.success)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class getMyInt_args(object):
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('getMyInt_args')
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class getMyInt_result(object):
+    """
+    Attributes:
+     - success
+    """
+    def __init__(self, success=None):
+        self.success = success
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.I32:
+                    self.success = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('getMyInt_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.I32, 0)
+            oprot.writeI32(self.success)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.success)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class use_subdir_struct_args(object):
+    """
+    Attributes:
+     - a
+    """
+    def __init__(self, a=None):
+        self.a = a
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.a = subdir_include.ttypes.A()
+                    self.a.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('use_subdir_struct_args')
+        if self.a is not None:
+            oprot.writeFieldBegin('a', TType.STRUCT, 1)
+            self.a.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.a)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class use_subdir_struct_result(object):
+    """
+    Attributes:
+     - success
+    """
+    def __init__(self, success=None):
+        self.success = success
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 0:
+                if ftype == TType.STRUCT:
+                    self.success = subdir_include.ttypes.A()
+                    self.success.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('use_subdir_struct_result')
+        if self.success is not None:
+            oprot.writeFieldBegin('success', TType.STRUCT, 0)
+            self.success.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.success)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
diff --git a/test/expected/python.gevent/variety/ttypes.py b/test/expected/python.gevent/variety/ttypes.py
new file mode 100644
index 0000000..6079009
--- /dev/null
+++ b/test/expected/python.gevent/variety/ttypes.py
@@ -0,0 +1,1003 @@
+#
+# Autogenerated by Frugal Compiler (2.0.0-RC5)
+#
+# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
+#
+
+from thrift.Thrift import TType, TMessageType, TException, TApplicationException
+import actual_base.python.ttypes
+import actual_base.python.constants
+import validStructs.ttypes
+import validStructs.constants
+import ValidTypes.ttypes
+import ValidTypes.constants
+import subdir_include.ttypes
+import subdir_include.constants
+
+from thrift.transport import TTransport
+from thrift.protocol import TBinaryProtocol, TProtocol
+
+
+class HealthCondition(object):
+    PASS = 1
+    WARN = 2
+    FAIL = 3
+    UNKNOWN = 4
+
+    _VALUES_TO_NAMES = {
+        1: "PASS",
+        2: "WARN",
+        3: "FAIL",
+        4: "UNKNOWN",
+    }
+
+    _NAMES_TO_VALUES = {
+        "PASS": 1,
+        "WARN": 2,
+        "FAIL": 3,
+        "UNKNOWN": 4,
+    }
+
+class ItsAnEnum(object):
+    FIRST = 2
+    SECOND = 3
+    THIRD = 4
+    fourth = 5
+    Fifth = 6
+    sIxItH = 7
+
+    _VALUES_TO_NAMES = {
+        2: "FIRST",
+        3: "SECOND",
+        4: "THIRD",
+        5: "fourth",
+        6: "Fifth",
+        7: "sIxItH",
+    }
+
+    _NAMES_TO_VALUES = {
+        "FIRST": 2,
+        "SECOND": 3,
+        "THIRD": 4,
+        "fourth": 5,
+        "Fifth": 6,
+        "sIxItH": 7,
+    }
+
+class TestBase(object):
+    """
+    Attributes:
+     - base_struct
+    """
+    def __init__(self, base_struct=None):
+        self.base_struct = base_struct
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.STRUCT:
+                    self.base_struct = actual_base.python.ttypes.thing()
+                    self.base_struct.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('TestBase')
+        if self.base_struct is not None:
+            oprot.writeFieldBegin('base_struct', TType.STRUCT, 1)
+            self.base_struct.write(oprot)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.base_struct)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class TestLowercase(object):
+    """
+    Attributes:
+     - lowercaseInt
+    """
+    def __init__(self, lowercaseInt=None):
+        self.lowercaseInt = lowercaseInt
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.I32:
+                    self.lowercaseInt = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('TestLowercase')
+        if self.lowercaseInt is not None:
+            oprot.writeFieldBegin('lowercaseInt', TType.I32, 1)
+            oprot.writeI32(self.lowercaseInt)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.lowercaseInt)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class Event(object):
+    """
+    This docstring gets added to the generated code because it has
+    the @ sign.
+    
+    Attributes:
+     - ID: ID is a unique identifier for an event.
+     - Message: Message contains the event payload.
+    """
+    from . import constants
+    _DEFAULT_ID_MARKER = constants.DEFAULT_ID
+    def __init__(self, ID=_DEFAULT_ID_MARKER, Message=None):
+        self.ID = ID
+        self.Message = Message
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.I64:
+                    self.ID = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.Message = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('Event')
+        if self.ID is not None:
+            oprot.writeFieldBegin('ID', TType.I64, 1)
+            oprot.writeI64(self.ID)
+            oprot.writeFieldEnd()
+        if self.Message is not None:
+            oprot.writeFieldBegin('Message', TType.STRING, 2)
+            oprot.writeString(self.Message)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.ID)
+        value = (value * 31) ^ hash(self.Message)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class TestingDefaults(object):
+    """
+    Attributes:
+     - ID2
+     - ev1
+     - ev2
+     - ID
+     - thing
+     - thing2
+     - listfield
+     - ID3
+     - bin_field
+     - bin_field2
+     - bin_field3
+     - bin_field4
+     - list2
+     - list3
+     - list4
+     - a_map
+     - status
+     - base_status
+    """
+    from . import constants
+    _DEFAULT_ID2_MARKER = constants.DEFAULT_ID
+    _DEFAULT_ev1_MARKER = object()
+    _DEFAULT_ev2_MARKER = object()
+    _DEFAULT_ID_MARKER = -2
+    _DEFAULT_thing_MARKER = "a constant"
+    _DEFAULT_thing2_MARKER = "another constant"
+    _DEFAULT_listfield_MARKER = object()
+    _DEFAULT_ID3_MARKER = constants.other_default
+    _DEFAULT_bin_field4_MARKER = constants.bin_const
+    _DEFAULT_list2_MARKER = object()
+    _DEFAULT_list4_MARKER = object()
+    _DEFAULT_a_map_MARKER = object()
+    _DEFAULT_status_MARKER = HealthCondition.PASS
+    _DEFAULT_base_status_MARKER = actual_base.python.ttypes.base_health_condition.FAIL
+    def __init__(self, ID2=_DEFAULT_ID2_MARKER, ev1=_DEFAULT_ev1_MARKER, ev2=_DEFAULT_ev2_MARKER, ID=_DEFAULT_ID_MARKER, thing=_DEFAULT_thing_MARKER, thing2=_DEFAULT_thing2_MARKER, listfield=_DEFAULT_listfield_MARKER, ID3=_DEFAULT_ID3_MARKER, bin_field=None, bin_field2=None, bin_field3=None, bin_field4=_DEFAULT_bin_field4_MARKER, list2=_DEFAULT_list2_MARKER, list3=None, list4=_DEFAULT_list4_MARKER, a_map=_DEFAULT_a_map_MARKER, status=_DEFAULT_status_MARKER, base_status=_DEFAULT_base_status_MARKER):
+        self.ID2 = ID2
+        if ev1 is self._DEFAULT_ev1_MARKER:
+            ev1 = Event(**{
+                "ID": DEFAULT_ID,
+                "Message": "a message",
+            })
+        self.ev1 = ev1
+        if ev2 is self._DEFAULT_ev2_MARKER:
+            ev2 = Event(**{
+                "ID": 5,
+                "Message": "a message2",
+            })
+        self.ev2 = ev2
+        self.ID = ID
+        self.thing = thing
+        self.thing2 = thing2
+        if listfield is self._DEFAULT_listfield_MARKER:
+            listfield = [
+                1,
+                2,
+                3,
+                4,
+                5,
+            ]
+        self.listfield = listfield
+        self.ID3 = ID3
+        self.bin_field = bin_field
+        self.bin_field2 = bin_field2
+        self.bin_field3 = bin_field3
+        self.bin_field4 = bin_field4
+        if list2 is self._DEFAULT_list2_MARKER:
+            list2 = [
+                1,
+                3,
+                4,
+                5,
+                8,
+            ]
+        self.list2 = list2
+        self.list3 = list3
+        if list4 is self._DEFAULT_list4_MARKER:
+            list4 = [
+                1,
+                2,
+                3,
+                6,
+            ]
+        self.list4 = list4
+        if a_map is self._DEFAULT_a_map_MARKER:
+            a_map = {
+                "k1": "v1",
+                "k2": "v2",
+            }
+        self.a_map = a_map
+        self.status = status
+        self.base_status = base_status
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.I64:
+                    self.ID2 = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.ev1 = Event()
+                    self.ev1.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.STRUCT:
+                    self.ev2 = Event()
+                    self.ev2.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I64:
+                    self.ID = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.STRING:
+                    self.thing = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 6:
+                if ftype == TType.STRING:
+                    self.thing2 = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 7:
+                if ftype == TType.LIST:
+                    self.listfield = []
+                    (_, elem0) = iprot.readListBegin()
+                    for _ in range(elem0):
+                        elem1 = iprot.readI32()
+                        self.listfield.append(elem1)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 8:
+                if ftype == TType.I64:
+                    self.ID3 = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 9:
+                if ftype == TType.STRING:
+                    self.bin_field = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 10:
+                if ftype == TType.STRING:
+                    self.bin_field2 = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 11:
+                if ftype == TType.STRING:
+                    self.bin_field3 = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 12:
+                if ftype == TType.STRING:
+                    self.bin_field4 = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 13:
+                if ftype == TType.LIST:
+                    self.list2 = []
+                    (_, elem2) = iprot.readListBegin()
+                    for _ in range(elem2):
+                        elem3 = iprot.readI32()
+                        self.list2.append(elem3)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 14:
+                if ftype == TType.LIST:
+                    self.list3 = []
+                    (_, elem4) = iprot.readListBegin()
+                    for _ in range(elem4):
+                        elem5 = iprot.readI32()
+                        self.list3.append(elem5)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 15:
+                if ftype == TType.LIST:
+                    self.list4 = []
+                    (_, elem6) = iprot.readListBegin()
+                    for _ in range(elem6):
+                        elem7 = iprot.readI32()
+                        self.list4.append(elem7)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 16:
+                if ftype == TType.MAP:
+                    self.a_map = {}
+                    (_, _, elem8) = iprot.readMapBegin()
+                    for _ in range(elem8):
+                        elem10 = iprot.readString()
+                        elem9 = iprot.readString()
+                        self.a_map[elem10] = elem9
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 17:
+                if ftype == TType.I32:
+                    self.status = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 18:
+                if ftype == TType.I32:
+                    self.base_status = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('TestingDefaults')
+        if self.ID2 is not None:
+            oprot.writeFieldBegin('ID2', TType.I64, 1)
+            oprot.writeI64(self.ID2)
+            oprot.writeFieldEnd()
+        if self.ev1 is not None:
+            oprot.writeFieldBegin('ev1', TType.STRUCT, 2)
+            self.ev1.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ev2 is not None:
+            oprot.writeFieldBegin('ev2', TType.STRUCT, 3)
+            self.ev2.write(oprot)
+            oprot.writeFieldEnd()
+        if self.ID is not None:
+            oprot.writeFieldBegin('ID', TType.I64, 4)
+            oprot.writeI64(self.ID)
+            oprot.writeFieldEnd()
+        if self.thing is not None:
+            oprot.writeFieldBegin('thing', TType.STRING, 5)
+            oprot.writeString(self.thing)
+            oprot.writeFieldEnd()
+        if self.thing2 is not None:
+            oprot.writeFieldBegin('thing2', TType.STRING, 6)
+            oprot.writeString(self.thing2)
+            oprot.writeFieldEnd()
+        if self.listfield is not None:
+            oprot.writeFieldBegin('listfield', TType.LIST, 7)
+            oprot.writeListBegin(TType.I32, len(self.listfield))
+            for elem11 in self.listfield:
+                oprot.writeI32(elem11)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.ID3 is not None:
+            oprot.writeFieldBegin('ID3', TType.I64, 8)
+            oprot.writeI64(self.ID3)
+            oprot.writeFieldEnd()
+        if self.bin_field is not None:
+            oprot.writeFieldBegin('bin_field', TType.STRING, 9)
+            oprot.writeBinary(self.bin_field)
+            oprot.writeFieldEnd()
+        if self.bin_field2 is not None:
+            oprot.writeFieldBegin('bin_field2', TType.STRING, 10)
+            oprot.writeBinary(self.bin_field2)
+            oprot.writeFieldEnd()
+        if self.bin_field3 is not None:
+            oprot.writeFieldBegin('bin_field3', TType.STRING, 11)
+            oprot.writeBinary(self.bin_field3)
+            oprot.writeFieldEnd()
+        if self.bin_field4 is not None:
+            oprot.writeFieldBegin('bin_field4', TType.STRING, 12)
+            oprot.writeBinary(self.bin_field4)
+            oprot.writeFieldEnd()
+        if self.list2 is not None:
+            oprot.writeFieldBegin('list2', TType.LIST, 13)
+            oprot.writeListBegin(TType.I32, len(self.list2))
+            for elem12 in self.list2:
+                oprot.writeI32(elem12)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.list3 is not None:
+            oprot.writeFieldBegin('list3', TType.LIST, 14)
+            oprot.writeListBegin(TType.I32, len(self.list3))
+            for elem13 in self.list3:
+                oprot.writeI32(elem13)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.list4 is not None:
+            oprot.writeFieldBegin('list4', TType.LIST, 15)
+            oprot.writeListBegin(TType.I32, len(self.list4))
+            for elem14 in self.list4:
+                oprot.writeI32(elem14)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.a_map is not None:
+            oprot.writeFieldBegin('a_map', TType.MAP, 16)
+            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.a_map))
+            for elem16, elem15 in self.a_map.items():
+                oprot.writeString(elem16)
+                oprot.writeString(elem15)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.status is not None:
+            oprot.writeFieldBegin('status', TType.I32, 17)
+            oprot.writeI32(self.status)
+            oprot.writeFieldEnd()
+        if self.base_status is not None:
+            oprot.writeFieldBegin('base_status', TType.I32, 18)
+            oprot.writeI32(self.base_status)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        if self.status is None:
+            raise TProtocol.TProtocolException(message='Required field status is unset!')
+        if self.base_status is None:
+            raise TProtocol.TProtocolException(message='Required field base_status is unset!')
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.ID2)
+        value = (value * 31) ^ hash(self.ev1)
+        value = (value * 31) ^ hash(self.ev2)
+        value = (value * 31) ^ hash(self.ID)
+        value = (value * 31) ^ hash(self.thing)
+        value = (value * 31) ^ hash(self.thing2)
+        value = (value * 31) ^ hash(self.listfield)
+        value = (value * 31) ^ hash(self.ID3)
+        value = (value * 31) ^ hash(self.bin_field)
+        value = (value * 31) ^ hash(self.bin_field2)
+        value = (value * 31) ^ hash(self.bin_field3)
+        value = (value * 31) ^ hash(self.bin_field4)
+        value = (value * 31) ^ hash(self.list2)
+        value = (value * 31) ^ hash(self.list3)
+        value = (value * 31) ^ hash(self.list4)
+        value = (value * 31) ^ hash(self.a_map)
+        value = (value * 31) ^ hash(self.status)
+        value = (value * 31) ^ hash(self.base_status)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class EventWrapper(object):
+    """
+    Attributes:
+     - ID
+     - Ev
+     - Events
+     - Events2
+     - EventMap
+     - Nums
+     - Enums
+     - aBoolField
+     - a_union
+     - typedefOfTypedef
+    """
+    def __init__(self, ID=None, Ev=None, Events=None, Events2=None, EventMap=None, Nums=None, Enums=None, aBoolField=None, a_union=None, typedefOfTypedef=None):
+        self.ID = ID
+        self.Ev = Ev
+        self.Events = Events
+        self.Events2 = Events2
+        self.EventMap = EventMap
+        self.Nums = Nums
+        self.Enums = Enums
+        self.aBoolField = aBoolField
+        self.a_union = a_union
+        self.typedefOfTypedef = typedefOfTypedef
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.I64:
+                    self.ID = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRUCT:
+                    self.Ev = Event()
+                    self.Ev.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.LIST:
+                    self.Events = []
+                    (_, elem17) = iprot.readListBegin()
+                    for _ in range(elem17):
+                        elem18 = Event()
+                        elem18.read(iprot)
+                        self.Events.append(elem18)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.SET:
+                    self.Events2 = set()
+                    (_, elem19) = iprot.readSetBegin()
+                    for _ in range(elem19):
+                        elem20 = Event()
+                        elem20.read(iprot)
+                        self.Events2.add(elem20)
+                    iprot.readSetEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.MAP:
+                    self.EventMap = {}
+                    (_, _, elem21) = iprot.readMapBegin()
+                    for _ in range(elem21):
+                        elem23 = iprot.readI64()
+                        elem22 = Event()
+                        elem22.read(iprot)
+                        self.EventMap[elem23] = elem22
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 6:
+                if ftype == TType.LIST:
+                    self.Nums = []
+                    (_, elem24) = iprot.readListBegin()
+                    for _ in range(elem24):
+                        elem25 = []
+                        (_, elem26) = iprot.readListBegin()
+                        for _ in range(elem26):
+                            elem27 = iprot.readI32()
+                            elem25.append(elem27)
+                        iprot.readListEnd()
+                        self.Nums.append(elem25)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 7:
+                if ftype == TType.LIST:
+                    self.Enums = []
+                    (_, elem28) = iprot.readListBegin()
+                    for _ in range(elem28):
+                        elem29 = iprot.readI32()
+                        self.Enums.append(elem29)
+                    iprot.readListEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 8:
+                if ftype == TType.BOOL:
+                    self.aBoolField = iprot.readBool()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 9:
+                if ftype == TType.STRUCT:
+                    self.a_union = TestingUnions()
+                    self.a_union.read(iprot)
+                else:
+                    iprot.skip(ftype)
+            elif fid == 10:
+                if ftype == TType.STRING:
+                    self.typedefOfTypedef = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('EventWrapper')
+        if self.ID is not None:
+            oprot.writeFieldBegin('ID', TType.I64, 1)
+            oprot.writeI64(self.ID)
+            oprot.writeFieldEnd()
+        if self.Ev is not None:
+            oprot.writeFieldBegin('Ev', TType.STRUCT, 2)
+            self.Ev.write(oprot)
+            oprot.writeFieldEnd()
+        if self.Events is not None:
+            oprot.writeFieldBegin('Events', TType.LIST, 3)
+            oprot.writeListBegin(TType.STRUCT, len(self.Events))
+            for elem30 in self.Events:
+                elem30.write(oprot)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.Events2 is not None:
+            oprot.writeFieldBegin('Events2', TType.SET, 4)
+            oprot.writeSetBegin(TType.STRUCT, len(self.Events2))
+            for elem31 in self.Events2:
+                elem31.write(oprot)
+            oprot.writeSetEnd()
+            oprot.writeFieldEnd()
+        if self.EventMap is not None:
+            oprot.writeFieldBegin('EventMap', TType.MAP, 5)
+            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.EventMap))
+            for elem33, elem32 in self.EventMap.items():
+                oprot.writeI64(elem33)
+                elem32.write(oprot)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.Nums is not None:
+            oprot.writeFieldBegin('Nums', TType.LIST, 6)
+            oprot.writeListBegin(TType.LIST, len(self.Nums))
+            for elem34 in self.Nums:
+                oprot.writeListBegin(TType.I32, len(elem34))
+                for elem35 in elem34:
+                    oprot.writeI32(elem35)
+                oprot.writeListEnd()
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.Enums is not None:
+            oprot.writeFieldBegin('Enums', TType.LIST, 7)
+            oprot.writeListBegin(TType.I32, len(self.Enums))
+            for elem36 in self.Enums:
+                oprot.writeI32(elem36)
+            oprot.writeListEnd()
+            oprot.writeFieldEnd()
+        if self.aBoolField is not None:
+            oprot.writeFieldBegin('aBoolField', TType.BOOL, 8)
+            oprot.writeBool(self.aBoolField)
+            oprot.writeFieldEnd()
+        if self.a_union is not None:
+            oprot.writeFieldBegin('a_union', TType.STRUCT, 9)
+            self.a_union.write(oprot)
+            oprot.writeFieldEnd()
+        if self.typedefOfTypedef is not None:
+            oprot.writeFieldBegin('typedefOfTypedef', TType.STRING, 10)
+            oprot.writeString(self.typedefOfTypedef)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        if self.Ev is None:
+            raise TProtocol.TProtocolException(message='Required field Ev is unset!')
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.ID)
+        value = (value * 31) ^ hash(self.Ev)
+        value = (value * 31) ^ hash(self.Events)
+        value = (value * 31) ^ hash(self.Events2)
+        value = (value * 31) ^ hash(self.EventMap)
+        value = (value * 31) ^ hash(self.Nums)
+        value = (value * 31) ^ hash(self.Enums)
+        value = (value * 31) ^ hash(self.aBoolField)
+        value = (value * 31) ^ hash(self.a_union)
+        value = (value * 31) ^ hash(self.typedefOfTypedef)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class TestingUnions(object):
+    """
+    Attributes:
+     - AnID
+     - aString
+     - someotherthing
+     - AnInt16
+     - Requests
+     - bin_field_in_union
+    """
+    def __init__(self, AnID=None, aString=None, someotherthing=None, AnInt16=None, Requests=None, bin_field_in_union=None):
+        self.AnID = AnID
+        self.aString = aString
+        self.someotherthing = someotherthing
+        self.AnInt16 = AnInt16
+        self.Requests = Requests
+        self.bin_field_in_union = bin_field_in_union
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.I64:
+                    self.AnID = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.aString = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 3:
+                if ftype == TType.I32:
+                    self.someotherthing = iprot.readI32()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 4:
+                if ftype == TType.I16:
+                    self.AnInt16 = iprot.readI16()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 5:
+                if ftype == TType.MAP:
+                    self.Requests = {}
+                    (_, _, elem37) = iprot.readMapBegin()
+                    for _ in range(elem37):
+                        elem39 = iprot.readI32()
+                        elem38 = iprot.readString()
+                        self.Requests[elem39] = elem38
+                    iprot.readMapEnd()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 6:
+                if ftype == TType.STRING:
+                    self.bin_field_in_union = iprot.readBinary()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('TestingUnions')
+        if self.AnID is not None:
+            oprot.writeFieldBegin('AnID', TType.I64, 1)
+            oprot.writeI64(self.AnID)
+            oprot.writeFieldEnd()
+        if self.aString is not None:
+            oprot.writeFieldBegin('aString', TType.STRING, 2)
+            oprot.writeString(self.aString)
+            oprot.writeFieldEnd()
+        if self.someotherthing is not None:
+            oprot.writeFieldBegin('someotherthing', TType.I32, 3)
+            oprot.writeI32(self.someotherthing)
+            oprot.writeFieldEnd()
+        if self.AnInt16 is not None:
+            oprot.writeFieldBegin('AnInt16', TType.I16, 4)
+            oprot.writeI16(self.AnInt16)
+            oprot.writeFieldEnd()
+        if self.Requests is not None:
+            oprot.writeFieldBegin('Requests', TType.MAP, 5)
+            oprot.writeMapBegin(TType.I32, TType.STRING, len(self.Requests))
+            for elem41, elem40 in self.Requests.items():
+                oprot.writeI32(elem41)
+                oprot.writeString(elem40)
+            oprot.writeMapEnd()
+            oprot.writeFieldEnd()
+        if self.bin_field_in_union is not None:
+            oprot.writeFieldBegin('bin_field_in_union', TType.STRING, 6)
+            oprot.writeBinary(self.bin_field_in_union)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.AnID)
+        value = (value * 31) ^ hash(self.aString)
+        value = (value * 31) ^ hash(self.someotherthing)
+        value = (value * 31) ^ hash(self.AnInt16)
+        value = (value * 31) ^ hash(self.Requests)
+        value = (value * 31) ^ hash(self.bin_field_in_union)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
+class AwesomeException(TException):
+    """
+    Attributes:
+     - ID: ID is a unique identifier for an awesome exception.
+     - Reason: Reason contains the error message.
+    """
+    def __init__(self, ID=None, Reason=None):
+        self.ID = ID
+        self.Reason = Reason
+
+    def read(self, iprot):
+        iprot.readStructBegin()
+        while True:
+            (fname, ftype, fid) = iprot.readFieldBegin()
+            if ftype == TType.STOP:
+                break
+            if fid == 1:
+                if ftype == TType.I64:
+                    self.ID = iprot.readI64()
+                else:
+                    iprot.skip(ftype)
+            elif fid == 2:
+                if ftype == TType.STRING:
+                    self.Reason = iprot.readString()
+                else:
+                    iprot.skip(ftype)
+            else:
+                iprot.skip(ftype)
+            iprot.readFieldEnd()
+        iprot.readStructEnd()
+
+    def write(self, oprot):
+        oprot.writeStructBegin('AwesomeException')
+        if self.ID is not None:
+            oprot.writeFieldBegin('ID', TType.I64, 1)
+            oprot.writeI64(self.ID)
+            oprot.writeFieldEnd()
+        if self.Reason is not None:
+            oprot.writeFieldBegin('Reason', TType.STRING, 2)
+            oprot.writeString(self.Reason)
+            oprot.writeFieldEnd()
+        oprot.writeFieldStop()
+        oprot.writeStructEnd()
+
+    def validate(self):
+        return
+
+    def __str__(self):
+        return repr(self)
+
+    def __hash__(self):
+        value = 17
+        value = (value * 31) ^ hash(self.ID)
+        value = (value * 31) ^ hash(self.Reason)
+        return value
+
+    def __repr__(self):
+        L = ['%s=%r' % (key, value)
+            for key, value in self.__dict__.items()]
+        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))
+
+    def __eq__(self, other):
+        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__
+
+    def __ne__(self, other):
+        return not (self == other)
+
diff --git a/test/expected/python.tornado/actual_base/f_BaseFoo.py b/test/expected/python.tornado/actual_base/f_BaseFoo.py
index 950bed9..f95e067 100644
--- a/test/expected/python.tornado/actual_base/f_BaseFoo.py
+++ b/test/expected/python.tornado/actual_base/f_BaseFoo.py
@@ -132,7 +132,8 @@ class Processor(FBaseProcessor):
 class _basePing(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_basePing, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     @gen.coroutine
     def process(self, ctx, iprot, oprot):
diff --git a/test/expected/python.tornado/variety/f_Foo.py b/test/expected/python.tornado/variety/f_Foo.py
index 3c1f28d..31a350b 100644
--- a/test/expected/python.tornado/variety/f_Foo.py
+++ b/test/expected/python.tornado/variety/f_Foo.py
@@ -727,7 +727,8 @@ class Processor(actual_base.python.f_BaseFoo.Processor):
 class _ping(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_ping, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     @gen.coroutine
     def process(self, ctx, iprot, oprot):
@@ -759,7 +760,8 @@ class _ping(FProcessorFunction):
 class _blah(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_blah, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     @gen.coroutine
     def process(self, ctx, iprot, oprot):
@@ -795,7 +797,8 @@ class _blah(FProcessorFunction):
 class _oneWay(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_oneWay, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     @gen.coroutine
     def process(self, ctx, iprot, oprot):
@@ -815,7 +818,8 @@ class _oneWay(FProcessorFunction):
 class _bin_method(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_bin_method, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     @gen.coroutine
     def process(self, ctx, iprot, oprot):
@@ -849,7 +853,8 @@ class _bin_method(FProcessorFunction):
 class _param_modifiers(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_param_modifiers, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     @gen.coroutine
     def process(self, ctx, iprot, oprot):
@@ -881,7 +886,8 @@ class _param_modifiers(FProcessorFunction):
 class _underlying_types_test(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_underlying_types_test, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     @gen.coroutine
     def process(self, ctx, iprot, oprot):
@@ -913,7 +919,8 @@ class _underlying_types_test(FProcessorFunction):
 class _getThing(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_getThing, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     @gen.coroutine
     def process(self, ctx, iprot, oprot):
@@ -945,7 +952,8 @@ class _getThing(FProcessorFunction):
 class _getMyInt(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_getMyInt, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     @gen.coroutine
     def process(self, ctx, iprot, oprot):
@@ -977,7 +985,8 @@ class _getMyInt(FProcessorFunction):
 class _use_subdir_struct(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_use_subdir_struct, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     @gen.coroutine
     def process(self, ctx, iprot, oprot):
diff --git a/test/expected/python/actual_base/f_BaseFoo.py b/test/expected/python/actual_base/f_BaseFoo.py
index 8a5e4fb..f3121f2 100644
--- a/test/expected/python/actual_base/f_BaseFoo.py
+++ b/test/expected/python/actual_base/f_BaseFoo.py
@@ -106,7 +106,8 @@ class Processor(FBaseProcessor):
 class _basePing(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_basePing, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     def process(self, ctx, iprot, oprot):
         args = basePing_args()
diff --git a/test/expected/python/package_prefix/f_Foo.py b/test/expected/python/package_prefix/f_Foo.py
index 0ce131b..648da4d 100644
--- a/test/expected/python/package_prefix/f_Foo.py
+++ b/test/expected/python/package_prefix/f_Foo.py
@@ -112,7 +112,8 @@ class Processor(generic_package_prefix.actual_base.python.f_BaseFoo.Processor):
 class _get_thing(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_get_thing, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     def process(self, ctx, iprot, oprot):
         args = get_thing_args()
diff --git a/test/expected/python/variety/f_Foo.py b/test/expected/python/variety/f_Foo.py
index 5045b1c..73d2674 100644
--- a/test/expected/python/variety/f_Foo.py
+++ b/test/expected/python/variety/f_Foo.py
@@ -564,7 +564,8 @@ class Processor(actual_base.python.f_BaseFoo.Processor):
 class _ping(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_ping, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     def process(self, ctx, iprot, oprot):
         args = ping_args()
@@ -592,7 +593,8 @@ class _ping(FProcessorFunction):
 class _blah(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_blah, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     def process(self, ctx, iprot, oprot):
         args = blah_args()
@@ -624,7 +626,8 @@ class _blah(FProcessorFunction):
 class _oneWay(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_oneWay, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     def process(self, ctx, iprot, oprot):
         args = oneWay_args()
@@ -643,7 +646,8 @@ class _oneWay(FProcessorFunction):
 class _bin_method(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_bin_method, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     def process(self, ctx, iprot, oprot):
         args = bin_method_args()
@@ -673,7 +677,8 @@ class _bin_method(FProcessorFunction):
 class _param_modifiers(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_param_modifiers, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     def process(self, ctx, iprot, oprot):
         args = param_modifiers_args()
@@ -701,7 +706,8 @@ class _param_modifiers(FProcessorFunction):
 class _underlying_types_test(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_underlying_types_test, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     def process(self, ctx, iprot, oprot):
         args = underlying_types_test_args()
@@ -729,7 +735,8 @@ class _underlying_types_test(FProcessorFunction):
 class _getThing(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_getThing, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     def process(self, ctx, iprot, oprot):
         args = getThing_args()
@@ -757,7 +764,8 @@ class _getThing(FProcessorFunction):
 class _getMyInt(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_getMyInt, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     def process(self, ctx, iprot, oprot):
         args = getMyInt_args()
@@ -785,7 +793,8 @@ class _getMyInt(FProcessorFunction):
 class _use_subdir_struct(FProcessorFunction):
 
     def __init__(self, handler, lock):
-        super(_use_subdir_struct, self).__init__(handler, lock)
+        self._handler = handler
+        self._lock = lock
 
     def process(self, ctx, iprot, oprot):
         args = use_subdir_struct_args()
diff --git a/test/python_test.go b/test/python_test.go
index 3701285..6448b52 100644
--- a/test/python_test.go
+++ b/test/python_test.go
@@ -69,6 +69,39 @@ func TestValidPythonTornado(t *testing.T) {
 	compareFiles(t, "expected/python.tornado/actual_base/f_BaseFoo.py", baseFooPath)
 }
 
+
+func TestValidPythonGevent(t *testing.T) {
+	options := compiler.Options{
+		File:    frugalGenFile,
+		Gen:     "py:gevent",
+		Out:     outputDir + "/gevent",
+		Delim:   delim,
+		Recurse: true,
+	}
+	if err := compiler.Compile(options); err != nil {
+		t.Fatal("unexpected error", err)
+	}
+
+	varietyConstantsPath := filepath.Join(outputDir, "gevent", "variety", "python", "constants.py")
+	compareFiles(t, "expected/python.gevent/variety/constants.py", varietyConstantsPath)
+	varietyFtypesPath := filepath.Join(outputDir, "gevent", "variety", "python", "ttypes.py")
+	compareFiles(t, "expected/python.gevent/variety/ttypes.py", varietyFtypesPath)
+	eventsPublisherPath := filepath.Join(outputDir, "gevent", "variety", "python", "f_Events_publisher.py")
+	compareFiles(t, "expected/python.gevent/variety/f_Events_publisher.py", eventsPublisherPath)
+	eventsSubscriberPath := filepath.Join(outputDir, "gevent", "variety", "python", "f_Events_subscriber.py")
+	compareFiles(t, "expected/python.gevent/variety/f_Events_subscriber.py", eventsSubscriberPath)
+	fooServicePath := filepath.Join(outputDir, "gevent", "variety", "python", "f_Foo.py")
+	compareFiles(t, "expected/python.gevent/variety/f_Foo.py", fooServicePath)
+
+	baseConstantsPath := filepath.Join(outputDir, "gevent", "actual_base", "python", "constants.py")
+	compareFiles(t, "expected/python.gevent/actual_base/constants.py", baseConstantsPath)
+	baseFtypesPath := filepath.Join(outputDir, "gevent", "actual_base", "python", "ttypes.py")
+	compareFiles(t, "expected/python.gevent/actual_base/ttypes.py", baseFtypesPath)
+	baseFooPath := filepath.Join(outputDir, "gevent", "actual_base", "python", "f_BaseFoo.py")
+	compareFiles(t, "expected/python.gevent/actual_base/f_BaseFoo.py", baseFooPath)
+}
+
+
 func TestValidPythonAsyncIO(t *testing.T) {
 	options := compiler.Options{
 		File:    frugalGenFile,
