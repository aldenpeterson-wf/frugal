#
# Autogenerated by Frugal Compiler (1.18.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#



from threading import Lock

from frugal.middleware import Method
from frugal.processor import FBaseProcessor
from frugal.processor import FProcessorFunction
from thrift.Thrift import TApplicationException
from thrift.Thrift import TMessageType

import base
from event.Foo import *
from event.ttypes import *


class Iface(base.f_BaseFoo.Iface):
    """
    This is a thrift service. Frugal will generate bindings that include 
    a frugal Context for each service call.
    """

    def ping(self, ctx):
        """
        Ping the server.
        
        Args:
            ctx: FContext
        """
        pass

    def blah(self, ctx, num, Str, event):
        """
        Blah the server.
        
        Args:
            ctx: FContext
            num: int (signed 32 bits)
            Str: string
            event: Event
        """
        pass

    def oneWay(self, ctx, id, req):
        """
        oneway methods don't receive a response from the server.
        
        Args:
            ctx: FContext
            id: int (signed 64 bits)
            req: dict of <int (signed 32 bits), string>
        """
        pass


class Client(base.f_BaseFoo.Client, Iface):

    def __init__(self, transport, protocol_factory, middleware=None):
        """
        Create a new Client with a transport and protocol factory.

        Args:
            transport: FSynchronousTransport
            protocol_factory: FProtocolFactory
            middleware: ServiceMiddleware or list of ServiceMiddleware
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]
        super(Client, self).__init__(transport, protocol_factory,
                                     middleware=middleware)
        self._methods.update({
            'ping': Method(self._ping, middleware),
            'blah': Method(self._blah, middleware),
            'oneWay': Method(self._oneWay, middleware),
        })

    def ping(self, ctx):
        """
        Ping the server.
        
        Args:
            ctx: FContext
        """
        return self._methods['ping']([ctx])

    def _ping(self, ctx):
        self._send_ping(ctx)
        self._recv_ping(ctx)

    def _send_ping(self, ctx):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.get_timeout())
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('ping', TMessageType.CALL, 0)
            args = ping_args()
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_ping(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            raise x
        result = ping_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        return

    def blah(self, ctx, num, Str, event):
        """
        Blah the server.
        
        Args:
            ctx: FContext
            num: int (signed 32 bits)
            Str: string
            event: Event
        """
        return self._methods['blah']([ctx, num, Str, event])

    def _blah(self, ctx, num, Str, event):
        self._send_blah(ctx, num, Str, event)
        return self._recv_blah(ctx)

    def _send_blah(self, ctx, num, Str, event):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.get_timeout())
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('blah', TMessageType.CALL, 0)
            args = blah_args()
            args.num = num
            args.Str = Str
            args.event = event
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_blah(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            raise x
        result = blah_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        if result.awe is not None:
            raise result.awe
        if result.api is not None:
            raise result.api
        if result.success is not None:
            return result.success
        x = TApplicationException(TApplicationException.MISSING_RESULT, "blah failed: unknown result")
        raise x

    def oneWay(self, ctx, id, req):
        """
        oneway methods don't receive a response from the server.
        
        Args:
            ctx: FContext
            id: int (signed 64 bits)
            req: dict of <int (signed 32 bits), string>
        """
        return self._methods['oneWay']([ctx, id, req])

    def _oneWay(self, ctx, id, req):
        self._send_oneWay(ctx, id, req)

    def _send_oneWay(self, ctx, id, req):
        oprot = self._oprot
        with self._write_lock:
            oprot.get_transport().set_timeout(ctx.get_timeout())
            oprot.write_request_headers(ctx)
            oprot.writeMessageBegin('oneWay', TMessageType.CALL, 0)
            args = oneWay_args()
            args.id = id
            args.req = req
            args.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()

    def _recv_oneWay(self, ctx):
        self._iprot.read_response_headers(ctx)
        _, mtype, _ = self._iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(self._iprot)
            self._iprot.readMessageEnd()
            raise x
        result = oneWay_result()
        result.read(self._iprot)
        self._iprot.readMessageEnd()
        return

class Processor(base.f_BaseFoo.Processor):

    def __init__(self, handler, middleware=None):
        """
        Create a new Processor.

        Args:
            handler: Iface
        """
        if middleware and not isinstance(middleware, list):
            middleware = [middleware]

        super(Processor, self).__init__(handler, middleware=middleware)
        self.add_to_processor_map('ping', _ping(Method(handler.ping, middleware), self.get_write_lock()))
        self.add_to_processor_map('blah', _blah(Method(handler.blah, middleware), self.get_write_lock()))
        self.add_to_processor_map('oneWay', _oneWay(Method(handler.oneWay, middleware), self.get_write_lock()))


class _ping(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    def process(self, ctx, iprot, oprot):
        args = ping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ping_result()
        self._handler([ctx])
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('ping', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _blah(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    def process(self, ctx, iprot, oprot):
        args = blah_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = blah_result()
        try:
            result.success = self._handler.blah(ctx, args.num, args.Str, args.event)
        except AwesomeException as awe:
            result.awe = awe
        except base.ttypes.api_exception as api:
            result.api = api
        with self._lock:
            oprot.write_response_headers(ctx)
            oprot.writeMessageBegin('blah', TMessageType.REPLY, 0)
            result.write(oprot)
            oprot.writeMessageEnd()
            oprot.get_transport().flush()


class _oneWay(FProcessorFunction):

    def __init__(self, handler, lock):
        self._handler = handler
        self._lock = lock

    def process(self, ctx, iprot, oprot):
        args = oneWay_args()
        args.read(iprot)
        iprot.readMessageEnd()
        self._handler([ctx, args.id, args.req])


